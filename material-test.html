<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Glass Material Test</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: #000;
        font-family: Arial, sans-serif;
      }

      #container {
        width: 100vw;
        height: 100vh;
        position: relative;
      }

      canvas {
        display: block;
      }

      /* Leva controls will be positioned automatically */
    </style>
  </head>
  <body>
    <div id="container"></div>

    <script type="module">
      import * as THREE from "three";
      import { useControls } from "leva";

      // Scene setup
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });

      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.physicallyCorrectLights = true;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1;
      document.getElementById("container").appendChild(renderer.domElement);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 5, 5);
      scene.add(directionalLight);

      // Background
      scene.background = new THREE.Color(0x222222);

      // Test geometry
      const geometry = new THREE.SphereGeometry(1, 32, 32);

      // Create material with controls
      const materialProps = useControls({
        thickness: { value: 0.2, min: 0, max: 3, step: 0.05 },
        roughness: { value: 0, min: 0, max: 1, step: 0.1 },
        transmission: { value: 1, min: 0, max: 1, step: 0.1 },
        ior: { value: 1.2, min: 0, max: 3, step: 0.1 },
        opacity: { value: 0.3, min: 0, max: 1, step: 0.01 },
        envMapIntensity: { value: 2.0, min: 0, max: 5, step: 0.1 },
        clearcoat: { value: 1.0, min: 0, max: 1, step: 0.01 },
        clearcoatRoughness: { value: 0.0, min: 0, max: 1, step: 0.01 },
        reflectivity: { value: 0.9, min: 0, max: 1, step: 0.01 },
        backside: { value: true },
      });

      // Create material
      const material = new THREE.MeshPhysicalMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: materialProps.opacity,
        transmission: materialProps.transmission,
        roughness: materialProps.roughness,
        metalness: 0.0,
        ior: materialProps.ior,
        clearcoat: materialProps.clearcoat,
        clearcoatRoughness: materialProps.clearcoatRoughness,
        side: materialProps.backside ? THREE.DoubleSide : THREE.FrontSide,
        depthWrite: false,
        depthTest: true,
        envMapIntensity: materialProps.envMapIntensity,
        reflectivity: materialProps.reflectivity,
      });

      const sphere = new THREE.Mesh(geometry, material);
      scene.add(sphere);

      // Background objects for distortion testing
      const bgGeometry = new THREE.BoxGeometry(2, 2, 0.1);
      const bgMaterial = new THREE.MeshBasicMaterial({ color: 0xff4444 });
      const bgCube = new THREE.Mesh(bgGeometry, bgMaterial);
      bgCube.position.z = -3;
      scene.add(bgCube);

      const bgSphere = new THREE.SphereGeometry(0.5, 16, 16);
      const bgSphereMat = new THREE.MeshBasicMaterial({ color: 0x44ff44 });
      const bgSphereObj = new THREE.Mesh(bgSphere, bgSphereMat);
      bgSphereObj.position.set(-2, 1, -2);
      scene.add(bgSphereObj);

      // Position camera
      camera.position.z = 3;

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        // Update material properties
        material.opacity = materialProps.opacity;
        material.transmission = materialProps.transmission;
        material.roughness = materialProps.roughness;
        material.ior = materialProps.ior;
        material.clearcoat = materialProps.clearcoat;
        material.clearcoatRoughness = materialProps.clearcoatRoughness;
        material.envMapIntensity = materialProps.envMapIntensity;
        material.reflectivity = materialProps.reflectivity;
        material.side = materialProps.backside
          ? THREE.DoubleSide
          : THREE.FrontSide;
        material.needsUpdate = true;

        // Rotate objects
        sphere.rotation.x += 0.01;
        sphere.rotation.y += 0.01;

        bgCube.rotation.x += 0.005;
        bgSphereObj.position.x = Math.sin(Date.now() * 0.001) * 2;

        renderer.render(scene, camera);
      }

      animate();

      // Handle resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
