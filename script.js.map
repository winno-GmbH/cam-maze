{"version":3,"file":"script.js","mappings":"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","sources":["webpack://cam-3d-animation/./src/config/dom-elements.ts","webpack://cam-3d-animation/./src/core/materials.ts","webpack://cam-3d-animation/./src/animation/home-scroll.ts","webpack://cam-3d-animation/./src/core/debug-hud.ts","webpack://cam-3d-animation/./src/animation/constants.ts","webpack://cam-3d-animation/external var \"gsap\"","webpack://cam-3d-animation/./src/core/material-utils.ts","webpack://cam-3d-animation/./src/animation/scene-presets.ts","webpack://cam-3d-animation/./src/config/config.ts","webpack://cam-3d-animation/./src/animation/intro-scroll.ts","webpack://cam-3d-animation/./src/animation/object-state.ts","webpack://cam-3d-animation/./src/paths/paths.ts","webpack://cam-3d-animation/./src/core/scene.ts","webpack://cam-3d-animation/./src/animation/scene-utils.ts","webpack://cam-3d-animation/./src/core/camera.ts","webpack://cam-3d-animation/external var \"ScrollTrigger\"","webpack://cam-3d-animation/./src/animation/util.ts","webpack://cam-3d-animation/external var \"THREE\"","webpack://cam-3d-animation/./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js","webpack://cam-3d-animation/./src/core/objects.ts","webpack://cam-3d-animation/./src/paths/coordinates.ts","webpack://cam-3d-animation/./src/paths/pathpoints.ts","webpack://cam-3d-animation/webpack/bootstrap","webpack://cam-3d-animation/webpack/runtime/compat get default export","webpack://cam-3d-animation/webpack/runtime/define property getters","webpack://cam-3d-animation/webpack/runtime/hasOwnProperty shorthand","webpack://cam-3d-animation/webpack/runtime/make namespace object","webpack://cam-3d-animation/./src/animation/home-loop.ts","webpack://cam-3d-animation/./src/animation/pov-scroll.ts","webpack://cam-3d-animation/./src/animation/outro-scroll.ts","webpack://cam-3d-animation/./src/main.ts"],"sourcesContent":["import { SCROLL_SELECTORS } from \"../animation/constants\";\n\nconst SELECTORS = {\n  mazeContainer: \".el--home-maze.el\",\n  canvas: \"canvas\",\n\n  homeSection: SCROLL_SELECTORS.HOME,\n  introSection: SCROLL_SELECTORS.INTRO,\n  povSection: SCROLL_SELECTORS.POV,\n  finalSection: SCROLL_SELECTORS.OUTRO,\n  finalContainer: \".cr--outro.cr\",\n\n  scrollComponent: \".cmp--scroll.cmp\",\n  parentElements: \".cmp--pov.cmp\",\n\n  pov: \".pov\",\n  cam: \".cam\",\n};\n\nexport const DOM_ELEMENTS = {\n  mazeContainer: document.querySelector(SELECTORS.mazeContainer) as HTMLElement,\n  canvas: document.querySelector(SELECTORS.canvas) as HTMLCanvasElement,\n\n  homeSection: document.querySelector(SELECTORS.homeSection) as HTMLElement,\n  introSection: document.querySelector(SELECTORS.introSection) as HTMLElement,\n  povSection: document.querySelector(SELECTORS.povSection) as HTMLElement,\n  finalSection: document.querySelector(SELECTORS.finalSection) as HTMLElement,\n  finalContainer: document.querySelector(\n    SELECTORS.finalContainer\n  ) as HTMLElement,\n\n  parentElements: document.querySelectorAll(\n    SELECTORS.parentElements\n  ) as NodeListOf<Element>,\n};\n","import * as THREE from \"three\";\nimport { ASSETS } from \"../config/config\";\n\nconst textureLoader = new THREE.TextureLoader();\n\nconst mazeTexture = textureLoader.load(ASSETS.mazeTexture);\n\nexport const mazeMaterial = new THREE.MeshMatcapMaterial({\n  matcap: mazeTexture,\n});\n\nexport const topMaterial = new THREE.MeshStandardMaterial({\n  color: 0xf2f9f9,\n  metalness: 0.4,\n  roughness: 0,\n  envMapIntensity: 10,\n});\n\nexport const ghostMaterial = new THREE.MeshPhysicalMaterial({\n  color: 0xffffff,\n  opacity: 0.9999,\n  transparent: true,\n  depthWrite: false,\n  depthTest: true,\n  blending: THREE.NormalBlending,\n  side: THREE.DoubleSide,\n  roughness: 0.75,\n  metalness: 0.2,\n  transmission: 0.5,\n});\n\nexport const floorMaterial = new THREE.MeshStandardMaterial({\n  color: 0xffffff,\n  opacity: 0.8,\n  transparent: true,\n  roughness: 0.5,\n  metalness: 0.1,\n});\n\nconst pacmanMaterials = {\n  blue: new THREE.MeshBasicMaterial({\n    color: 0x1469d3,\n    transparent: true,\n    opacity: 1,\n  }),\n  white: new THREE.MeshBasicMaterial({\n    color: 0xffffff,\n    transparent: true,\n    opacity: 1,\n  }),\n  default: new THREE.MeshBasicMaterial({\n    color: 0x1469d3,\n    transparent: true,\n    opacity: 1,\n  }),\n};\n\n// White/clear glass material for bottom half of pill shell\nconst pillFrontGlass = new THREE.MeshPhysicalMaterial({\n  color: 0xffffff, // Pure white - no tint\n  metalness: 0.0,\n  roughness: 0.05,\n  transmission: 1.0, // Full transmission for completely clear glass\n  thickness: 0.5,\n  ior: 1.5,\n  reflectivity: 0.5,\n  clearcoat: 1.0,\n  clearcoatRoughness: 0.1,\n  transparent: true,\n  opacity: 1.0,\n  side: THREE.DoubleSide,\n  envMapIntensity: 1.0,\n});\n\n// Orange, nearly intransparent material for top half of pill shell\nconst pillBackGlass = new THREE.MeshPhysicalMaterial({\n  color: 0xff6600, // Pure orange (not too dark)\n  metalness: 0.0,\n  roughness: 0.05,\n  transmission: 0.2, // Very low transmission - nearly intransparent\n  thickness: 0.5,\n  ior: 1.5,\n  reflectivity: 0.5,\n  clearcoat: 1.0,\n  clearcoatRoughness: 0.1,\n  transparent: true,\n  opacity: 0.98, // Nearly opaque\n  side: THREE.DoubleSide,\n  envMapIntensity: 1.0,\n});\n\n// Legacy orange glass (kept for backwards compatibility, but should use front/back materials)\nconst pillOrangeGlass = new THREE.MeshPhysicalMaterial({\n  color: 0xff4400,\n  metalness: 0.0,\n  roughness: 0.05,\n  transmission: 0.9,\n  thickness: 0.5,\n  ior: 1.5,\n  reflectivity: 0.5,\n  clearcoat: 1.0,\n  clearcoatRoughness: 0.1,\n  transparent: true,\n  opacity: 1.0,\n  side: THREE.DoubleSide,\n  envMapIntensity: 1.0,\n});\n\n// Orange material for Bitcoin in center\nconst pillBitcoinOrange = new THREE.MeshStandardMaterial({\n  color: 0xff6600, // Orange - same as glass\n  roughness: 0.3,\n  metalness: 0.2,\n});\n\n// Black material for inner elements (will appear orange-tinted through the glass)\nconst pillInnerBlack = new THREE.MeshStandardMaterial({\n  color: 0x000000, // Black\n  roughness: 0.5,\n  metalness: 0.1,\n});\n\nconst pillMaterials = {\n  shell: pillOrangeGlass,\n  shellFront: pillFrontGlass,\n  shellBack: pillBackGlass,\n  bitcoin: pillBitcoinOrange, // Bitcoin is fully orange\n  default: pillInnerBlack, // Inner elements are black\n};\n\nexport const materialMap = {\n  CAM_Pacman_Backframe: pacmanMaterials.blue,\n  \"CAM-Pacman_Bitcoin_1\": pacmanMaterials.white,\n  \"CAM-Pacman_Bitcoin_2\": pacmanMaterials.white,\n  \"CAM-Pacman_Bottom\": pacmanMaterials.blue,\n  \"CAM-Pacman_Top\": pacmanMaterials.blue,\n  \"CAM-Pacman_Eye\": pacmanMaterials.white,\n  CAM_Pacman_Logo_1: pacmanMaterials.white,\n  CAM_Pacman_Logo_2: pacmanMaterials.white,\n  \"CAM-Pacman_Shell_Boolean\": pacmanMaterials.blue,\n  \"CAM-Pacman_Shell\": pacmanMaterials.blue,\n  \"CAM-Pacman_Bottom_electronic\": pacmanMaterials.white,\n  \"CAM-Pacman_Top_electronic\": pacmanMaterials.white,\n  \"CAM-Pacman_Bottom_Text\": pacmanMaterials.white,\n  \"CAM-Pacman_Top_Text\": pacmanMaterials.white,\n  default: pacmanMaterials.blue,\n};\n\nexport const pillMaterialMap = {\n  shell: pillMaterials.shell,\n  shellFront: pillMaterials.shellFront,\n  shellBack: pillMaterials.shellBack,\n  bitcoin: pillMaterials.bitcoin,\n  default: pillMaterials.default,\n};\n","import gsap from \"gsap\";\nimport ScrollTrigger from \"gsap/ScrollTrigger\";\nimport * as THREE from \"three\";\nimport { camera } from \"../core/camera\";\nimport { ghosts, pacmanMixer } from \"../core/objects\";\nimport { clock, onFrame } from \"../core/scene\";\nimport { getCameraHomeScrollPathPoints } from \"../paths/pathpoints\";\nimport { getHomeScrollPaths } from \"../paths/paths\";\nimport { LAY_DOWN_QUAT_1 } from \"./util\";\n// Pacman rotation offsets (X=90, Y=180, Z=0 for correct end position)\nconst PACMAN_ROTATION_OFFSETS = { x: 90, y: 180, z: 0 };\nimport { applyHomeScrollPreset, getScrollDirection } from \"./scene-presets\";\nimport {\n  getCurrentRotations,\n  getCurrentPositions,\n  getHomeLoopStartPositions,\n  getHomeLoopStartRotations,\n} from \"./object-state\";\nimport {\n  setObjectOpacity,\n  getObjectOpacity,\n  forEachMaterial,\n  setMaterialOpacity,\n} from \"../core/material-utils\";\nimport { killObjectAnimations } from \"./scene-utils\";\nimport {\n  SCROLL_SELECTORS,\n  SCRUB_DURATION,\n  STAGGER_AMOUNT,\n  OPACITY,\n} from \"./constants\";\nimport { ghostMaterial, materialMap, pillMaterialMap } from \"../core/materials\";\n\nlet homeScrollTimeline: gsap.core.Timeline | null = null;\nconst originalFOV = 50;\n\nlet startPositions: Record<string, THREE.Vector3> = {};\nlet allObjects: Array<[string, THREE.Object3D]> = [];\n// Track cloned materials for disposal\nconst clonedMaterials: THREE.Material[] = [];\n// Cache for paths to avoid recalculation\nlet cachedPaths: Record<string, THREE.CurvePath<THREE.Vector3>> | null = null;\nlet cachedPathsKey: string | null = null;\n\nexport function initHomeScrollAnimation() {\n  if (homeScrollTimeline) {\n    homeScrollTimeline.kill();\n    homeScrollTimeline = null;\n  }\n\n  const cameraPathPoints = getCameraHomeScrollPathPoints();\n\n  const cameraPath = new THREE.CurvePath<THREE.Vector3>();\n  if (cameraPathPoints.length === 4) {\n    const cameraCurve = new THREE.CubicBezierCurve3(\n      cameraPathPoints[0].pos,\n      cameraPathPoints[1].pos,\n      cameraPathPoints[2].pos,\n      cameraPathPoints[3].pos\n    );\n    cameraPath.add(cameraCurve);\n  }\n\n  const disposeClonedMaterials = () => {\n    clonedMaterials.forEach((mat) => {\n      mat.dispose();\n    });\n    clonedMaterials.length = 0;\n  };\n\n  const handleScrollLeave = () => {\n    const introScrollTrigger = ScrollTrigger.getById(\"introScroll\");\n    // Kill all object animations and reset opacity when leaving home-scroll\n    allObjects.forEach(([key, object]) => {\n      killObjectAnimations(object);\n      setObjectOpacity(object, 1.0, {\n        preserveTransmission: true,\n        skipCurrencySymbols: true,\n      });\n    });\n    // Dispose cloned materials to prevent memory leaks\n    disposeClonedMaterials();\n  };\n\n  const handleScrollEnter = () => {\n    requestAnimationFrame(() => {\n      const introScrollTrigger = ScrollTrigger.getById(\"introScroll\");\n      if (introScrollTrigger?.isActive) {\n        return;\n      }\n\n      const homeLoopStartPos = getHomeLoopStartPositions();\n      const homeLoopStartRot = getHomeLoopStartRotations();\n      const scrollDir = getScrollDirection();\n\n      Object.entries(ghosts).forEach(([key, object]) => {\n        if (homeLoopStartPos[key]) {\n          object.position.copy(homeLoopStartPos[key]);\n          startPositions[key] = homeLoopStartPos[key].clone();\n        } else {\n          const currentPositions = getCurrentPositions();\n          const position = currentPositions[key] || object.position;\n          object.position.copy(position);\n          startPositions[key] = position.clone();\n        }\n\n        if (homeLoopStartRot[key]) {\n          object.quaternion.copy(homeLoopStartRot[key]);\n        }\n      });\n\n      const rotationsToUse =\n        Object.keys(homeLoopStartRot).length > 0\n          ? homeLoopStartRot\n          : getCurrentRotations();\n\n      applyHomeScrollPreset(true, scrollDir, startPositions, rotationsToUse);\n\n      createObjectAnimations();\n    });\n  };\n\n  homeScrollTimeline = gsap.timeline({\n    scrollTrigger: {\n      id: \"homeScroll\",\n      trigger: SCROLL_SELECTORS.HOME,\n      start: \"top top\",\n      end: \"bottom top\",\n      scrub: SCRUB_DURATION,\n      markers: false,\n      refreshPriority: 0,\n      invalidateOnRefresh: false,\n      onEnter: handleScrollEnter,\n      onEnterBack: handleScrollEnter,\n      onUpdate: (self) => {\n        if (cameraPath && cameraPath.curves.length) {\n          const progress = self.progress;\n          const clampedProgress = Math.min(1, Math.max(0, progress));\n\n          // Camera: starts at 0%, ends at 100%\n          // Should start fast, then slow down (ease-out) - but gentler and slower\n          // Use a gentler ease-out curve (exponent 1.5 instead of 2) for slower, smoother acceleration\n          const cameraProgress = 1 - Math.pow(1 - clampedProgress, 1.5); // Gentler ease-out for slower camera movement\n\n          const cameraPoint = cameraPath.getPointAt(cameraProgress);\n          camera.position.copy(cameraPoint);\n\n          const lookAtPoints: THREE.Vector3[] = [];\n          cameraPathPoints.forEach((point) => {\n            if (\"lookAt\" in point && point.lookAt) {\n              lookAtPoints.push(point.lookAt);\n            }\n          });\n\n          if (lookAtPoints.length >= 4) {\n            // Use original Bezier curve with all 4 lookAt points\n            const lookAtCurve = new THREE.CubicBezierCurve3(\n              lookAtPoints[0],\n              lookAtPoints[1],\n              lookAtPoints[2],\n              lookAtPoints[3]\n            );\n            const lookAtPoint = lookAtCurve.getPointAt(cameraProgress);\n            camera.lookAt(lookAtPoint);\n\n            // Always override Z rotation: interpolate from -17 to 0 based on progress\n            // Interpolate Z rotation from -17 (at 0%) to 0 (at 100%)\n            const targetZRotation = -17 + cameraProgress * 17; // -17 to 0\n\n            // Get current rotation and override Z\n            const currentEuler = new THREE.Euler().setFromQuaternion(\n              camera.quaternion\n            );\n            // Override Z rotation directly\n            currentEuler.z = (targetZRotation * Math.PI) / 180;\n            // Apply the modified rotation\n            camera.quaternion.setFromEuler(currentEuler);\n\n            const euler = new THREE.Euler().setFromQuaternion(\n              camera.quaternion\n            );\n            console.log(\n              `Progress: ${(clampedProgress * 100).toFixed(\n                1\n              )}% | Rotation: X=${((euler.x * 180) / Math.PI).toFixed(2)} Y=${(\n                (euler.y * 180) /\n                Math.PI\n              ).toFixed(2)} Z=${((euler.z * 180) / Math.PI).toFixed(2)}`\n            );\n          } else if (lookAtPoints.length >= 4) {\n            // Fallback to lookAt only\n            const lookAtCurve = new THREE.CubicBezierCurve3(\n              lookAtPoints[0]!,\n              lookAtPoints[1]!,\n              lookAtPoints[2]!,\n              lookAtPoints[3]!\n            );\n            const lookAtPoint = lookAtCurve.getPointAt(cameraProgress);\n            camera.lookAt(lookAtPoint);\n\n            const euler = new THREE.Euler().setFromQuaternion(\n              camera.quaternion\n            );\n            console.log(\n              `Progress: ${(clampedProgress * 100).toFixed(\n                1\n              )}% | Rotation: X=${((euler.x * 180) / Math.PI).toFixed(2)} Y=${(\n                (euler.y * 180) /\n                Math.PI\n              ).toFixed(2)} Z=${((euler.z * 180) / Math.PI).toFixed(2)}`\n            );\n          }\n          camera.fov = originalFOV;\n          camera.updateProjectionMatrix();\n        }\n      },\n      onLeave: handleScrollLeave,\n      onLeaveBack: handleScrollLeave,\n    },\n  });\n\n  allObjects = Object.entries(ghosts);\n  allObjects.forEach(([key, object]) => {\n    startPositions[key] = object.position.clone();\n  });\n\n  const createObjectAnimations = () => {\n    if (homeScrollTimeline) {\n      homeScrollTimeline.clear();\n    }\n\n    allObjects.forEach(([key, object]) => {\n      killObjectAnimations(object);\n    });\n\n    // Dispose old cloned materials before creating new ones\n    disposeClonedMaterials();\n\n    // Check if paths need to be recalculated\n    const pathsKey = JSON.stringify(startPositions);\n    let homeScrollPaths: Record<string, THREE.CurvePath<THREE.Vector3>>;\n    if (cachedPaths && cachedPathsKey === pathsKey) {\n      homeScrollPaths = cachedPaths;\n    } else {\n      homeScrollPaths = getHomeScrollPaths(startPositions);\n      cachedPaths = homeScrollPaths;\n      cachedPathsKey = pathsKey;\n    }\n\n    const animPropsArray: any[] = [];\n    const animationData: Array<{\n      key: string;\n      object: THREE.Object3D;\n      path: THREE.CurvePath<THREE.Vector3>;\n      startEuler: THREE.Euler;\n      endEuler: THREE.Euler;\n    }> = [];\n\n    allObjects.forEach(([key, object]) => {\n      const currentMaterialOpacity = getObjectOpacity(object);\n\n      forEachMaterial(\n        object,\n        (mat: any, mesh: THREE.Mesh) => {\n          // Only clone if material is shared (not already cloned)\n          const isSharedMaterial =\n            mat === ghostMaterial ||\n            Object.values(materialMap).includes(mat) ||\n            Object.values(pillMaterialMap).includes(mat);\n\n          let clonedMat: THREE.Material;\n          if (\n            isSharedMaterial ||\n            !mesh.material ||\n            Array.isArray(mesh.material)\n          ) {\n            clonedMat = mat.clone();\n            clonedMaterials.push(clonedMat);\n            setMaterialOpacity(clonedMat, currentMaterialOpacity, true);\n\n            if (Array.isArray(mesh.material)) {\n              const index = mesh.material.indexOf(mat);\n              if (index !== -1) {\n                const newMaterials = [...mesh.material];\n                newMaterials[index] = clonedMat;\n                mesh.material = newMaterials;\n              }\n            } else {\n              mesh.material = clonedMat;\n            }\n          } else {\n            // Material already cloned, just update opacity\n            setMaterialOpacity(mat, currentMaterialOpacity, true);\n          }\n        },\n        { skipCurrencySymbols: false }\n      );\n\n      const homeLoopStartRot = getHomeLoopStartRotations();\n      const startRot =\n        homeLoopStartRot[key] ||\n        getCurrentRotations()[key] ||\n        object.quaternion.clone();\n      const startEuler = new THREE.Euler().setFromQuaternion(startRot);\n\n      // For Pacman: Use rotation offsets from HUD sliders directly in end rotation\n      // This allows testing the end rotation by adjusting HUD values\n      let endEuler: THREE.Euler;\n      if (key === \"pacman\") {\n        // Use fixed rotation offsets for correct end position\n        const offsets = PACMAN_ROTATION_OFFSETS;\n\n        // Start with LAY_DOWN_QUAT_1, then apply rotation offsets\n        const xRotation = new THREE.Quaternion().setFromAxisAngle(\n          new THREE.Vector3(1, 0, 0),\n          (offsets.x * Math.PI) / 180\n        );\n        const yRotation = new THREE.Quaternion().setFromAxisAngle(\n          new THREE.Vector3(0, 1, 0),\n          (offsets.y * Math.PI) / 180\n        );\n        const zRotation = new THREE.Quaternion().setFromAxisAngle(\n          new THREE.Vector3(0, 0, 1),\n          (offsets.z * Math.PI) / 180\n        );\n\n        // Combine rotations: LAY_DOWN_QUAT_1 * Y * X * Z\n        const pacmanLayDown = LAY_DOWN_QUAT_1.clone()\n          .multiply(yRotation)\n          .multiply(xRotation)\n          .multiply(zRotation);\n        endEuler = new THREE.Euler().setFromQuaternion(pacmanLayDown);\n      } else {\n        // Ghosts use standard lay down rotation\n        endEuler = new THREE.Euler().setFromQuaternion(LAY_DOWN_QUAT_1);\n      }\n\n      const path = homeScrollPaths[key];\n      if (!path) {\n        return;\n      }\n\n      const animProps = {\n        progress: 0,\n        rotX: startEuler.x,\n        rotY: startEuler.y,\n        rotZ: startEuler.z,\n        opacity: currentMaterialOpacity,\n      };\n\n      animPropsArray.push(animProps);\n      animationData.push({\n        key,\n        object,\n        path,\n        startEuler,\n        endEuler,\n      });\n    });\n\n    // Define start and end scroll percentages for each object\n    // Format: [start%, end%]\n    const objectTimings = [\n      [0.0, 0.7], // Pacman: start 0%, end 70%\n      [0.05, 0.75], // Ghost1: start 5%, end 75%\n      [0.1, 0.8], // Ghost2: start 10%, end 80%\n      [0.15, 0.85], // Ghost3: start 15%, end 85%\n      [0.2, 0.9], // Ghost4: start 20%, end 90%\n      [0.25, 0.95], // Ghost5: start 25%, end 95%\n    ];\n\n    const baseDuration = 1.0;\n    const staggerOffset = STAGGER_AMOUNT;\n\n    animationData.forEach((data, index) => {\n      const animProps = animPropsArray[index];\n      const timing = objectTimings[index] || [0, 1];\n      const [startPercent, endPercent] = timing;\n\n      // Calculate start time and duration based on percentages\n      const startTime = startPercent;\n      const duration = endPercent - startPercent;\n\n      const startPathPoint = data.path.getPointAt(0);\n      data.object.position.copy(startPathPoint);\n\n      homeScrollTimeline!.fromTo(\n        animProps,\n        {\n          progress: 0,\n          rotX: data.startEuler.x,\n          rotY: data.startEuler.y,\n          rotZ: data.startEuler.z,\n          opacity: animProps.opacity,\n        },\n        {\n          progress: 1,\n          rotX: data.endEuler.x,\n          rotY: data.endEuler.y,\n          rotZ: data.endEuler.z,\n          opacity: OPACITY.HIDDEN,\n          ease: \"power2.out\",\n          immediateRender: false,\n          duration: duration,\n          onUpdate: function () {\n            const introScrollTrigger = ScrollTrigger.getById(\"introScroll\");\n            const homeScrollTrigger = ScrollTrigger.getById(\"homeScroll\");\n            // Don't update if intro scroll is active or home scroll is not active\n            if (introScrollTrigger?.isActive || !homeScrollTrigger?.isActive) {\n              return;\n            }\n\n            // Map scroll progress to object animation progress\n            // animProps.progress is 0-1 within the object's animation window\n            // Apply same easing to both position and rotation\n            const rawProgress = animProps.progress;\n            const easedProgress = rawProgress * rawProgress * rawProgress; // Cubic ease-in\n\n            // Position uses eased progress\n            const pathPoint = data.path.getPointAt(easedProgress);\n            data.object.position.copy(pathPoint);\n\n            // Rotation also uses eased progress for smooth animation\n            // Apply same rotation logic for all objects (Pacman and Ghosts)\n            let startEuler = data.startEuler;\n            let endEuler = data.endEuler;\n\n            // For Pacman: Recalculate end rotation from HUD values in real-time and overwrite state\n            let finalRotX: number;\n            let finalRotY: number;\n            let finalRotZ: number;\n\n            if (data.key === \"pacman\") {\n              // Use fixed rotation offsets\n              const offsets = PACMAN_ROTATION_OFFSETS;\n              const xRotation = new THREE.Quaternion().setFromAxisAngle(\n                new THREE.Vector3(1, 0, 0),\n                (offsets.x * Math.PI) / 180\n              );\n              const yRotation = new THREE.Quaternion().setFromAxisAngle(\n                new THREE.Vector3(0, 1, 0),\n                (offsets.y * Math.PI) / 180\n              );\n              const zRotation = new THREE.Quaternion().setFromAxisAngle(\n                new THREE.Vector3(0, 0, 1),\n                (offsets.z * Math.PI) / 180\n              );\n              const pacmanLayDown = LAY_DOWN_QUAT_1.clone()\n                .multiply(yRotation)\n                .multiply(xRotation)\n                .multiply(zRotation);\n              const newEndEuler = new THREE.Euler().setFromQuaternion(\n                pacmanLayDown\n              );\n\n              // Calculate eased rotation using the new endEuler\n              finalRotX =\n                startEuler.x + (newEndEuler.x - startEuler.x) * easedProgress;\n              finalRotY =\n                startEuler.y + (newEndEuler.y - startEuler.y) * easedProgress;\n              finalRotZ =\n                startEuler.z + (newEndEuler.z - startEuler.z) * easedProgress;\n\n              // Update pacmanMixer if this is Pacman (to keep mouth animation running)\n              if (pacmanMixer) {\n                pacmanMixer.update(clock.getDelta());\n              }\n            } else {\n              // For ghosts: use standard calculation\n              finalRotX =\n                startEuler.x + (endEuler.x - startEuler.x) * easedProgress;\n              finalRotY =\n                startEuler.y + (endEuler.y - startEuler.y) * easedProgress;\n              finalRotZ =\n                startEuler.z + (endEuler.z - startEuler.z) * easedProgress;\n            }\n\n            // Set rotation for all objects - FORCE apply to overwrite any other rotation state\n            // This ensures the rotation is always applied, even if something else tries to override it\n            data.object.rotation.set(finalRotX, finalRotY, finalRotZ);\n            data.object.quaternion.setFromEuler(data.object.rotation);\n            data.object.updateMatrixWorld(false);\n\n            // For Pacman: Set rotation again in next frame to ensure it's not overwritten\n            // This is a workaround to ensure the rotation persists after pacmanMixer.update()\n            if (data.key === \"pacman\") {\n              requestAnimationFrame(() => {\n                // Only apply if we're still in home-scroll\n                const homeScrollTrigger = ScrollTrigger.getById(\"homeScroll\");\n                if (homeScrollTrigger?.isActive && data.object) {\n                  data.object.rotation.set(finalRotX, finalRotY, finalRotZ);\n                  data.object.quaternion.setFromEuler(data.object.rotation);\n                  data.object.updateMatrixWorld(false);\n                }\n              });\n            }\n\n            // Opacity animation: starts fading at 80% of the animation progress\n            // From 0% to 80%: opacity stays at 1.0\n            // From 80% to 100%: opacity fades from 1.0 to 0.0\n            const opacityFadeStart = 0.8;\n            let finalOpacity: number;\n            if (rawProgress < opacityFadeStart) {\n              // Before fade start: full opacity\n              finalOpacity = OPACITY.FULL;\n            } else {\n              // During fade: map progress from [0.8, 1.0] to opacity [1.0, 0.0]\n              const fadeProgress =\n                (rawProgress - opacityFadeStart) / (1.0 - opacityFadeStart);\n              finalOpacity = OPACITY.FULL * (1 - fadeProgress);\n            }\n\n            setObjectOpacity(data.object, finalOpacity, {\n              preserveTransmission: true,\n              skipCurrencySymbols: true,\n            });\n          },\n        },\n        startTime // Start time offset for stagger\n      );\n    });\n  };\n\n  createObjectAnimations();\n}\n","import * as THREE from \"three\";\nimport ScrollTrigger from \"gsap/ScrollTrigger\";\nimport { pill } from \"./objects\";\n\n// Global variable to store Y rotation in degrees\nlet pillYRotationDegrees = 20;\n\nexport function getPillYRotationDegrees(): number {\n  return pillYRotationDegrees;\n}\n\n// Global variables to store Pacman rotation offsets in degrees (for home-scroll animation)\n// Default values set to correct end position: X=90, Y=180, Z=0\nlet pacmanRotationX = 90;\nlet pacmanRotationY = 180;\nlet pacmanRotationZ = 0;\n\nexport function getPacmanRotationOffsets(): { x: number; y: number; z: number } {\n  return { x: pacmanRotationX, y: pacmanRotationY, z: pacmanRotationZ };\n}\n\n// Global variables to store Pacman rotation for intro-scroll animation\n// Initialized from current intro-scroll rotation + 180 on Y axis\nlet introPacmanRotationX = 0;\nlet introPacmanRotationY = 0;\nlet introPacmanRotationZ = 0;\n\nexport function getIntroPacmanRotation(): { x: number; y: number; z: number } {\n  return { x: introPacmanRotationX, y: introPacmanRotationY, z: introPacmanRotationZ };\n}\n\nfunction applyPillRotation(): void {\n  if (!pill) return;\n  \n  // Set rotation: X=1.571 (90), Y from slider, Z=180 ()\n  const targetEuler = new THREE.Euler(\n    1.571, // X: 90 degrees (/2)\n    (pillYRotationDegrees * Math.PI) / 180, // Y: from HUD slider\n    (180 * Math.PI) / 180, // Z: 180 degrees ()\n    \"XYZ\"\n  );\n  pill.rotation.copy(targetEuler);\n}\n\nlet hudContainer: HTMLDivElement | null = null;\nlet isVisible = false;\n\nlet pacmanHudContainer: HTMLDivElement | null = null;\nlet isPacmanHudVisible = false;\n\nexport function createPillDebugHUD(): void {\n  if (hudContainer) {\n    return; // Already created\n  }\n\n  // Create container\n  hudContainer = document.createElement(\"div\");\n  hudContainer.id = \"pill-debug-hud\";\n  hudContainer.style.cssText = `\n    position: fixed;\n    top: 20px;\n    right: 20px;\n    width: 300px;\n    background: rgba(20, 20, 20, 0.95);\n    color: #e0e0e0;\n    padding: 20px;\n    border-radius: 8px;\n    font-family: 'Courier New', monospace;\n    font-size: 13px;\n    z-index: 10000;\n    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);\n    border: 2px solid #4CAF50;\n  `;\n\n  // Toggle button\n  const toggleBtn = document.createElement(\"button\");\n  toggleBtn.textContent = \"Show/Hide Pill Rotation\";\n  toggleBtn.style.cssText = `\n    position: fixed;\n    top: 20px;\n    right: 340px;\n    padding: 10px 15px;\n    background: #4CAF50;\n    color: white;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    z-index: 10001;\n    font-size: 14px;\n    font-weight: bold;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n  `;\n  toggleBtn.addEventListener(\"click\", (e) => {\n    e.stopPropagation();\n    e.preventDefault();\n    isVisible = !isVisible;\n    if (hudContainer) {\n      hudContainer.style.display = isVisible ? \"block\" : \"none\";\n    }\n  });\n\n  document.body.appendChild(toggleBtn);\n  document.body.appendChild(hudContainer);\n  hudContainer.style.display = \"none\";\n\n  updateHUD();\n  // Apply initial rotation\n  applyPillRotation();\n}\n\nfunction updateHUD(): void {\n  if (!hudContainer) return;\n\n  hudContainer.innerHTML = `\n    <h3 style=\"margin-top: 0; color: #4CAF50; font-size: 16px; text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);\">Pill Y Rotation</h3>\n    \n    <div style=\"margin-bottom: 15px; color: #e0e0e0;\">\n      <label for=\"pill-y-rotation-slider\" style=\"display: block; margin-bottom: 10px;\">\n        <strong style=\"color: #ffffff;\">Y Rotation (degrees):</strong>\n        <span id=\"pill-y-rotation-value\" style=\"color: #4CAF50; margin-left: 10px; font-weight: bold;\">${pillYRotationDegrees}</span>\n      </label>\n      <input \n        type=\"range\" \n        id=\"pill-y-rotation-slider\" \n        min=\"0\" \n        max=\"360\" \n        value=\"${pillYRotationDegrees}\"\n        step=\"1\"\n        style=\"width: 100%; height: 8px; border-radius: 5px; outline: none; background: #333; cursor: pointer;\"\n      />\n    </div>\n  `;\n\n  // Attach event listener\n  const slider = hudContainer.querySelector(\"#pill-y-rotation-slider\") as HTMLInputElement;\n  const valueDisplay = hudContainer.querySelector(\"#pill-y-rotation-value\");\n  \n  if (slider) {\n    slider.addEventListener(\"input\", (e) => {\n      const target = e.target as HTMLInputElement;\n      pillYRotationDegrees = parseFloat(target.value);\n      if (valueDisplay) {\n        valueDisplay.textContent = `${pillYRotationDegrees}`;\n      }\n      // Apply rotation immediately when slider changes\n      applyPillRotation();\n    });\n  }\n}\n\n// Auto-refresh HUD periodically (disabled since we don't need it for slider)\nlet refreshInterval: number | null = null;\n\nexport function startHUDRefresh(intervalMs: number = 1000): void {\n  // No longer needed for slider, but keeping function signature for compatibility\n  if (refreshInterval) {\n    clearInterval(refreshInterval);\n  }\n}\n\nexport function stopHUDRefresh(): void {\n  if (refreshInterval) {\n    clearInterval(refreshInterval);\n    refreshInterval = null;\n  }\n}\n\nexport function createPacmanRotationHUD(): void {\n  if (pacmanHudContainer) {\n    return; // Already created\n  }\n\n  // Create container\n  pacmanHudContainer = document.createElement(\"div\");\n  pacmanHudContainer.id = \"pacman-rotation-hud\";\n  pacmanHudContainer.style.cssText = `\n    position: fixed;\n    top: 20px;\n    left: 20px;\n    width: 320px;\n    background: rgba(20, 20, 20, 0.95);\n    color: #e0e0e0;\n    padding: 20px;\n    border-radius: 8px;\n    font-family: 'Courier New', monospace;\n    font-size: 13px;\n    z-index: 10000;\n    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);\n    border: 2px solid #FFD700;\n    max-height: 90vh;\n    overflow-y: auto;\n  `;\n\n  // Toggle button\n  const toggleBtn = document.createElement(\"button\");\n  toggleBtn.textContent = \"Show/Hide Pacman Rotation\";\n  toggleBtn.style.cssText = `\n    position: fixed;\n    top: 20px;\n    left: 360px;\n    padding: 10px 15px;\n    background: #FFD700;\n    color: #000;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    z-index: 10001;\n    font-size: 14px;\n    font-weight: bold;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n  `;\n  toggleBtn.addEventListener(\"click\", (e) => {\n    e.stopPropagation();\n    e.preventDefault();\n    isPacmanHudVisible = !isPacmanHudVisible;\n    if (pacmanHudContainer) {\n      pacmanHudContainer.style.display = isPacmanHudVisible ? \"block\" : \"none\";\n    }\n  });\n\n  document.body.appendChild(toggleBtn);\n  document.body.appendChild(pacmanHudContainer);\n  pacmanHudContainer.style.display = \"none\";\n\n  updatePacmanHUD();\n}\n\nfunction updatePacmanHUD(): void {\n  if (!pacmanHudContainer) return;\n\n  pacmanHudContainer.innerHTML = `\n    <h3 style=\"margin-top: 0; color: #FFD700; font-size: 16px; text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);\">Pacman Rotation (Home-Scroll)</h3>\n    \n    <div style=\"margin-bottom: 15px; color: #e0e0e0;\">\n      <label for=\"pacman-x-rotation-slider\" style=\"display: block; margin-bottom: 10px;\">\n        <strong style=\"color: #ffffff;\">X Rotation (degrees):</strong>\n        <span id=\"pacman-x-rotation-value\" style=\"color: #FFD700; margin-left: 10px; font-weight: bold;\">${pacmanRotationX}</span>\n      </label>\n      <input \n        type=\"range\" \n        id=\"pacman-x-rotation-slider\" \n        min=\"-180\" \n        max=\"180\" \n        value=\"${pacmanRotationX}\"\n        step=\"1\"\n        style=\"width: 100%; height: 8px; border-radius: 5px; outline: none; background: #333; cursor: pointer;\"\n      />\n    </div>\n    \n    <div style=\"margin-bottom: 15px; color: #e0e0e0;\">\n      <label for=\"pacman-y-rotation-slider\" style=\"display: block; margin-bottom: 10px;\">\n        <strong style=\"color: #ffffff;\">Y Rotation (degrees):</strong>\n        <span id=\"pacman-y-rotation-value\" style=\"color: #FFD700; margin-left: 10px; font-weight: bold;\">${pacmanRotationY}</span>\n      </label>\n      <input \n        type=\"range\" \n        id=\"pacman-y-rotation-slider\" \n        min=\"-180\" \n        max=\"180\" \n        value=\"${pacmanRotationY}\"\n        step=\"1\"\n        style=\"width: 100%; height: 8px; border-radius: 5px; outline: none; background: #333; cursor: pointer;\"\n      />\n    </div>\n    \n    <div style=\"margin-bottom: 15px; color: #e0e0e0;\">\n      <label for=\"pacman-z-rotation-slider\" style=\"display: block; margin-bottom: 10px;\">\n        <strong style=\"color: #ffffff;\">Z Rotation (degrees):</strong>\n        <span id=\"pacman-z-rotation-value\" style=\"color: #FFD700; margin-left: 10px; font-weight: bold;\">${pacmanRotationZ}</span>\n      </label>\n      <input \n        type=\"range\" \n        id=\"pacman-z-rotation-slider\" \n        min=\"-180\" \n        max=\"180\" \n        value=\"${pacmanRotationZ}\"\n        step=\"1\"\n        style=\"width: 100%; height: 8px; border-radius: 5px; outline: none; background: #333; cursor: pointer;\"\n      />\n    </div>\n    \n    <div style=\"margin-top: 20px; padding-top: 15px; border-top: 1px solid #444; color: #aaa; font-size: 11px;\">\n      <p style=\"margin: 0;\">These values adjust the end rotation of Pacman in the home-scroll animation. Changes are applied instantly.</p>\n    </div>\n  `;\n\n  // Attach event listeners\n  const xSlider = pacmanHudContainer.querySelector(\"#pacman-x-rotation-slider\") as HTMLInputElement;\n  const ySlider = pacmanHudContainer.querySelector(\"#pacman-y-rotation-slider\") as HTMLInputElement;\n  const zSlider = pacmanHudContainer.querySelector(\"#pacman-z-rotation-slider\") as HTMLInputElement;\n  const xValueDisplay = pacmanHudContainer.querySelector(\"#pacman-x-rotation-value\");\n  const yValueDisplay = pacmanHudContainer.querySelector(\"#pacman-y-rotation-value\");\n  const zValueDisplay = pacmanHudContainer.querySelector(\"#pacman-z-rotation-value\");\n  \n  if (xSlider) {\n    xSlider.addEventListener(\"input\", (e) => {\n      const target = e.target as HTMLInputElement;\n      pacmanRotationX = parseFloat(target.value);\n      if (xValueDisplay) {\n        xValueDisplay.textContent = `${pacmanRotationX}`;\n      }\n      // Recreate home-scroll animation to apply new end rotation\n      // Only if home-scroll is currently active\n      const homeScrollTrigger = ScrollTrigger.getById(\"homeScroll\");\n      if (homeScrollTrigger?.isActive) {\n        const { initHomeScrollAnimation } = require(\"../animation/home-scroll\");\n        initHomeScrollAnimation();\n      }\n    });\n  }\n  \n  if (ySlider) {\n    ySlider.addEventListener(\"input\", (e) => {\n      const target = e.target as HTMLInputElement;\n      pacmanRotationY = parseFloat(target.value);\n      if (yValueDisplay) {\n        yValueDisplay.textContent = `${pacmanRotationY}`;\n      }\n      // Recreate home-scroll animation to apply new end rotation\n      // Only if home-scroll is currently active\n      const homeScrollTrigger = ScrollTrigger.getById(\"homeScroll\");\n      if (homeScrollTrigger?.isActive) {\n        const { initHomeScrollAnimation } = require(\"../animation/home-scroll\");\n        initHomeScrollAnimation();\n      }\n    });\n  }\n  \n  if (zSlider) {\n    zSlider.addEventListener(\"input\", (e) => {\n      const target = e.target as HTMLInputElement;\n      pacmanRotationZ = parseFloat(target.value);\n      if (zValueDisplay) {\n        zValueDisplay.textContent = `${pacmanRotationZ}`;\n      }\n      // Recreate home-scroll animation to apply new end rotation\n      // Only if home-scroll is currently active\n      const homeScrollTrigger = ScrollTrigger.getById(\"homeScroll\");\n      if (homeScrollTrigger?.isActive) {\n        const { initHomeScrollAnimation } = require(\"../animation/home-scroll\");\n        initHomeScrollAnimation();\n      }\n    });\n  }\n}\n\nlet introPacmanHudContainer: HTMLDivElement | null = null;\nlet isIntroPacmanHudVisible = false;\n\nexport function createIntroPacmanRotationHUD(): void {\n  if (introPacmanHudContainer) {\n    return; // Already created\n  }\n\n  // Initialize rotation values from current intro-scroll rotation\n  // Get the current pacmanTargetQuaternion and convert to Euler, then add 180 to Y\n  try {\n    const { ghosts } = require(\"./objects\");\n    const pacmanObj = ghosts.pacman;\n    if (pacmanObj) {\n      // Try to get current rotation from intro-scroll\n      try {\n        const introScrollModule = require(\"../animation/intro-scroll\");\n        if (introScrollModule.pacmanTargetQuaternion) {\n          const euler = new THREE.Euler().setFromQuaternion(introScrollModule.pacmanTargetQuaternion);\n          introPacmanRotationX = (euler.x * 180) / Math.PI;\n          introPacmanRotationY = ((euler.y * 180) / Math.PI) + 180; // Add 180 to Y\n          introPacmanRotationZ = (euler.z * 180) / Math.PI;\n        } else {\n          // Fallback: use current rotation\n          const euler = new THREE.Euler().setFromQuaternion(pacmanObj.quaternion);\n          introPacmanRotationX = (euler.x * 180) / Math.PI;\n          introPacmanRotationY = ((euler.y * 180) / Math.PI) + 180; // Add 180 to Y\n          introPacmanRotationZ = (euler.z * 180) / Math.PI;\n        }\n      } catch (e) {\n        // Fallback: use current rotation\n        const euler = new THREE.Euler().setFromQuaternion(pacmanObj.quaternion);\n        introPacmanRotationX = (euler.x * 180) / Math.PI;\n        introPacmanRotationY = ((euler.y * 180) / Math.PI) + 180; // Add 180 to Y\n        introPacmanRotationZ = (euler.z * 180) / Math.PI;\n      }\n    }\n  } catch (e) {\n    // Default values if initialization fails\n    introPacmanRotationX = 0;\n    introPacmanRotationY = 180;\n    introPacmanRotationZ = 0;\n  }\n\n  // Create container\n  introPacmanHudContainer = document.createElement(\"div\");\n  introPacmanHudContainer.id = \"intro-pacman-rotation-hud\";\n  introPacmanHudContainer.style.cssText = `\n    position: fixed;\n    top: 100px;\n    left: 20px;\n    width: 320px;\n    background: rgba(20, 20, 20, 0.95);\n    color: #e0e0e0;\n    padding: 20px;\n    border-radius: 8px;\n    font-family: 'Courier New', monospace;\n    font-size: 13px;\n    z-index: 10000;\n    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);\n    border: 2px solid #FF6B6B;\n    max-height: 90vh;\n    overflow-y: auto;\n  `;\n\n  // Toggle button\n  const toggleBtn = document.createElement(\"button\");\n  toggleBtn.textContent = \"Show/Hide Intro Pacman Rotation\";\n  toggleBtn.style.cssText = `\n    position: fixed;\n    top: 100px;\n    left: 360px;\n    padding: 10px 15px;\n    background: #FF6B6B;\n    color: white;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    z-index: 10001;\n    font-size: 14px;\n    font-weight: bold;\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n  `;\n  toggleBtn.addEventListener(\"click\", (e) => {\n    e.stopPropagation();\n    e.preventDefault();\n    isIntroPacmanHudVisible = !isIntroPacmanHudVisible;\n    if (introPacmanHudContainer) {\n      introPacmanHudContainer.style.display = isIntroPacmanHudVisible ? \"block\" : \"none\";\n    }\n  });\n\n  document.body.appendChild(toggleBtn);\n  document.body.appendChild(introPacmanHudContainer);\n  introPacmanHudContainer.style.display = \"none\";\n\n  updateIntroPacmanHUD();\n}\n\nfunction updateIntroPacmanHUD(): void {\n  if (!introPacmanHudContainer) return;\n\n  introPacmanHudContainer.innerHTML = `\n    <h3 style=\"margin-top: 0; color: #FF6B6B; font-size: 16px; text-shadow: 0 0 5px rgba(255, 107, 107, 0.5);\">Pacman Rotation (Intro-Scroll)</h3>\n    \n    <div style=\"margin-bottom: 15px; color: #e0e0e0;\">\n      <label for=\"intro-pacman-x-rotation-slider\" style=\"display: block; margin-bottom: 10px;\">\n        <strong style=\"color: #ffffff;\">X Rotation (degrees):</strong>\n        <span id=\"intro-pacman-x-rotation-value\" style=\"color: #FF6B6B; margin-left: 10px; font-weight: bold;\">${introPacmanRotationX.toFixed(1)}</span>\n      </label>\n      <input \n        type=\"range\" \n        id=\"intro-pacman-x-rotation-slider\" \n        min=\"-180\" \n        max=\"180\" \n        value=\"${introPacmanRotationX}\"\n        step=\"0.1\"\n        style=\"width: 100%; height: 8px; border-radius: 5px; outline: none; background: #333; cursor: pointer;\"\n      />\n    </div>\n    \n    <div style=\"margin-bottom: 15px; color: #e0e0e0;\">\n      <label for=\"intro-pacman-y-rotation-slider\" style=\"display: block; margin-bottom: 10px;\">\n        <strong style=\"color: #ffffff;\">Y Rotation (degrees):</strong>\n        <span id=\"intro-pacman-y-rotation-value\" style=\"color: #FF6B6B; margin-left: 10px; font-weight: bold;\">${introPacmanRotationY.toFixed(1)}</span>\n      </label>\n      <input \n        type=\"range\" \n        id=\"intro-pacman-y-rotation-slider\" \n        min=\"-180\" \n        max=\"180\" \n        value=\"${introPacmanRotationY}\"\n        step=\"0.1\"\n        style=\"width: 100%; height: 8px; border-radius: 5px; outline: none; background: #333; cursor: pointer;\"\n      />\n    </div>\n    \n    <div style=\"margin-bottom: 15px; color: #e0e0e0;\">\n      <label for=\"intro-pacman-z-rotation-slider\" style=\"display: block; margin-bottom: 10px;\">\n        <strong style=\"color: #ffffff;\">Z Rotation (degrees):</strong>\n        <span id=\"intro-pacman-z-rotation-value\" style=\"color: #FF6B6B; margin-left: 10px; font-weight: bold;\">${introPacmanRotationZ.toFixed(1)}</span>\n      </label>\n      <input \n        type=\"range\" \n        id=\"intro-pacman-z-rotation-slider\" \n        min=\"-180\" \n        max=\"180\" \n        value=\"${introPacmanRotationZ}\"\n        step=\"0.1\"\n        style=\"width: 100%; height: 8px; border-radius: 5px; outline: none; background: #333; cursor: pointer;\"\n      />\n    </div>\n    \n    <div style=\"margin-top: 20px; padding-top: 15px; border-top: 1px solid #444; color: #aaa; font-size: 11px;\">\n      <p style=\"margin: 0;\">These values adjust the rotation of Pacman in the intro-scroll animation. Changes are applied instantly.</p>\n    </div>\n  `;\n\n  // Attach event listeners\n  const xSlider = introPacmanHudContainer.querySelector(\"#intro-pacman-x-rotation-slider\") as HTMLInputElement;\n  const ySlider = introPacmanHudContainer.querySelector(\"#intro-pacman-y-rotation-slider\") as HTMLInputElement;\n  const zSlider = introPacmanHudContainer.querySelector(\"#intro-pacman-z-rotation-slider\") as HTMLInputElement;\n  const xValueDisplay = introPacmanHudContainer.querySelector(\"#intro-pacman-x-rotation-value\");\n  const yValueDisplay = introPacmanHudContainer.querySelector(\"#intro-pacman-y-rotation-value\");\n  const zValueDisplay = introPacmanHudContainer.querySelector(\"#intro-pacman-z-rotation-value\");\n  \n  if (xSlider) {\n    xSlider.addEventListener(\"input\", (e) => {\n      const target = e.target as HTMLInputElement;\n      introPacmanRotationX = parseFloat(target.value);\n      if (xValueDisplay) {\n        xValueDisplay.textContent = `${introPacmanRotationX.toFixed(1)}`;\n      }\n      updateIntroPacmanRotation();\n    });\n  }\n  \n  if (ySlider) {\n    ySlider.addEventListener(\"input\", (e) => {\n      const target = e.target as HTMLInputElement;\n      introPacmanRotationY = parseFloat(target.value);\n      if (yValueDisplay) {\n        yValueDisplay.textContent = `${introPacmanRotationY.toFixed(1)}`;\n      }\n      updateIntroPacmanRotation();\n    });\n  }\n  \n  if (zSlider) {\n    zSlider.addEventListener(\"input\", (e) => {\n      const target = e.target as HTMLInputElement;\n      introPacmanRotationZ = parseFloat(target.value);\n      if (zValueDisplay) {\n        zValueDisplay.textContent = `${introPacmanRotationZ.toFixed(1)}`;\n      }\n      updateIntroPacmanRotation();\n    });\n  }\n}\n\nfunction updateIntroPacmanRotation(): void {\n  try {\n    const { ghosts } = require(\"./objects\");\n    const pacmanObj = ghosts.pacman;\n    if (!pacmanObj) return;\n\n    // Create quaternion from Euler angles\n    const euler = new THREE.Euler(\n      (introPacmanRotationX * Math.PI) / 180,\n      (introPacmanRotationY * Math.PI) / 180,\n      (introPacmanRotationZ * Math.PI) / 180,\n      \"XYZ\"\n    );\n    const newQuaternion = new THREE.Quaternion().setFromEuler(euler);\n\n    // Update pacmanTargetQuaternion in intro-scroll module\n    const introScrollModule = require(\"../animation/intro-scroll\");\n    if (introScrollModule.pacmanTargetQuaternion) {\n      introScrollModule.pacmanTargetQuaternion.copy(newQuaternion);\n    }\n\n    // If intro-scroll is active, apply rotation immediately\n    const introScrollTrigger = ScrollTrigger.getById(\"introScroll\");\n    if (introScrollTrigger?.isActive && pacmanObj) {\n      pacmanObj.quaternion.copy(newQuaternion);\n    }\n  } catch (e) {\n    console.error(\"Error updating intro Pacman rotation:\", e);\n  }\n}\n","export const SCALE = {\n  PACMAN_HOME: 0.05,\n  PACMAN_INTRO: 0.1,\n  GHOST_NORMAL: 1.0,\n  GHOST_INTRO: 1.5,\n  GHOST_POV: 0.5,\n} as const;\n\nexport const OPACITY = {\n  FULL: 1.0,\n  HIDDEN: 0.0,\n} as const;\n\nexport const SCROLL_SELECTORS = {\n  HOME: \".sc--home.sc\",\n  INTRO: \".sc--intro.sc\",\n  POV: \".sc--pov.sc\",\n  OUTRO: \".sc--outro.sc\",\n} as const;\n\nexport const TANGENT_SMOOTHING = {\n  HOME_LOOP: 0.06,\n  POV: 0.08,\n} as const;\n\nexport const PARAMETER_SMOOTHING_FACTOR = 0.1;\nexport const GHOST_FADE_THRESHOLD = 0.9;\nexport const GHOST_FADE_OUT_DURATION = 0.1;\n\nexport const INTRO_WALK_DISTANCE = 10.0;\nexport const INTRO_FADE_IN_DURATION = 0.2;\nexport const INTRO_POSITION_OFFSET = {\n  x: 4.3,\n  y: -2.0,\n  z: 0.0,\n} as const;\n\nexport const FIND_CLOSEST_SAMPLES = 800;\n\nexport const SCRUB_DURATION = 0.5;\nexport const STAGGER_AMOUNT = 0.15;\nexport const ROTATION_TRANSITION_DURATION = 1.5;\n\nexport const POV_SEQUENCE_PHASE_END = 0.05;\nexport const POV_TRANSITION_PHASE_END = 0.07;\nexport const POV_Y_CONSTRAINT_THRESHOLD = 0.15;\nexport const OPACITY_VISIBILITY_THRESHOLD = 0.01;\n\nexport const KEYFRAME_SCALE = {\n  START: 0.5,\n  MID: 0.8,\n  LARGE: 1.2,\n  END: 1.5,\n} as const;\n\nexport const KEYFRAME_DURATION = {\n  NONE: 0,\n  FADE_IN: 0.3,\n  HOLD: 0.4,\n  FADE_OUT: 0.3,\n} as const;\n\nexport const INTRO_GHOST_OFFSETS = {\n  GHOST1: 0.0,\n  GHOST2: -0.005,\n  GHOST3: -0.01,\n  GHOST4: -0.015,\n  GHOST5: -0.02,\n} as const;\n\nexport function clamp(value: number, min: number = 0, max: number = 1): number {\n  return Math.max(min, Math.min(max, value));\n}\n","module.exports = gsap;","import * as THREE from \"three\";\nimport { isCurrencySymbol, isPacmanPart } from \"../animation/util\";\n\nexport function setObjectOpacity(\n  object: THREE.Object3D,\n  opacity: number,\n  options?: {\n    preserveTransmission?: boolean;\n    skipCurrencySymbols?: boolean;\n  }\n): void {\n  const preserveTransmission = options?.preserveTransmission !== false;\n\n  forEachMaterial(\n    object,\n    (mat: any) => {\n      setMaterialOpacity(mat, opacity, preserveTransmission);\n    },\n    {\n      skipCurrencySymbols: options?.skipCurrencySymbols === true,\n    }\n  );\n}\n\nexport function setMaterialOpacity(\n  material: THREE.Material,\n  opacity: number,\n  preserveTransmission: boolean = true\n): void {\n  const mat = material as any;\n  const currentOpacity = mat.opacity ?? 1;\n  const currentTransparent = mat.transparent ?? false;\n\n  if (Math.abs(currentOpacity - opacity) < 0.0001) {\n    return;\n  }\n\n  mat.opacity = opacity;\n\n  const shouldBeTransparent = preserveTransmission && mat.transmission !== undefined && mat.transmission > 0\n    ? true\n    : opacity < 1.0;\n\n  if (currentTransparent !== shouldBeTransparent) {\n    mat.transparent = shouldBeTransparent;\n    if (mat.needsUpdate !== undefined) {\n      mat.needsUpdate = true;\n    }\n  }\n}\n\nexport function setMaterialTransparent(\n  material: THREE.Material,\n  transparent: boolean,\n  preserveTransmission: boolean = true\n): void {\n  const mat = material as any;\n  const currentTransparent = mat.transparent ?? false;\n\n  const shouldBeTransparent = preserveTransmission && mat.transmission !== undefined && mat.transmission > 0\n    ? true\n    : transparent;\n\n  if (currentTransparent === shouldBeTransparent) {\n    return;\n  }\n\n  mat.transparent = shouldBeTransparent;\n\n  if (mat.needsUpdate !== undefined) {\n    mat.needsUpdate = true;\n  }\n}\n\nexport function getObjectOpacity(object: THREE.Object3D): number {\n  let opacity = 1.0;\n  let found = false;\n\n  forEachMaterial(\n    object,\n    (mat: any) => {\n      if (!found) {\n        opacity = mat.opacity ?? 1.0;\n        found = true;\n      }\n    },\n    { skipCurrencySymbols: false }\n  );\n\n  return opacity;\n}\n\nexport function resetGhostMaterialsToFullOpacity(object: THREE.Object3D): void {\n  setObjectOpacity(object, 1.0, {\n    preserveTransmission: true,\n    skipCurrencySymbols: true,\n  });\n}\n\n\nexport function forEachMaterial(\n  object: THREE.Object3D,\n  callback: (material: THREE.Material, mesh: THREE.Mesh, childName: string) => void,\n  options?: {\n    skipCurrencySymbols?: boolean;\n    skipPacmanParts?: boolean;\n    objectKey?: string;\n  }\n): void {\n  const skipCurrencySymbols = options?.skipCurrencySymbols === true;\n  const skipPacmanParts = options?.skipPacmanParts === true;\n  const objectKey = options?.objectKey;\n\n  object.traverse((child) => {\n    if ((child as any).isMesh && (child as any).material) {\n      const mesh = child as THREE.Mesh;\n      const childName = child.name || \"\";\n\n      if (skipCurrencySymbols && isCurrencySymbol(childName)) {\n        return;\n      }\n\n      if (skipPacmanParts && objectKey === \"pacman\" && isPacmanPart(childName)) {\n        return;\n      }\n\n      if (Array.isArray(mesh.material)) {\n        mesh.material.forEach((mat: any) => {\n          callback(mat, mesh, childName);\n        });\n      } else {\n        callback(mesh.material as any, mesh, childName);\n      }\n    }\n  });\n}\n","import gsap from \"gsap\";\nimport * as THREE from \"three\";\nimport { camera } from \"../core/camera\";\nimport { ghosts } from \"../core/objects\";\nimport {\n  slerpToLayDown,\n  applyRotations,\n  OBJECT_KEYS,\n  isCurrencySymbol,\n  isPacmanPart,\n} from \"./util\";\nimport {\n  setMaterialOpacity,\n  setMaterialTransparent,\n  resetGhostMaterialsToFullOpacity,\n  forEachMaterial,\n} from \"../core/material-utils\";\nimport {\n  setFloorPlane,\n  setObjectScale,\n  killObjectAnimations,\n} from \"./scene-utils\";\nimport { SCALE, OPACITY, INTRO_POSITION_OFFSET } from \"./constants\";\n\nexport function applyHomeLoopPreset(\n  isEntering: boolean,\n  scrollDirection?: \"up\" | \"down\"\n) {\n  if (!isEntering) return;\n\n  Object.entries(ghosts).forEach(([key, object]) => {\n    gsap.set(object, { visible: true });\n    setObjectScale(object, key, \"home\");\n\n    forEachMaterial(\n      object,\n      (mat: any, mesh: THREE.Mesh, childName: string) => {\n        if (isCurrencySymbol(childName)) {\n          mesh.visible = false;\n          return;\n        }\n        mesh.visible = true;\n      },\n      { skipCurrencySymbols: false }\n    );\n\n    resetGhostMaterialsToFullOpacity(object);\n  });\n\n  setFloorPlane(true, OPACITY.FULL, false);\n}\n\nexport function applyHomeScrollPreset(\n  isEntering: boolean,\n  scrollDirection?: \"up\" | \"down\",\n  pausedPositions?: Record<string, THREE.Vector3>,\n  pausedRotations?: Record<string, THREE.Quaternion>\n) {\n  if (!isEntering) return;\n\n  if (pausedPositions && pausedRotations) {\n    Object.entries(ghosts).forEach(([key, object]) => {\n      if (pausedPositions[key]) {\n        object.position.set(\n          pausedPositions[key].x,\n          pausedPositions[key].y,\n          pausedPositions[key].z\n        );\n        gsap.set(object.position, {\n          x: pausedPositions[key].x,\n          y: pausedPositions[key].y,\n          z: pausedPositions[key].z,\n        });\n      }\n\n      gsap.set(object, { visible: true });\n\n      setObjectScale(object, key, \"home\");\n\n      forEachMaterial(\n        object,\n        (mat: any, mesh: THREE.Mesh, childName: string) => {\n          if (isCurrencySymbol(childName)) {\n            mesh.visible = false;\n            return;\n          }\n\n          mesh.visible = true;\n\n          setMaterialTransparent(mat, true, true);\n        },\n        { skipCurrencySymbols: false }\n      );\n    });\n  }\n\n  setFloorPlane(true, OPACITY.FULL, false);\n}\n\nexport { INTRO_POSITION_OFFSET };\n\nlet pacmanTargetQuaternion: THREE.Quaternion | null = null;\nlet ghostTargetQuaternion: THREE.Quaternion | null = null;\nlet introInitialRotations: Record<string, THREE.Quaternion> = {};\n\nexport function applyIntroScrollPreset(\n  isEntering: boolean,\n  scrollDirection?: \"up\" | \"down\"\n) {\n  if (!isEntering) return;\n\n  if (!pacmanTargetQuaternion || !ghostTargetQuaternion) {\n    const pacmanObj = ghosts.pacman;\n    if (pacmanObj) {\n      if (!introInitialRotations[\"pacman\"]) {\n        introInitialRotations[\"pacman\"] = pacmanObj.quaternion.clone();\n      }\n\n      let quat = introInitialRotations[\"pacman\"].clone();\n      slerpToLayDown(pacmanObj, quat, OPACITY.FULL);\n      quat = pacmanObj.quaternion.clone();\n\n      quat = applyRotations(quat, [\n        { axis: \"x\", angle: Math.PI / 2 },\n        { axis: \"y\", angle: Math.PI },\n        { axis: \"y\", angle: Math.PI },\n        { axis: \"x\", angle: Math.PI },\n        { axis: \"x\", angle: Math.PI },\n        { axis: \"y\", angle: Math.PI },\n      ]);\n\n      pacmanTargetQuaternion = quat;\n      pacmanObj.quaternion.copy(introInitialRotations[\"pacman\"]);\n    }\n\n    const ghostObj = ghosts.ghost1;\n    if (ghostObj) {\n      if (!introInitialRotations[\"ghost1\"]) {\n        introInitialRotations[\"ghost1\"] = ghostObj.quaternion.clone();\n      }\n\n      let quat = introInitialRotations[\"ghost1\"].clone();\n      slerpToLayDown(ghostObj, quat, OPACITY.FULL);\n      quat = ghostObj.quaternion.clone();\n\n      quat = applyRotations(quat, [\n        { axis: \"x\", angle: Math.PI },\n        { axis: \"x\", angle: Math.PI },\n        { axis: \"y\", angle: Math.PI },\n        { axis: \"y\", angle: Math.PI },\n        { axis: \"x\", angle: Math.PI },\n        { axis: \"x\", angle: Math.PI },\n      ]);\n\n      ghostTargetQuaternion = quat;\n      ghostObj.quaternion.copy(introInitialRotations[\"ghost1\"]);\n    }\n\n    OBJECT_KEYS.forEach((key) => {\n      const obj = ghosts[key];\n      if (obj && !introInitialRotations[key]) {\n        introInitialRotations[key] = obj.quaternion.clone();\n      }\n    });\n  }\n}\n\nexport function applyPovScrollPreset(\n  isEntering: boolean,\n  scrollDirection?: \"up\" | \"down\"\n) {\n  if (!isEntering) return;\n\n  if (ghosts.pacman) {\n    gsap.set(ghosts.pacman, { visible: false });\n  }\n\n  Object.entries(ghosts).forEach(([key, object]) => {\n    if (key !== \"pacman\") {\n      gsap.set(object, { visible: false });\n      setObjectScale(object, key, \"pov\");\n\n      forEachMaterial(\n        object,\n        (mat: any) => {\n          setMaterialOpacity(mat, 1, true);\n        },\n        { skipCurrencySymbols: false }\n      );\n    }\n  });\n\n  setFloorPlane(true, OPACITY.FULL, false);\n}\n\nexport function applyOutroScrollPreset(\n  isEntering: boolean,\n  scrollDirection?: \"up\" | \"down\"\n) {\n  if (!isEntering) return;\n\n  setFloorPlane(true, OPACITY.FULL, false);\n}\n\nlet lastScrollY = window.scrollY;\nexport function getScrollDirection(): \"up\" | \"down\" {\n  const currentScrollY = window.scrollY;\n  const direction = currentScrollY > lastScrollY ? \"down\" : \"up\";\n  lastScrollY = currentScrollY;\n  return direction;\n}\n","export const isMobile = window.innerWidth < 768;\n\nexport const ASSETS = {\n  mazeTexture: \"https://c-am.b-cdn.net/CAM/matcap24.png\",\n  mazeModel: \"https://c-am.b-cdn.net/CAM/c-am-assets-3.glb\",\n};\n","import gsap from \"gsap\";\nimport ScrollTrigger from \"gsap/ScrollTrigger\";\nimport * as THREE from \"three\";\nimport { camera } from \"../core/camera\";\nimport { ghosts, pacmanMixer, pill } from \"../core/objects\";\nimport { clock, scene } from \"../core/scene\";\nimport { slerpToLayDown, applyRotations } from \"./util\";\nimport { isCurrencySymbol, isPacmanPart } from \"./util\";\nimport {\n  SCROLL_SELECTORS,\n  OPACITY,\n  INTRO_WALK_DISTANCE,\n  INTRO_FADE_IN_DURATION,\n  INTRO_POSITION_OFFSET,\n  SCRUB_DURATION,\n  KEYFRAME_SCALE,\n  KEYFRAME_DURATION,\n  INTRO_GHOST_OFFSETS,\n  clamp,\n} from \"./constants\";\nimport { setFloorPlane, setObjectScale } from \"./scene-utils\";\n\nlet introScrollTimeline: gsap.core.Timeline | null = null;\nlet isIntroScrollActive = false;\nlet lastUpdateProgress: number | null = null;\nexport let pacmanTargetQuaternion: THREE.Quaternion | null = null;\nlet ghostTargetQuaternion: THREE.Quaternion | null = null;\nlet introInitialRotations: Record<string, THREE.Quaternion> = {};\nlet cachedCameraPosition: THREE.Vector3 | null = null;\nlet lastCameraUpdateFrame = -1;\nlet introGridGuides: THREE.Group | null = null;\n\nfunction resetIntroScrollCache() {\n  cachedCameraPosition = null;\n  lastCameraUpdateFrame = -1;\n  lastUpdateProgress = null;\n}\n\nfunction setIntroScrollLocked(locked: boolean) {\n  Object.values(ghosts).forEach((obj) => {\n    obj.userData.introScrollLocked = locked;\n  });\n}\n\nfunction restoreFloor() {\n  const floorState = {\n    visible: true,\n    opacity: OPACITY.FULL,\n    transparent: false,\n  };\n  if (\n    !lastFloorState ||\n    lastFloorState.visible !== floorState.visible ||\n    lastFloorState.opacity !== floorState.opacity ||\n    lastFloorState.transparent !== floorState.transparent\n  ) {\n    setFloorPlane(\n      floorState.visible,\n      floorState.opacity,\n      floorState.transparent\n    );\n    lastFloorState = floorState;\n  }\n}\n\nfunction createIntroGridGuides() {\n  // Remove existing guides if they exist\n  if (introGridGuides) {\n    scene.remove(introGridGuides);\n    introGridGuides = null;\n  }\n\n  const gridGroup = new THREE.Group();\n  gridGroup.name = \"introGridGuides\";\n  introGridGuides = gridGroup;\n\n  // Use smaller grid size to match the object area\n  // Objects are positioned around INTRO_POSITION_OFFSET.y = -2.0\n  const gridSize = 10; // Smaller grid\n  const gridDivisions = 20; // More divisions for better visibility\n  const gridYPosition = INTRO_POSITION_OFFSET.y; // Position at same Y as objects (-2.0)\n  const gridSpacing = gridSize / gridDivisions; // 0.5 units between lines\n\n  // Create grid lines manually so we can color them differently\n  // X-direction lines (green) - lines parallel to X-axis\n  const xLinesMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });\n  for (let i = -gridSize / 2; i <= gridSize / 2; i += gridSpacing) {\n    const xLineGeometry = new THREE.BufferGeometry().setFromPoints([\n      new THREE.Vector3(-gridSize / 2, gridYPosition, i),\n      new THREE.Vector3(gridSize / 2, gridYPosition, i),\n    ]);\n    const xLine = new THREE.Line(xLineGeometry, xLinesMaterial);\n    xLine.renderOrder = 999;\n    gridGroup.add(xLine);\n  }\n\n  // Z-direction lines (red) - lines parallel to Z-axis\n  const zLinesMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });\n  for (let i = -gridSize / 2; i <= gridSize / 2; i += gridSpacing) {\n    const zLineGeometry = new THREE.BufferGeometry().setFromPoints([\n      new THREE.Vector3(i, gridYPosition, -gridSize / 2),\n      new THREE.Vector3(i, gridYPosition, gridSize / 2),\n    ]);\n    const zLine = new THREE.Line(zLineGeometry, zLinesMaterial);\n    zLine.renderOrder = 999;\n    gridGroup.add(zLine);\n  }\n\n  // Y-axis line (yellow) - vertical, centered at grid to show height\n  const yLineGeometry = new THREE.BufferGeometry().setFromPoints([\n    new THREE.Vector3(0, gridYPosition - 1, 0),\n    new THREE.Vector3(0, gridYPosition + 1, 0),\n  ]);\n  const yLineMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });\n  const yLine = new THREE.Line(yLineGeometry, yLineMaterial);\n  yLine.renderOrder = 1000;\n  gridGroup.add(yLine);\n\n  // Add labeled grid markers with numbers\n  const labelDistance = 1; // Distance between labels\n  const labelColor = 0xffffff;\n  const labelSize = 0.15;\n\n  // X-axis labels (along the red line)\n  for (\n    let i = -Math.floor(gridSize / 2);\n    i <= Math.floor(gridSize / 2);\n    i += labelDistance\n  ) {\n    if (i === 0) continue; // Skip origin\n\n    // Create small sphere marker\n    const markerGeometry = new THREE.SphereGeometry(0.05, 8, 8);\n    const markerMaterial = new THREE.MeshBasicMaterial({ color: labelColor });\n    const marker = new THREE.Mesh(markerGeometry, markerMaterial);\n    marker.position.set(i, gridYPosition, 0);\n    marker.renderOrder = 1001;\n    gridGroup.add(marker);\n\n    // Create number text using sprites (simple approach)\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = 64;\n    canvas.height = 64;\n    const context = canvas.getContext(\"2d\");\n    if (context) {\n      context.fillStyle = \"#ffffff\";\n      context.font = \"Bold 48px Arial\";\n      context.textAlign = \"center\";\n      context.textBaseline = \"middle\";\n      context.fillText(i.toString(), 32, 32);\n      const texture = new THREE.CanvasTexture(canvas);\n      const spriteMaterial = new THREE.SpriteMaterial({ map: texture });\n      const sprite = new THREE.Sprite(spriteMaterial);\n      sprite.scale.set(0.3, 0.3, 1);\n      sprite.position.set(i, gridYPosition + 0.3, 0);\n      sprite.renderOrder = 1001;\n      gridGroup.add(sprite);\n    }\n  }\n\n  // Z-axis labels (along the blue line)\n  for (\n    let i = -Math.floor(gridSize / 2);\n    i <= Math.floor(gridSize / 2);\n    i += labelDistance\n  ) {\n    if (i === 0) continue; // Skip origin\n\n    // Create small sphere marker\n    const markerGeometry = new THREE.SphereGeometry(0.05, 8, 8);\n    const markerMaterial = new THREE.MeshBasicMaterial({ color: labelColor });\n    const marker = new THREE.Mesh(markerGeometry, markerMaterial);\n    marker.position.set(0, gridYPosition, i);\n    marker.renderOrder = 1001;\n    gridGroup.add(marker);\n\n    // Create number text\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = 64;\n    canvas.height = 64;\n    const context = canvas.getContext(\"2d\");\n    if (context) {\n      context.fillStyle = \"#ffffff\";\n      context.font = \"Bold 48px Arial\";\n      context.textAlign = \"center\";\n      context.textBaseline = \"middle\";\n      context.fillText(i.toString(), 32, 32);\n      const texture = new THREE.CanvasTexture(canvas);\n      const spriteMaterial = new THREE.SpriteMaterial({ map: texture });\n      const sprite = new THREE.Sprite(spriteMaterial);\n      sprite.scale.set(0.3, 0.3, 1);\n      sprite.position.set(0, gridYPosition + 0.3, i);\n      sprite.renderOrder = 1001;\n      gridGroup.add(sprite);\n    }\n  }\n\n  // Origin marker\n  const originGeometry = new THREE.SphereGeometry(0.1, 16, 16);\n  const originMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });\n  const originMarker = new THREE.Mesh(originGeometry, originMaterial);\n  originMarker.position.set(0, gridYPosition, 0);\n  originMarker.renderOrder = 1001;\n  gridGroup.add(originMarker);\n\n  // Position grid at origin (0, 0, 0) - grid elements are positioned relative to this\n  // The grid will be positioned at world Y = -2.0, which matches INTRO_POSITION_OFFSET.y\n  // Since objects move relative to camera, the grid should cover a reasonable area\n  gridGroup.position.set(0, 0, 0);\n\n  scene.add(gridGroup);\n}\n\nfunction removeIntroGridGuides() {\n  if (introGridGuides) {\n    scene.remove(introGridGuides);\n    introGridGuides = null;\n  }\n}\n\nexport function initIntroScrollAnimation() {\n  if (introScrollTimeline) {\n    introScrollTimeline.kill();\n    introScrollTimeline = null;\n  }\n\n  introScrollTimeline = gsap\n    .timeline({\n      scrollTrigger: {\n        trigger: SCROLL_SELECTORS.INTRO,\n        start: \"top top\",\n        end: \"bottom bottom\",\n        scrub: SCRUB_DURATION,\n        refreshPriority: 1,\n        markers: {\n          startColor: \"green\",\n          endColor: \"red\",\n          fontSize: \"12px\",\n          fontWeight: \"bold\",\n          indent: 60,\n        },\n        onEnter: () => {\n          isIntroScrollActive = true;\n          resetIntroScrollCache();\n          setIntroScrollLocked(true);\n          createIntroGridGuides();\n          // Speed up Pacman mouth animation in intro-scroll\n          if (pacmanMixer) {\n            pacmanMixer.timeScale = 1.5; // 50% faster\n          }\n        },\n        onEnterBack: () => {\n          isIntroScrollActive = true;\n          resetIntroScrollCache();\n          setIntroScrollLocked(true);\n          createIntroGridGuides();\n          // Speed up Pacman mouth animation in intro-scroll\n          if (pacmanMixer) {\n            pacmanMixer.timeScale = 1.5; // 50% faster\n          }\n        },\n        onLeave: () => {\n          isIntroScrollActive = false;\n          resetIntroScrollCache();\n          restoreFloor();\n          setIntroScrollLocked(false);\n          removeIntroGridGuides();\n          // Reset Pacman animation speed when leaving intro-scroll\n          if (pacmanMixer) {\n            pacmanMixer.timeScale = 1.0;\n          }\n        },\n        onLeaveBack: () => {\n          isIntroScrollActive = false;\n          resetIntroScrollCache();\n          restoreFloor();\n          setIntroScrollLocked(false);\n          removeIntroGridGuides();\n          // Reset Pacman animation speed when leaving intro-scroll\n          if (pacmanMixer) {\n            pacmanMixer.timeScale = 1.0;\n          }\n        },\n        onUpdate: (self) => {\n          if (typeof self.progress === \"number\") {\n            updateObjectsWalkBy(self.progress);\n          }\n        },\n        id: \"introScroll\",\n      },\n    })\n    .addLabel(\"intro-text-start\", 0)\n    .fromTo(\n      \".sc_h--intro\",\n      { scale: KEYFRAME_SCALE.START, opacity: OPACITY.HIDDEN },\n      {\n        keyframes: [\n          {\n            scale: KEYFRAME_SCALE.START,\n            opacity: OPACITY.HIDDEN,\n            duration: KEYFRAME_DURATION.NONE,\n          },\n          {\n            scale: KEYFRAME_SCALE.MID,\n            opacity: OPACITY.FULL,\n            duration: KEYFRAME_DURATION.FADE_IN,\n          },\n          {\n            scale: KEYFRAME_SCALE.LARGE,\n            opacity: OPACITY.FULL,\n            duration: KEYFRAME_DURATION.HOLD,\n          },\n          {\n            scale: KEYFRAME_SCALE.END,\n            opacity: OPACITY.HIDDEN,\n            duration: KEYFRAME_DURATION.FADE_OUT,\n          },\n        ],\n      }\n    )\n    .addLabel(\"intro-text-fade-in\", KEYFRAME_DURATION.NONE)\n    .addLabel(\n      \"intro-text-hold\",\n      KEYFRAME_DURATION.NONE + KEYFRAME_DURATION.FADE_IN\n    )\n    .addLabel(\n      \"intro-text-fade-out\",\n      KEYFRAME_DURATION.NONE +\n        KEYFRAME_DURATION.FADE_IN +\n        KEYFRAME_DURATION.HOLD\n    )\n    .fromTo(\n      \".sc_b--intro\",\n      { scale: KEYFRAME_SCALE.START, opacity: OPACITY.HIDDEN },\n      {\n        keyframes: [\n          {\n            scale: KEYFRAME_SCALE.START,\n            opacity: OPACITY.HIDDEN,\n            duration: KEYFRAME_DURATION.NONE,\n          },\n          {\n            scale: KEYFRAME_SCALE.MID,\n            opacity: OPACITY.FULL,\n            duration: KEYFRAME_DURATION.FADE_IN,\n          },\n          {\n            scale: KEYFRAME_SCALE.LARGE,\n            opacity: OPACITY.FULL,\n            duration: KEYFRAME_DURATION.HOLD,\n          },\n          {\n            scale: KEYFRAME_SCALE.END,\n            opacity: OPACITY.HIDDEN,\n            duration: KEYFRAME_DURATION.FADE_OUT,\n          },\n        ],\n      }\n    )\n    .addLabel(\n      \"intro-text-end\",\n      KEYFRAME_DURATION.NONE +\n        KEYFRAME_DURATION.FADE_IN +\n        KEYFRAME_DURATION.HOLD +\n        KEYFRAME_DURATION.FADE_OUT\n    );\n}\n\nfunction initializeQuaternions() {\n  if (pacmanTargetQuaternion && ghostTargetQuaternion) return;\n\n  const pacmanObj = ghosts.pacman;\n  if (pacmanObj) {\n    if (!introInitialRotations[\"pacman\"]) {\n      introInitialRotations[\"pacman\"] = pacmanObj.quaternion.clone();\n    }\n\n    let quat = introInitialRotations[\"pacman\"].clone();\n    const tempObj = new THREE.Object3D();\n    tempObj.quaternion.copy(quat);\n    slerpToLayDown(tempObj, quat, OPACITY.FULL);\n    quat = tempObj.quaternion.clone();\n\n    quat = applyRotations(quat, [\n      { axis: \"x\", angle: Math.PI / 2 },\n      { axis: \"y\", angle: Math.PI },\n      { axis: \"y\", angle: Math.PI },\n      { axis: \"x\", angle: Math.PI },\n      { axis: \"x\", angle: Math.PI },\n      { axis: \"y\", angle: Math.PI },\n    ]);\n\n    pacmanTargetQuaternion = quat;\n  }\n\n  const ghostObj = ghosts.ghost1;\n  if (ghostObj) {\n    if (!introInitialRotations[\"ghost1\"]) {\n      introInitialRotations[\"ghost1\"] = ghostObj.quaternion.clone();\n    }\n\n    let quat = introInitialRotations[\"ghost1\"].clone();\n    const tempObj = new THREE.Object3D();\n    tempObj.quaternion.copy(quat);\n    slerpToLayDown(tempObj, quat, OPACITY.FULL);\n    quat = tempObj.quaternion.clone();\n\n    quat = applyRotations(quat, [\n      { axis: \"x\", angle: Math.PI },\n      { axis: \"x\", angle: Math.PI },\n      { axis: \"y\", angle: Math.PI },\n      { axis: \"y\", angle: Math.PI },\n      { axis: \"x\", angle: Math.PI },\n      { axis: \"x\", angle: Math.PI },\n    ]);\n\n    ghostTargetQuaternion = quat;\n  }\n\n  Object.keys(ghosts).forEach((key) => {\n    const obj = ghosts[key as keyof typeof ghosts];\n    if (obj && !introInitialRotations[key]) {\n      introInitialRotations[key] = obj.quaternion.clone();\n    }\n  });\n}\n\nlet lastFloorState: {\n  visible: boolean;\n  opacity: number;\n  transparent: boolean;\n} | null = null;\n\nconst tempVector = new THREE.Vector3();\n\nfunction updateObjectsWalkBy(progress: number) {\n  if (!isIntroScrollActive) return;\n\n  if (lastUpdateProgress === progress) return;\n  lastUpdateProgress = progress;\n\n  const currentFrame = performance.now();\n  const shouldUpdateCache =\n    !cachedCameraPosition || currentFrame - lastCameraUpdateFrame > 16;\n\n  if (shouldUpdateCache) {\n    const camX = camera.position.x;\n    const camY = camera.position.y;\n    const camZ = camera.position.z;\n\n    if (!isFinite(camX) || !isFinite(camY) || !isFinite(camZ)) {\n      if (!cachedCameraPosition) {\n        return;\n      }\n      tempVector.copy(cachedCameraPosition);\n    } else {\n      if (!cachedCameraPosition) {\n        cachedCameraPosition = new THREE.Vector3();\n      }\n      cachedCameraPosition.set(camX, camY, camZ);\n      lastCameraUpdateFrame = currentFrame;\n      tempVector.copy(cachedCameraPosition);\n    }\n  } else {\n    tempVector.copy(cachedCameraPosition!);\n  }\n\n  initializeQuaternions();\n\n  if (pacmanMixer) {\n    // Ensure timeScale is set during intro-scroll (in case it was reset elsewhere)\n    if (isIntroScrollActive && pacmanMixer.timeScale !== 1.5) {\n      pacmanMixer.timeScale = 1.5;\n    }\n    pacmanMixer.update(clock.getDelta());\n  }\n\n  const floorState = {\n    visible: true,\n    opacity: OPACITY.HIDDEN,\n    transparent: true,\n  };\n  if (\n    !lastFloorState ||\n    lastFloorState.visible !== floorState.visible ||\n    lastFloorState.opacity !== floorState.opacity ||\n    lastFloorState.transparent !== floorState.transparent\n  ) {\n    setFloorPlane(\n      floorState.visible,\n      floorState.opacity,\n      floorState.transparent\n    );\n    lastFloorState = floorState;\n  }\n\n  const pacmanQuat = pacmanTargetQuaternion;\n  const ghostQuat = ghostTargetQuaternion;\n\n  const walkStart = tempVector.x - INTRO_WALK_DISTANCE;\n  const walkEnd = tempVector.x + INTRO_WALK_DISTANCE;\n\n  const objectsToAnimate = [\n    {\n      key: \"pacman\",\n      behindOffset: 1.5,\n      zOffset: 0.5,\n      xOffset: 0,\n      yOffset: 0,\n      zPhase: 0,\n    },\n    {\n      key: \"ghost1\",\n      behindOffset: INTRO_GHOST_OFFSETS.GHOST1,\n      zOffset: 0.5,\n      xOffset: 0.5,\n      yOffset: -0.5,\n      zPhase: Math.PI * 1.0,\n    },\n    {\n      key: \"ghost2\",\n      behindOffset: INTRO_GHOST_OFFSETS.GHOST2,\n      zOffset: 0.5,\n      xOffset: 0,\n      yOffset: -1,\n      zPhase: Math.PI * 1.5,\n    },\n    {\n      key: \"ghost3\",\n      behindOffset: INTRO_GHOST_OFFSETS.GHOST3,\n      zOffset: 0.5,\n      xOffset: 0.5,\n      yOffset: 0.5,\n      zPhase: Math.PI * 1.0,\n    },\n    {\n      key: \"ghost4\",\n      behindOffset: INTRO_GHOST_OFFSETS.GHOST4,\n      zOffset: 0.5,\n      xOffset: 0.75,\n      yOffset: 0.25,\n      zPhase: Math.PI * 1.0,\n    },\n    {\n      key: \"ghost5\",\n      behindOffset: INTRO_GHOST_OFFSETS.GHOST5,\n      zOffset: 0.5,\n      xOffset: 0,\n      yOffset: -0.5,\n      zPhase: Math.PI * 1.0,\n    },\n    {\n      key: \"pill\",\n      behindOffset: 1.1 - INTRO_POSITION_OFFSET.x, // X position 1.1 on green grid line (absolute world position)\n      zOffset: 1.5, // Z position 1.5 on red grid line (absolute world position)\n      xOffset: 0,\n      yOffset: 0,\n      zPhase: Math.PI * 0.5,\n    },\n  ];\n\n  const normalizedProgress = clamp(progress);\n  const baseX = walkStart + (walkEnd - walkStart) * normalizedProgress;\n  const pacmanX = baseX + INTRO_POSITION_OFFSET.x;\n  const pacmanY = tempVector.y + INTRO_POSITION_OFFSET.y;\n  const pacmanZ = tempVector.z + INTRO_POSITION_OFFSET.z;\n\n  if (\n    !isFinite(baseX) ||\n    !isFinite(pacmanX) ||\n    !isFinite(pacmanY) ||\n    !isFinite(pacmanZ)\n  ) {\n    return;\n  }\n\n  const baseGhostOpacity =\n    normalizedProgress < INTRO_FADE_IN_DURATION\n      ? normalizedProgress / INTRO_FADE_IN_DURATION\n      : 1.0;\n\n  objectsToAnimate.forEach(\n    ({\n      key,\n      behindOffset,\n      zOffset,\n      xOffset,\n      yOffset: staticYOffset,\n      zPhase,\n    }) => {\n      const object = key === \"pill\" ? pill : ghosts[key];\n      if (!object) return;\n\n      const zBounce =\n        key === \"pacman\" || key === \"pill\"\n          ? 0\n          : Math.sin(normalizedProgress * Math.PI * 2 * 20 + zPhase) * 0.01;\n      const animatedYOffset =\n        key === \"pacman\" || key === \"pill\" ? 0 : zBounce * 1.5;\n\n      // Special handling for pill: position at absolute grid coordinates\n      let finalX: number;\n      let finalY: number;\n      let finalZ: number;\n\n      if (key === \"pill\") {\n        // Pill should be at grid position X=1.5 (green), Z=1.1 (red), Y=-2.0 (grid height)\n        finalX = 1.5;\n        finalY = INTRO_POSITION_OFFSET.y; // -2.0, same as grid height\n        finalZ = 1.1;\n      } else {\n        // Other objects use relative positioning\n        finalX = pacmanX + behindOffset + xOffset;\n        finalY = pacmanY + staticYOffset - animatedYOffset;\n        finalZ = pacmanZ + zOffset - zBounce;\n      }\n\n      if (\n        !isFinite(finalX) ||\n        !isFinite(finalY) ||\n        !isFinite(finalZ) ||\n        Math.abs(finalZ) < 0.01 ||\n        Math.abs(finalZ) > 100\n      ) {\n        return;\n      }\n\n      object.position.set(finalX, finalY, finalZ);\n\n      if (key === \"pill\") {\n        // Set specific rotation: X=1.571 (90), Y=20, Z=180 ( rad)\n        const targetEuler = new THREE.Euler(\n          1.571, // X: 90 degrees (/2)\n          (20 * Math.PI) / 180, // Y: 20 degrees\n          (180 * Math.PI) / 180, // Z: 180 degrees ()\n          \"XYZ\"\n        );\n        object.rotation.copy(targetEuler);\n        object.scale.set(10, 10, 10);\n      } else {\n        let targetQuat = key === \"pacman\" ? pacmanQuat : ghostQuat;\n        \n        // For Pacman: use HUD values if available\n        if (key === \"pacman\") {\n          const { getIntroPacmanRotation } = require(\"../core/debug-hud\");\n          const rotation = getIntroPacmanRotation();\n          const euler = new THREE.Euler(\n            (rotation.x * Math.PI) / 180,\n            (rotation.y * Math.PI) / 180,\n            (rotation.z * Math.PI) / 180,\n            \"XYZ\"\n          );\n          targetQuat = new THREE.Quaternion().setFromEuler(euler);\n        }\n        \n        if (targetQuat) {\n          object.quaternion.copy(targetQuat);\n        }\n        setObjectScale(object, key, \"intro\");\n      }\n      object.visible = true;\n\n      const targetOpacity =\n        key === \"pacman\" || key === \"pill\" ? OPACITY.FULL : baseGhostOpacity;\n\n      // For pill, don't manipulate materials - keep original materials from 3D file\n      if (key !== \"pill\") {\n        object.traverse((child) => {\n          if ((child as any).isMesh) {\n            const mesh = child as THREE.Mesh;\n            const childName = child.name || \"\";\n\n            if (\n              isCurrencySymbol(childName) ||\n              (key === \"pacman\" && isPacmanPart(childName))\n            ) {\n              mesh.visible = false;\n              return;\n            }\n\n            mesh.visible = true;\n\n            const mat = mesh.material;\n            if (mat) {\n              const materials = Array.isArray(mat) ? mat : [mat];\n              materials.forEach((material: any) => {\n                material.opacity = targetOpacity;\n                if (\n                  material.transmission !== undefined &&\n                  material.transmission > 0\n                ) {\n                  material.transparent = true;\n                } else {\n                  material.transparent = targetOpacity < 1.0;\n                }\n              });\n            }\n          }\n        });\n      } else {\n        // For pill: just ensure visibility, but keep original materials untouched\n        object.traverse((child) => {\n          if ((child as any).isMesh) {\n            const mesh = child as THREE.Mesh;\n            mesh.visible = true;\n          }\n        });\n      }\n    }\n  );\n}\n","import * as THREE from \"three\";\nimport { ghosts } from \"../core/objects\";\nimport {\n  setObjectOpacity,\n  forEachMaterial,\n  getObjectOpacity,\n} from \"../core/material-utils\";\n\nexport interface ObjectState {\n  position: THREE.Vector3;\n  rotation: THREE.Quaternion;\n  scale: THREE.Vector3;\n  visible: boolean;\n  opacity: number;\n}\n\nexport interface HomeLoopState {\n  t: number;\n  animationTime: number;\n}\n\nexport const homeLoopState: HomeLoopState = {\n  t: 0,\n  animationTime: 0,\n};\n\nexport const currentObjectStates: Record<string, ObjectState> = {};\n\nexport let homeLoopStartPositions: Record<string, THREE.Vector3> = {};\nexport let homeLoopStartRotations: Record<string, THREE.Quaternion> = {};\nexport let homeLoopStartT: number | null = null;\n\nlet isHomeLoopActive = false;\n\nexport function setHomeLoopActive(active: boolean) {\n  isHomeLoopActive = active;\n}\n\nexport function getIsHomeLoopActive(): boolean {\n  return isHomeLoopActive;\n}\n\nexport function updateHomeLoopT(t: number, animationTime: number) {\n  homeLoopState.t = t;\n  homeLoopState.animationTime = animationTime;\n}\n\nexport function initializeObjectStates() {\n  Object.entries(ghosts).forEach(([key, object]) => {\n    const initialOpacity = getObjectOpacity(object);\n\n    currentObjectStates[key] = {\n      position: object.position.clone(),\n      rotation: object.quaternion.clone(),\n      scale: object.scale.clone(),\n      visible: object.visible,\n      opacity: initialOpacity,\n    };\n  });\n}\n\nexport function getCurrentPositions(): Record<string, THREE.Vector3> {\n  const positions: Record<string, THREE.Vector3> = {};\n  Object.entries(currentObjectStates).forEach(([key, state]) => {\n    positions[key] = state.position.clone();\n  });\n  return positions;\n}\n\nexport function getCurrentRotations(): Record<string, THREE.Quaternion> {\n  const rotations: Record<string, THREE.Quaternion> = {};\n  Object.entries(currentObjectStates).forEach(([key, state]) => {\n    rotations[key] = state.rotation.clone();\n  });\n  return rotations;\n}\n\nexport function updateObjectPosition(\n  key: string,\n  position: THREE.Vector3,\n  force: boolean = false,\n  preserveHomeLoopStart: boolean = false\n) {\n  if (!isHomeLoopActive && !force) {\n    return;\n  }\n\n  if (currentObjectStates[key]) {\n    currentObjectStates[key].position.copy(position);\n  }\n\n  if (preserveHomeLoopStart) {\n    homeLoopStartPositions[key] = position.clone();\n  }\n}\n\nexport function getHomeLoopStartPositions(): Record<string, THREE.Vector3> {\n  return { ...homeLoopStartPositions };\n}\n\nexport function updateObjectRotation(\n  key: string,\n  rotation: THREE.Quaternion,\n  preserveHomeLoopStart: boolean = false\n) {\n  if (currentObjectStates[key]) {\n    currentObjectStates[key].rotation.copy(rotation);\n  }\n\n  if (preserveHomeLoopStart) {\n    homeLoopStartRotations[key] = rotation.clone();\n  }\n}\n\nexport function getHomeLoopStartRotations(): Record<string, THREE.Quaternion> {\n  return Object.entries(homeLoopStartRotations).reduce((acc, [key, rot]) => {\n    acc[key] = rot.clone();\n    return acc;\n  }, {} as Record<string, THREE.Quaternion>);\n}\n\nexport function setHomeLoopStartT(t: number): void {\n  homeLoopStartT = t;\n}\n\nexport function getHomeLoopStartT(): number | null {\n  return homeLoopStartT;\n}\n","import * as THREE from \"three\";\nimport { MazePathPoint, PathPoint, CameraPathPoint } from \"../types/types\";\nimport {\n  homePaths,\n  povPaths,\n  createHomeScrollPathPoints,\n  getCameraHomeScrollPathPoints,\n} from \"./pathpoints\";\n\nconst pathCache = new Map<string, THREE.CurvePath<THREE.Vector3>>();\n\nexport class TangentSmoother {\n  private currentTangent: THREE.Vector3;\n  private smoothing: number;\n\n  constructor(initialTangent: THREE.Vector3, smoothing: number = 0.06) {\n    this.currentTangent = initialTangent.clone();\n    this.smoothing = smoothing;\n  }\n\n  update(targetTangent: THREE.Vector3): THREE.Vector3 {\n    this.currentTangent.lerp(targetTangent, this.smoothing);\n    return this.currentTangent.normalize();\n  }\n\n  reset(newTangent: THREE.Vector3): void {\n    this.currentTangent.copy(newTangent);\n  }\n\n  getCurrentTangent(): THREE.Vector3 {\n    return this.currentTangent.clone();\n  }\n\n  setSmoothingFactor(smoothing: number): void {\n    this.smoothing = Math.max(0.001, Math.min(1, smoothing));\n  }\n}\n\nfunction createMazePath(\n  pathPoints: MazePathPoint[]\n): THREE.CurvePath<THREE.Vector3> {\n  const cacheKey = pathPoints\n    .map((p) => `${p.pos.x},${p.pos.y},${p.pos.z},${p.type},${p.arc || \"\"}`)\n    .join(\"|\");\n\n  if (pathCache.has(cacheKey)) {\n    return pathCache.get(cacheKey)!;\n  }\n\n  const path = new THREE.CurvePath<THREE.Vector3>();\n\n  let i = 0;\n  while (i < pathPoints.length - 1) {\n    const current = pathPoints[i];\n    const next = pathPoints[i + 1];\n\n    if (current.curveCheckPoints?.length) {\n      const catmullPoints = [\n        current.pos,\n        ...current.curveCheckPoints,\n        next.pos,\n      ];\n      path.add(\n        new THREE.CatmullRomCurve3(catmullPoints, false, \"centripetal\", 0)\n      );\n    } else if (current.type === \"straight\") {\n      path.add(new THREE.LineCurve3(current.pos, next.pos));\n    } else {\n      const midPoint = createNormalCurveMidPoint(current, next);\n      path.add(\n        new THREE.QuadraticBezierCurve3(current.pos, midPoint, next.pos)\n      );\n    }\n\n    i++;\n  }\n\n  pathCache.set(cacheKey, path);\n  return path;\n}\n\nfunction createNormalCurveMidPoint(\n  current: MazePathPoint,\n  next: MazePathPoint\n): THREE.Vector3 {\n  if (current.arc) {\n    const curveType = current.arc;\n\n    if (curveType === \"upperArc\") {\n      return new THREE.Vector3(current.pos.x, current.pos.y, next.pos.z);\n    } else if (curveType === \"lowerArc\") {\n      return new THREE.Vector3(next.pos.x, current.pos.y, current.pos.z);\n    } else if (curveType === \"forwardDownArc\") {\n      return new THREE.Vector3(current.pos.x, next.pos.y, current.pos.z);\n    }\n  }\n\n  return new THREE.Vector3(current.pos.x, current.pos.y, next.pos.z);\n}\n\nfunction createHomeScrollPath(\n  pathPoints: PathPoint[]\n): THREE.CurvePath<THREE.Vector3> {\n  const path = new THREE.CurvePath<THREE.Vector3>();\n\n  if (pathPoints.length === 3) {\n    const curve = new THREE.QuadraticBezierCurve3(\n      pathPoints[0].pos,\n      pathPoints[1].pos,\n      pathPoints[2].pos\n    );\n    path.add(curve);\n  }\n\n  return path;\n}\n\nfunction createCameraHomeScrollPath(\n  pathPoints: CameraPathPoint[]\n): THREE.CurvePath<THREE.Vector3> {\n  const path = new THREE.CurvePath<THREE.Vector3>();\n\n  if (pathPoints.length === 4) {\n    const curve = new THREE.CubicBezierCurve3(\n      pathPoints[0].pos,\n      pathPoints[1].pos,\n      pathPoints[2].pos,\n      pathPoints[3].pos\n    );\n    path.add(curve);\n  }\n\n  return path;\n}\n\nexport function getHomePaths(): Record<string, THREE.CurvePath<THREE.Vector3>> {\n  const paths: Record<string, THREE.CurvePath<THREE.Vector3>> = {};\n\n  Object.entries(homePaths).forEach(([key, pathPoints]) => {\n    paths[key] = createMazePath(pathPoints);\n  });\n\n  return paths;\n}\n\nexport function getHomeScrollPaths(\n  pausedPositions: Record<string, THREE.Vector3>\n): Record<string, THREE.CurvePath<THREE.Vector3>> {\n  const scrollPathPoints = createHomeScrollPathPoints(pausedPositions);\n  const cameraPathPoints = getCameraHomeScrollPathPoints();\n\n  const paths: Record<string, THREE.CurvePath<THREE.Vector3>> = {\n    camera: createCameraHomeScrollPath(cameraPathPoints),\n  };\n\n  Object.entries(scrollPathPoints).forEach(([key, pathPoints]) => {\n    paths[key] = createHomeScrollPath(pathPoints);\n  });\n\n  return paths;\n}\n\nexport function getPovPaths(): Record<string, THREE.CurvePath<THREE.Vector3>> {\n  const paths: Record<string, THREE.CurvePath<THREE.Vector3>> = {};\n\n  Object.entries(povPaths).forEach(([key, pathPoints]) => {\n    paths[key] = createMazePath(pathPoints as MazePathPoint[]);\n  });\n\n  return paths;\n}\n","import * as THREE from \"three\";\nimport { isMobile } from \"../config/config\";\nimport { DOM_ELEMENTS } from \"../config/dom-elements\";\nimport { camera } from \"./camera\";\n\nexport const scene = new THREE.Scene();\n\nconst renderer = new THREE.WebGLRenderer({\n  antialias: true,\n  alpha: true,\n  powerPreference: \"high-performance\",\n  precision: \"highp\",\n});\n\nconst clock = new THREE.Clock();\nconst frameCallbacks: (() => void)[] = [];\n\nexport function initRenderer(): void {\n  enhanceAntiAliasing();\n\n  if (DOM_ELEMENTS.mazeContainer) {\n    renderer.setSize(\n      DOM_ELEMENTS.mazeContainer.clientWidth,\n      DOM_ELEMENTS.mazeContainer.clientHeight\n    );\n    DOM_ELEMENTS.mazeContainer.appendChild(renderer.domElement);\n  } else {\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(renderer.domElement);\n  }\n\n  setPixelRatio();\n  window.addEventListener(\"resize\", setPixelRatio);\n\n  renderer.render(scene, camera);\n}\n\nfunction enhanceAntiAliasing(): void {\n  if (isMobile) {\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n  } else {\n    renderer.setPixelRatio(window.devicePixelRatio);\n  }\n  renderer.shadowMap.enabled = true;\n  renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n}\n\nfunction setPixelRatio(): void {\n  const pixelRatio = Math.min(window.devicePixelRatio, isMobile ? 2 : 3);\n  renderer.setPixelRatio(pixelRatio);\n\n  if (DOM_ELEMENTS.mazeContainer) {\n    renderer.setSize(\n      DOM_ELEMENTS.mazeContainer.clientWidth,\n      DOM_ELEMENTS.mazeContainer.clientHeight\n    );\n    camera.aspect =\n      DOM_ELEMENTS.mazeContainer.clientWidth /\n      DOM_ELEMENTS.mazeContainer.clientHeight;\n  } else {\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    camera.aspect = window.innerWidth / window.innerHeight;\n  }\n\n  camera.updateProjectionMatrix();\n}\n\nexport function setupLighting(): void {\n  const ambientLight = new THREE.AmbientLight(0xffffff);\n  scene.add(ambientLight);\n\n  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n  scene.add(directionalLight);\n  directionalLight.position.set(-5, 15, 10);\n  directionalLight.shadow.mapSize.width = 4096;\n  directionalLight.shadow.mapSize.height = 4096;\n  directionalLight.shadow.camera.left = -20;\n  directionalLight.shadow.camera.right = 20;\n  directionalLight.shadow.camera.top = 20;\n  directionalLight.shadow.camera.bottom = -20;\n  directionalLight.shadow.camera.near = 0.1;\n  directionalLight.shadow.camera.far = 50;\n  directionalLight.shadow.bias = -0.001;\n  directionalLight.shadow.radius = 3;\n  directionalLight.castShadow = true;\n}\n\n// Create a simple environment map for realistic glass reflections\nexport function createEnvironmentMap(): void {\n  const envScene = new THREE.Scene();\n  const geometry = new THREE.BoxGeometry(100, 100, 100);\n  const material = new THREE.MeshBasicMaterial({\n    color: 0x666666,\n    side: THREE.BackSide,\n  });\n  const skybox = new THREE.Mesh(geometry, material);\n  envScene.add(skybox);\n\n  const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256);\n  const cubeCamera = new THREE.CubeCamera(0.1, 1000, cubeRenderTarget);\n  cubeCamera.update(renderer, envScene);\n  scene.environment = cubeRenderTarget.texture;\n}\n\nexport function startRenderLoop(): void {\n  const render = () => {\n    frameCallbacks.forEach((callback) => callback());\n\n    renderer.render(scene, camera);\n\n    requestAnimationFrame(render);\n  };\n  render();\n}\n\nexport function onFrame(callback: () => void): void {\n  frameCallbacks.push(callback);\n}\n\nexport { renderer, clock };\n","import gsap from \"gsap\";\nimport * as THREE from \"three\";\nimport { scene } from \"../core/scene\";\nimport { SCALE, OPACITY } from \"./constants\";\nimport { forEachMaterial } from \"../core/material-utils\";\n\nexport function setFloorPlane(\n  visible: boolean,\n  opacity: number = OPACITY.FULL,\n  transparent: boolean = false\n): void {\n  scene.traverse((child) => {\n    if (child.name === \"CAM-Floor\") {\n      child.visible = visible;\n      if (child instanceof THREE.Mesh && child.material) {\n        const material = child.material as THREE.MeshBasicMaterial;\n        material.color.setHex(0xffffff);\n        material.opacity = opacity;\n        material.transparent = transparent;\n      }\n    }\n  });\n}\n\nexport function setObjectScale(\n  object: THREE.Object3D,\n  key: string,\n  sceneType: \"home\" | \"intro\" | \"pov\" | \"outro\"\n): void {\n  let scale: number;\n\n  if (key === \"pacman\") {\n    scale = sceneType === \"intro\" ? SCALE.PACMAN_INTRO : SCALE.PACMAN_HOME;\n  } else {\n    if (sceneType === \"intro\") {\n      scale = SCALE.GHOST_INTRO;\n    } else if (sceneType === \"pov\") {\n      scale = SCALE.GHOST_POV;\n    } else {\n      scale = SCALE.GHOST_NORMAL;\n    }\n  }\n\n  object.scale.set(scale, scale, scale);\n  object.updateMatrixWorld(true);\n  gsap.set(object.scale, { x: scale, y: scale, z: scale });\n}\n\nexport function killObjectAnimations(object: THREE.Object3D): void {\n  gsap.killTweensOf(object);\n  gsap.killTweensOf(object.scale);\n  gsap.killTweensOf(object.position);\n  gsap.killTweensOf(object.rotation);\n  gsap.killTweensOf(object.quaternion);\n\n  forEachMaterial(\n    object,\n    (mat: any) => {\n      gsap.killTweensOf(mat);\n      gsap.killTweensOf(mat.opacity);\n    },\n    { skipCurrencySymbols: false }\n  );\n}\n","import * as THREE from \"three\";\nimport { getLookAtPosition, getStartPosition } from \"../paths/pathpoints\";\n\nconst CAMERA_NEAR = 0.001;\nconst CAMERA_FAR = 100;\n\nexport const camera = new THREE.PerspectiveCamera(\n  50,\n  window.innerWidth / window.innerHeight,\n  CAMERA_NEAR,\n  CAMERA_FAR\n);\n\nexport function setupCamera(): void {\n  const startPosition = getStartPosition();\n  const lookAtPosition = getLookAtPosition();\n  camera.position.set(startPosition.x, startPosition.y, startPosition.z);\n  camera.lookAt(lookAtPosition.x, lookAtPosition.y, lookAtPosition.z);\n}\n","module.exports = ScrollTrigger;","import * as THREE from \"three\";\n\nexport const OBJECT_KEYS = [\n  \"pacman\",\n  \"ghost1\",\n  \"ghost2\",\n  \"ghost3\",\n  \"ghost4\",\n  \"ghost5\",\n] as const;\n\nconst CURRENCY_SYMBOLS = [\"EUR\", \"CHF\", \"YEN\", \"USD\", \"GBP\"] as const;\n\nexport function isCurrencySymbol(name: string): boolean {\n  return CURRENCY_SYMBOLS.some(\n    (symbol) => name === symbol || name.includes(symbol)\n  );\n}\n\nexport function isPacmanPart(name: string): boolean {\n  return (\n    name.includes(\"Shell\") ||\n    name.includes(\"Bitcoin_1\") ||\n    name.includes(\"Bitcoin_2\")\n  );\n}\n\nexport function calculateObjectOrientation(\n  object: THREE.Object3D,\n  tangent: THREE.Vector3,\n  objectType: \"pacman\" | \"ghost\" | \"camera\" = \"ghost\"\n): void {\n  if (!tangent?.length()) return;\n\n  const targetRotation = Math.atan2(tangent.x, tangent.z);\n\n  if (objectType === \"pacman\") {\n    object.rotation.set(\n      -(Math.PI / 2),\n      Math.PI,\n      -(targetRotation + Math.PI / 2)\n    );\n  } else if (objectType === \"ghost\") {\n    object.rotation.set(0, targetRotation, 0);\n  } else if (objectType === \"camera\") {\n    const lookAtPoint = object.position.clone().add(tangent);\n    object.lookAt(lookAtPoint);\n  }\n}\n\nconst baseLayDownQuat = new THREE.Quaternion().setFromEuler(\n  new THREE.Euler(Math.PI / 2, 0, 0)\n);\nconst yAxis180 = new THREE.Quaternion().setFromAxisAngle(\n  new THREE.Vector3(0, 1, 0),\n  Math.PI\n);\nexport const LAY_DOWN_QUAT_1 = yAxis180.clone().multiply(baseLayDownQuat);\n\nexport const LAY_DOWN_QUAT_2 = new THREE.Quaternion().setFromEuler(\n  new THREE.Euler(-Math.PI / 2, 0, 0)\n);\n\nexport function slerpToLayDown(\n  object: THREE.Object3D,\n  startQuat: THREE.Quaternion,\n  progress: number\n) {\n  const d1 = startQuat.angleTo(LAY_DOWN_QUAT_1);\n  const d2 = startQuat.angleTo(LAY_DOWN_QUAT_2);\n  const targetQuat = d1 < d2 ? LAY_DOWN_QUAT_1 : LAY_DOWN_QUAT_2;\n\n  object.quaternion.copy(startQuat.clone().slerp(targetQuat, progress));\n}\n\nexport function rotateQuaternionAroundAxis(\n  quat: THREE.Quaternion,\n  axis: \"x\" | \"y\" | \"z\",\n  angle: number\n): THREE.Quaternion {\n  const axisVector =\n    axis === \"x\"\n      ? new THREE.Vector3(1, 0, 0)\n      : axis === \"y\"\n      ? new THREE.Vector3(0, 1, 0)\n      : new THREE.Vector3(0, 0, 1);\n\n  const rotation = new THREE.Quaternion().setFromAxisAngle(axisVector, angle);\n\n  return quat.clone().multiply(rotation);\n}\n\nexport function applyRotations(\n  quat: THREE.Quaternion,\n  rotations: Array<{ axis: \"x\" | \"y\" | \"z\"; angle: number }>\n): THREE.Quaternion {\n  let result = quat.clone();\n  rotations.forEach(({ axis, angle }) => {\n    result = rotateQuaternionAroundAxis(result, axis, angle);\n  });\n  return result;\n}\n","module.exports = THREE;","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInstancedBufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst dstArray = new Float32Array( attribute.count * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.count; i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry );\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet gpuType = - 1;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( gpuType === - 1 ) gpuType = attribute.gpuType;\n\t\tif ( gpuType !== attribute.gpuType ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tarray.set( attributes[ i ].array, offset );\n\n\t\toffset += attributes[ i ].array.length;\n\n\t}\n\n\tconst result = new BufferAttribute( array, itemSize, normalized );\n\tif ( gpuType !== undefined ) {\n\n\t\tresult.gpuType = gpuType;\n\n\t}\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferAttribute}\n * @return {BufferAttribute}\n */\nexport function deepCloneAttribute( attribute ) {\n\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\n\n\t\treturn deinterleaveAttribute( attribute );\n\n\t}\n\n\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\treturn new InstancedBufferAttribute().copy( attribute );\n\n\t}\n\n\treturn new BufferAttribute().copy( attribute );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// returns a new, non-interleaved version of the provided attribute\nexport function deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n// deinterleaves all attributes on the geometry\nexport function deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst tmpAttributes = {};\n\tconst tmpMorphAttributes = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t// Initialize the arrays, allocating space conservatively. Extra\n\t// space will be trimmed in the last step.\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst attr = geometry.attributes[ name ];\n\n\t\ttmpAttributes[ name ] = new BufferAttribute(\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\n\t\t\tattr.itemSize,\n\t\t\tattr.normalized\n\t\t);\n\n\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\tif ( morphAttr ) {\n\n\t\t\ttmpMorphAttributes[ name ] = new BufferAttribute(\n\t\t\t\tnew morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize ),\n\t\t\t\tmorphAttr.itemSize,\n\t\t\t\tmorphAttr.normalized\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst halfTolerance = tolerance * 0.5;\n\tconst exponent = Math.log10( 1 / tolerance );\n\tconst hashMultiplier = Math.pow( 10, exponent );\n\tconst hashAdditive = halfTolerance * hashMultiplier;\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * hashMultiplier + hashAdditive ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the temporary attributes\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newarray = tmpAttributes[ name ];\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tconst setterFunc = setters[ k ];\n\t\t\t\t\tnewarray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// generate result BufferGeometry\n\tconst result = geometry.clone();\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst tmpAttribute = tmpAttributes[ name ];\n\n\t\tresult.setAttribute( name, new BufferAttribute(\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\n\t\t\ttmpAttribute.itemSize,\n\t\t\ttmpAttribute.normalized,\n\t\t) );\n\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\n\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\n\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\n\n\t\t\tresult.morphAttributes[ name ][ j ] = new BufferAttribute(\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\n\t\t\t\ttmpMorphAttribute.itemSize,\n\t\t\t\ttmpMorphAttribute.normalized,\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.applyBoneTransform( a, _vA );\n\t\t\tobject.applyBoneTransform( b, _vB );\n\t\t\tobject.applyBoneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * @param {BufferGeometry} geometry\n * @param {number} [creaseAngle]\n * @return {BufferGeometry}\n */\nfunction toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\n\n\tconst creaseDot = Math.cos( creaseAngle );\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\n\t// reusable vectors\n\tconst verts = [ new Vector3(), new Vector3(), new Vector3() ];\n\tconst tempVec1 = new Vector3();\n\tconst tempVec2 = new Vector3();\n\tconst tempNorm = new Vector3();\n\tconst tempNorm2 = new Vector3();\n\n\t// hashes a vector\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\t\treturn `${x},${y},${z}`;\n\n\t}\n\n\t// BufferGeometry.toNonIndexed() warns if the geometry is non-indexed\n\t// and returns the original geometry\n\tconst resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\tconst posAttr = resultGeometry.attributes.position;\n\tconst vertexMap = {};\n\n\t// find all the normals shared by commonly located vertices\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\t// add the normal to the map for all vertices\n\t\tconst normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tif ( ! ( hash in vertexMap ) ) {\n\n\t\t\t\tvertexMap[ hash ] = [];\n\n\t\t\t}\n\n\t\t\tvertexMap[ hash ].push( normal );\n\n\t\t}\n\n\t}\n\n\t// average normals from all vertices that share a common location if they are within the\n\t// provided crease threshold\n\tconst normalArray = new Float32Array( posAttr.count * 3 );\n\tconst normAttr = new BufferAttribute( normalArray, 3, false );\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\t// get the face normal for this vertex\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\ttempNorm.crossVectors( tempVec1, tempVec2 ).normalize();\n\n\t\t// average all normals that meet the threshold and set the normal value\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tconst otherNormals = vertexMap[ hash ];\n\t\t\ttempNorm2.set( 0, 0, 0 );\n\n\t\t\tfor ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {\n\n\t\t\t\tconst otherNorm = otherNormals[ k ];\n\t\t\t\tif ( tempNorm.dot( otherNorm ) > creaseDot ) {\n\n\t\t\t\t\ttempNorm2.add( otherNorm );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttempNorm2.normalize();\n\t\t\tnormAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );\n\n\t\t}\n\n\t}\n\n\tresultGeometry.setAttribute( 'normal', normAttr );\n\treturn resultGeometry;\n\n}\n\nfunction mergeBufferGeometries( geometries, useGroups = false ) {\n\n\tconsole.warn( 'THREE.BufferGeometryUtils: mergeBufferGeometries() has been renamed to mergeGeometries().' ); // @deprecated, r151\n\treturn mergeGeometries( geometries, useGroups );\n\n}\n\nfunction mergeBufferAttributes( attributes ) {\n\n\tconsole.warn( 'THREE.BufferGeometryUtils: mergeBufferAttributes() has been renamed to mergeAttributes().' ); // @deprecated, r151\n\treturn mergeAttributes( attributes );\n\n}\n\nexport {\n\tcomputeMikkTSpaceTangents,\n\tmergeGeometries,\n\tmergeBufferGeometries,\n\tmergeAttributes,\n\tmergeBufferAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups,\n\ttoCreasedNormals\n};\n","import * as THREE from \"three\";\nimport { mergeGeometries } from \"three/examples/jsm/utils/BufferGeometryUtils.js\";\nimport { ASSETS } from \"../config/config\";\nimport { GhostContainer } from \"../types/types\";\nimport { clock } from \"./scene\";\nimport {\n  mazeMaterial,\n  topMaterial,\n  ghostMaterial,\n  floorMaterial,\n  materialMap,\n  pillMaterialMap,\n} from \"./materials\";\n\nexport { clock };\n\nconst loader = new THREE.GLTFLoader();\n\nexport let pacmanMixer: THREE.AnimationMixer;\n\nexport const pacman = new THREE.Group();\n\nexport const ghosts: GhostContainer = {\n  pacman: pacman,\n  ghost1: new THREE.Mesh(new THREE.BufferGeometry(), ghostMaterial),\n  ghost2: new THREE.Mesh(new THREE.BufferGeometry(), ghostMaterial),\n  ghost3: new THREE.Mesh(new THREE.BufferGeometry(), ghostMaterial),\n  ghost4: new THREE.Mesh(new THREE.BufferGeometry(), ghostMaterial),\n  ghost5: new THREE.Mesh(new THREE.BufferGeometry(), ghostMaterial),\n};\n\nexport const pill = new THREE.Group();\npill.visible = true;\n\n// Helper function to split geometry by Y position using toNonIndexed approach\nfunction splitGeometryByY(\n  geometry: THREE.BufferGeometry,\n  splitY: number\n): { topGeometry: THREE.BufferGeometry; bottomGeometry: THREE.BufferGeometry } {\n  // Convert to non-indexed to make filtering easier\n  const nonIndexedGeometry = geometry.toNonIndexed();\n  const positionAttribute = nonIndexedGeometry.attributes.position;\n  const positions = positionAttribute.array as Float32Array;\n\n  const topPositions: number[] = [];\n  const bottomPositions: number[] = [];\n\n  // Filter triangles based on centroid Y position\n  for (let i = 0; i < positions.length; i += 9) {\n    // Each triangle has 9 values (3 vertices * 3 components)\n    const y0 = positions[i + 1];\n    const y1 = positions[i + 4];\n    const y2 = positions[i + 7];\n    const centroidY = (y0 + y1 + y2) / 3;\n\n    const trianglePositions = [\n      positions[i],\n      positions[i + 1],\n      positions[i + 2],\n      positions[i + 3],\n      positions[i + 4],\n      positions[i + 5],\n      positions[i + 6],\n      positions[i + 7],\n      positions[i + 8],\n    ];\n\n    if (centroidY >= splitY) {\n      topPositions.push(...trianglePositions);\n    } else {\n      bottomPositions.push(...trianglePositions);\n    }\n  }\n\n  // Create new geometries\n  const topGeometry = new THREE.BufferGeometry();\n  topGeometry.setAttribute(\n    \"position\",\n    new THREE.BufferAttribute(new Float32Array(topPositions), 3)\n  );\n\n  const bottomGeometry = new THREE.BufferGeometry();\n  bottomGeometry.setAttribute(\n    \"position\",\n    new THREE.BufferAttribute(new Float32Array(bottomPositions), 3)\n  );\n\n  // Compute normals for both geometries\n  topGeometry.computeVertexNormals();\n  bottomGeometry.computeVertexNormals();\n\n  return { topGeometry, bottomGeometry };\n}\n\nconst ghostContainers = {\n  Ghost_EUR: ghosts.ghost1,\n  Ghost_CHF: ghosts.ghost2,\n  Ghost_YEN: ghosts.ghost3,\n  Ghost_USD: ghosts.ghost4,\n  Ghost_GBP: ghosts.ghost5,\n};\n\nexport async function loadModel(scene: THREE.Scene): Promise<void> {\n  Object.values(ghosts).forEach((ghost) => scene.add(ghost));\n  scene.add(pacman);\n  scene.add(pill);\n  return new Promise((resolve, reject) => {\n    loader.load(\n      ASSETS.mazeModel,\n      function (gltf) {\n        const model = gltf.scene;\n\n        // Combined traversal: collect names and process objects in one pass\n        const allObjectNames: string[] = [];\n        model.traverse((child: THREE.Object3D) => {\n          // Collect names for debugging (only in development)\n          if (process.env.NODE_ENV === \"development\" && child.name) {\n            allObjectNames.push(child.name);\n          }\n          if (child.name === \"CAM-Pacman\") {\n            const children: THREE.Object3D[] = [];\n            child.traverse((subChild: THREE.Object3D) => {\n              if (\n                (subChild as any).isMesh &&\n                subChild.name !== \"CAM-Pacman_Shell\" &&\n                subChild.name !== \"CAM-Pacman_Shell_Boolean\" &&\n                subChild.name !== \"CAM-Pacman_Bitcoin_1\" &&\n                subChild.name !== \"CAM-Pacman_Bitcoin_2\"\n              ) {\n                const material =\n                  materialMap[subChild.name as keyof typeof materialMap] ||\n                  materialMap.default;\n                (subChild as THREE.Mesh).material = material;\n                children.push(subChild);\n              } else if (\n                subChild.name === \"CAM-Pacman_Shell\" ||\n                subChild.name === \"CAM-Pacman_Shell_Boolean\" ||\n                subChild.name === \"CAM-Pacman_Bitcoin_1\" ||\n                subChild.name === \"CAM-Pacman_Bitcoin_2\"\n              ) {\n                subChild.visible = false;\n              }\n            });\n\n            children.forEach((item) => ghosts.pacman.add(item));\n            ghosts.pacman.scale.set(0.05, 0.05, 0.05);\n            ghosts.pacman.rotation.set(Math.PI / 2, Math.PI / 2, Math.PI / 4);\n\n            pacmanMixer = new THREE.AnimationMixer(ghosts.pacman);\n            const pacmanActions: { [key: string]: THREE.AnimationAction } = {};\n\n            gltf.animations.forEach((clip: THREE.AnimationClip) => {\n              const action = pacmanMixer.clipAction(clip);\n\n              action.getMixer().addEventListener(\"loop\", function (e) {\n                e.action.getRoot().traverse(function (obj) {\n                  if (obj.userData && obj.userData.skipAnimation) {\n                    (obj as any).updateMorphTargets = function () {};\n                  }\n                });\n              });\n\n              pacmanActions[clip.name] = action;\n              action.setEffectiveWeight(0);\n              action.play();\n            });\n            Object.values(pacmanActions).forEach((action) => {\n              action.setEffectiveWeight(1);\n            });\n          } else if (\n            child.name &&\n            ghostContainers[child.name as keyof typeof ghostContainers]\n          ) {\n            const ghostContainer =\n              ghostContainers[child.name as keyof typeof ghostContainers];\n            const ghostGroup = new THREE.Group();\n\n            child.rotation.z = Math.PI;\n            child.rotation.x = Math.PI / 2;\n            child.scale.set(0.75, 0.75, 0.75);\n\n            const children: THREE.Object3D[] = [];\n            child.traverse((subChild: THREE.Object3D) => {\n              if ((subChild as any).isMesh) {\n                if (subChild.name && subChild.name.startsWith(\"Ghost_Mesh\")) {\n                  (subChild as THREE.Mesh).material = ghostMaterial;\n                } else if (\n                  subChild.name &&\n                  [\"EUR\", \"CHF\", \"YEN\", \"USD\", \"GBP\"].includes(subChild.name)\n                ) {\n                  subChild.visible = false;\n                }\n                children.push(subChild);\n              }\n            });\n\n            children.forEach((item) => {\n              if (\n                item.name &&\n                (item.name.includes(\"EUR\") ||\n                  item.name.startsWith(\"Ghost_Mesh\"))\n              ) {\n                item.rotation.z = Math.PI;\n                item.rotation.x = Math.PI / 2;\n              } else {\n                item.rotation.set(0, 0, 0);\n              }\n              ghostGroup.add(item);\n            });\n\n            if (ghostContainer) {\n              ghostContainer.add(ghostGroup);\n            }\n          } else if (\n            child.name &&\n            !child.name.toLowerCase().includes(\"pacman\") &&\n            (child.name === \"CAM-Pill-Orange\" ||\n              (child.name.toLowerCase().includes(\"pill\") &&\n                child.name.toLowerCase().includes(\"orange\")))\n          ) {\n            const pillGroup = new THREE.Group();\n\n            // First pass: collect all shell meshes\n            const shellMeshes: THREE.Mesh[] = [];\n            const otherMeshes: Array<{\n              mesh: THREE.Mesh;\n              name: string;\n              isBitcoin: boolean;\n            }> = [];\n\n            child.traverse((subChild: THREE.Object3D) => {\n              if ((subChild as any).isMesh) {\n                const mesh = subChild as THREE.Mesh;\n                const subChildName = subChild.name || \"\";\n                const clonedMesh = mesh.clone();\n                const lowerName = subChildName.toLowerCase();\n                const isShell = lowerName.includes(\"shell\");\n                const isBitcoin =\n                  lowerName.includes(\"bitcoin\") ||\n                  lowerName.includes(\"btc_logo\");\n\n                if (isShell) {\n                  shellMeshes.push(clonedMesh);\n                } else {\n                  otherMeshes.push({\n                    mesh: clonedMesh,\n                    name: subChildName,\n                    isBitcoin,\n                  });\n                }\n              }\n            });\n\n            // Process all shell meshes together - combine them first, then split\n            if (shellMeshes.length > 0) {\n              // Apply mesh transformations to geometries before merging\n              const transformedGeometries = shellMeshes.map((mesh) => {\n                const geometry = mesh.geometry.clone();\n                // Apply mesh transformations to geometry\n                geometry.applyMatrix4(mesh.matrixWorld);\n                return geometry;\n              });\n\n              // Use BufferGeometryUtils to properly merge geometries\n              let combinedGeometry: THREE.BufferGeometry;\n              if (transformedGeometries.length === 1) {\n                combinedGeometry = transformedGeometries[0];\n              } else {\n                combinedGeometry = mergeGeometries(transformedGeometries);\n              }\n\n              // Calculate center Y for the combined geometry\n              combinedGeometry.computeBoundingBox();\n              const bbox = combinedGeometry.boundingBox!;\n              const centerY = (bbox.max.y + bbox.min.y) / 2;\n\n              // Dispose original geometries after merging\n              transformedGeometries.forEach((geo) => {\n                if (geo !== combinedGeometry) {\n                  geo.dispose();\n                }\n              });\n\n              // Split combined geometry into top and bottom halves\n              const { topGeometry, bottomGeometry } = splitGeometryByY(\n                combinedGeometry,\n                centerY\n              );\n\n              // Create top half mesh (orange, nearly intransparent)\n              const topMesh = new THREE.Mesh(\n                topGeometry,\n                (\n                  pillMaterialMap.shellBack as THREE.MeshPhysicalMaterial\n                ).clone()\n              );\n              topMesh.visible = true;\n              topMesh.castShadow = true;\n              topMesh.receiveShadow = true;\n              pillGroup.add(topMesh);\n\n              // Create bottom half mesh (transparent white glass)\n              const bottomMesh = new THREE.Mesh(\n                bottomGeometry,\n                (\n                  pillMaterialMap.shellFront as THREE.MeshPhysicalMaterial\n                ).clone()\n              );\n              bottomMesh.visible = true;\n              bottomMesh.castShadow = true;\n              bottomMesh.receiveShadow = true;\n              pillGroup.add(bottomMesh);\n            }\n\n            // Process other meshes (bitcoin, inner elements, etc.)\n            otherMeshes.forEach(({ mesh, name, isBitcoin }) => {\n              if (isBitcoin) {\n                mesh.material = pillMaterialMap.bitcoin; // Fully orange (the B symbol)\n              } else {\n                mesh.material = pillMaterialMap.default; // Black for inner elements\n              }\n              mesh.visible = true;\n              mesh.castShadow = true;\n              mesh.receiveShadow = true;\n              pillGroup.add(mesh);\n            });\n            if (pillGroup.children.length > 0) {\n              pill.add(pillGroup);\n            }\n          }\n\n          if ((child as any).isMesh) {\n            if (child.name === \"CAM-Arena_LowRes_Top\") {\n              (child as THREE.Mesh).material = topMaterial;\n              child.castShadow = true;\n            } else if (child.name === \"CAM-Arena_LowRes_Bottom\") {\n              (child as THREE.Mesh).material = mazeMaterial;\n              child.castShadow = true;\n            } else if (child.name === \"CAM-Floor\") {\n              const clonedChild = child.clone();\n              child.position.y = -0.1;\n              child.position.x = 0;\n              child.position.z = 0;\n              (child as THREE.Mesh).material = new THREE.MeshBasicMaterial({\n                color: 0xffffff,\n                opacity: 1,\n                transparent: false,\n                depthWrite: true,\n                depthTest: true,\n                side: THREE.FrontSide,\n              });\n              child.receiveShadow = false;\n              child.castShadow = true;\n              child.scale.set(0.5, 0.5, 0.5);\n\n              (clonedChild as THREE.Mesh).material = floorMaterial;\n              clonedChild.position.y = -0.5;\n              clonedChild.receiveShadow = true;\n              scene.add(clonedChild);\n            } else {\n              (child as THREE.Mesh).visible = false;\n            }\n          }\n\n          // Set shadow properties during the same traversal\n          if ((child as any).isMesh) {\n            child.castShadow = true;\n            child.receiveShadow = true;\n          }\n        });\n\n        scene.add(model);\n        model.position.set(0.5, 0.5, 0.5);\n\n        if (pill.children.length > 0) {\n          pill.scale.set(0.05, 0.05, 0.05);\n          pill.visible = true;\n          pill.traverse((child) => {\n            if ((child as any).isMesh) {\n              (child as THREE.Mesh).visible = true;\n            }\n          });\n        }\n\n        resolve();\n      },\n      undefined,\n      function (error: any) {\n        reject(error);\n      }\n    );\n  });\n}\n","import * as THREE from \"three\";\n\nexport type XCoordKey =\n  | \"0\"\n  | \"0.5\"\n  | \"1\"\n  | \"1.5\"\n  | \"2\"\n  | \"2.5\"\n  | \"3\"\n  | \"3.5\"\n  | \"4\"\n  | \"4.5\"\n  | \"5\"\n  | \"5.5\"\n  | \"6\"\n  | \"6.5\"\n  | \"7\"\n  | \"7.5\"\n  | \"8\"\n  | \"8.5\"\n  | \"9\"\n  | \"9.5\"\n  | \"10\"\n  | \"10.5\"\n  | \"11\"\n  | \"11.5\"\n  | \"12\"\n  | \"12.5\"\n  | \"13\"\n  | \"13.5\"\n  | \"14\"\n  | \"14.5\"\n  | \"15\"\n  | \"15.5\"\n  | \"16\"\n  | \"16.5\"\n  | \"17\"\n  | \"17.5\"\n  | \"18\"\n  | \"18.5\"\n  | \"19\"\n  | \"19.5\"\n  | \"20\"\n\nexport type ZCoordKey =\n  | \"0\"\n  | \"0.5\"\n  | \"1\"\n  | \"1.5\"\n  | \"2\"\n  | \"2.5\"\n  | \"3\"\n  | \"3.5\"\n  | \"4\"\n  | \"4.5\"\n  | \"5\"\n  | \"5.5\"\n  | \"6\"\n  | \"6.5\"\n  | \"7\"\n  | \"7.5\"\n  | \"8\"\n  | \"8.5\"\n  | \"9\"\n  | \"9.5\"\n  | \"10\"\n  | \"10.5\"\n  | \"11\"\n  | \"11.5\"\n  | \"12\"\n  | \"12.5\"\n  | \"13\"\n  | \"13.5\"\n  | \"14\"\n  | \"14.5\"\n  | \"15\"\n  | \"15.5\"\n  | \"16\"\n\nexport const Y = 0.55;\n\nexport const X: Record<XCoordKey, number> = {\n  \"0\": -0.54875,\n  \"0.5\": -0.4985,\n  \"1\": -0.44825,\n  \"1.5\": -0.398,\n  \"2\": -0.34775,\n  \"2.5\": -0.2975,\n  \"3\": -0.24725,\n  \"3.5\": -0.197,\n  \"4\": -0.14675,\n  \"4.5\": -0.0965,\n  \"5\": -0.04625,\n  \"5.5\": 0.004,\n  \"6\": 0.05425,\n  \"6.5\": 0.1045,\n  \"7\": 0.15475,\n  \"7.5\": 0.205,\n  \"8\": 0.25525,\n  \"8.5\": 0.3055,\n  \"9\": 0.35575,\n  \"9.5\": 0.406,\n  \"10\": 0.45625,\n  \"10.5\": 0.5065,\n  \"11\": 0.55675,\n  \"11.5\": 0.607,\n  \"12\": 0.65725,\n  \"12.5\": 0.7075,\n  \"13\": 0.75775,\n  \"13.5\": 0.808,\n  \"14\": 0.85825,\n  \"14.5\": 0.9085,\n  \"15\": 0.95875,\n  \"15.5\": 1.009,\n  \"16\": 1.05925,\n  \"16.5\": 1.1095,\n  \"17\": 1.15975,\n  \"17.5\": 1.21,\n  \"18\": 1.26025,\n  \"18.5\": 1.3105,\n  \"19\": 1.36075,\n  \"19.5\": 1.411,\n  \"20\": 1.46125,\n};\n\nexport const Z: Record<ZCoordKey, number> = {\n  \"0\": -0.302,\n  \"0.5\": -0.25175,\n  \"1\": -0.2015,\n  \"1.5\": -0.15125,\n  \"2\": -0.101,\n  \"2.5\": -0.05075,\n  \"3\": -0.0005,\n  \"3.5\": 0.04975,\n  \"4\": 0.1,\n  \"4.5\": 0.15025,\n  \"5\": 0.2005,\n  \"5.5\": 0.25075,\n  \"6\": 0.301,\n  \"6.5\": 0.35125,\n  \"7\": 0.4015,\n  \"7.5\": 0.45175,\n  \"8\": 0.502,\n  \"8.5\": 0.55225,\n  \"9\": 0.6025,\n  \"9.5\": 0.65275,\n  \"10\": 0.703,\n  \"10.5\": 0.75325,\n  \"11\": 0.8035,\n  \"11.5\": 0.85375,\n  \"12\": 0.904,\n  \"12.5\": 0.95425,\n  \"13\": 1.0045,\n  \"13.5\": 1.05475,\n  \"14\": 1.105,\n  \"14.5\": 1.15525,\n  \"15\": 1.2055,\n  \"15.5\": 1.25575,\n  \"16\": 1.306,\n}\n\nexport const getCoord = (x: XCoordKey, z: ZCoordKey) => {\n  return new THREE.Vector3(X[x], Y, Z[z])\n};","import * as THREE from \"three\";\nimport { MazePathPoint, PathPoint, CameraPathPoint } from \"../types/types\";\nimport { isMobile } from \"../config/config\";\nimport { getCoord, X, Y, Z } from \"./coordinates\";\n\nexport const objectHomeScrollEndPathPoint = new THREE.Vector3(\n  0.55675,\n  0.35,\n  0.45175\n);\n\nconst cameraPathPointsConfig = {\n  startMobile: new THREE.Vector3(0.5, 2.5, 2.5),\n  startDesktop: new THREE.Vector3(-2, 2.5, 2),\n  secondMobile: new THREE.Vector3(0.5, 2.5, 2),\n  secondDesktop: new THREE.Vector3(-1.5, 3, 0.75),\n  mobileLookAt: new THREE.Vector3(0.5, 0.5, -1.5),\n  desktopLookAt: new THREE.Vector3(-1.25, 0.5, 0.25),\n  cameraLookAtSecondDesktop: new THREE.Vector3(-0.75, 0.5, -0.75),\n  cameraLookAtSecondMobile: new THREE.Vector3(-0.75, 0.5, -0.75),\n\n  cameraHomeScrollEndLookAt: new THREE.Vector3(0.55675, -5, 0.35),\n  thirdPosition: new THREE.Vector3(0.55675, 3, 0.45175),\n\n  cameraHomeScrollEndPathPoint: new THREE.Vector3(0.55675, 0.5, 0.45175),\n};\n\nconst startPosition = isMobile\n  ? cameraPathPointsConfig.startMobile\n  : cameraPathPointsConfig.startDesktop;\nconst secondPosition = isMobile\n  ? cameraPathPointsConfig.secondMobile\n  : cameraPathPointsConfig.secondDesktop;\nconst lookAtPosition = isMobile\n  ? cameraPathPointsConfig.mobileLookAt\n  : cameraPathPointsConfig.desktopLookAt;\nconst cameraLookAtSecondPosition = isMobile\n  ? cameraPathPointsConfig.cameraLookAtSecondMobile\n  : cameraPathPointsConfig.cameraLookAtSecondDesktop;\n\nconst thirdPosition = cameraPathPointsConfig.thirdPosition;\nconst cameraHomeScrollEndLookAt =\n  cameraPathPointsConfig.cameraHomeScrollEndLookAt;\nconst cameraHomeScrollEndPathPoint =\n  cameraPathPointsConfig.cameraHomeScrollEndPathPoint;\n\nconst pacmanHomePathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"8\", \"9\"), type: \"straight\" },\n  {\n    pos: getCoord(\"8\", \"6\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"9\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"10\", \"4\"), type: \"straight\" },\n  {\n    pos: getCoord(\"10\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"9\", \"1\"), type: \"straight\" },\n  {\n    pos: getCoord(\"7\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"6\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"5\", \"3\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"4\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"3\", \"1\"),\n    type: \"straight\",\n    curveCheckPoints: [\n      getCoord(\"2\", \"1\"),\n      getCoord(\"1\", \"2\"),\n      getCoord(\"1\", \"2.5\"),\n      getCoord(\"1.5\", \"3\"),\n      getCoord(\"2\", \"3.5\"),\n    ],\n  },\n  {\n    pos: getCoord(\"2\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"3\", \"5\"), type: \"straight\" },\n  {\n    pos: getCoord(\"5\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"6\", \"6\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"5\", \"7\"), type: \"straight\" },\n  {\n    pos: getCoord(\"4\", \"7\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"3\", \"8\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"4\", \"9\"), type: \"straight\" },\n  {\n    pos: getCoord(\"5\", \"9\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"6\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"5\", \"11\"),\n    type: \"straight\",\n    curveCheckPoints: [\n      getCoord(\"3\", \"11\"),\n      getCoord(\"2\", \"12\"),\n      getCoord(\"1.5\", \"13\"),\n      getCoord(\"1\", \"14\"),\n      getCoord(\"2\", \"15\"),\n      getCoord(\"3\", \"15\"),\n      getCoord(\"4\", \"14\"),\n      getCoord(\"5\", \"13\"),\n    ],\n  },\n  {\n    pos: getCoord(\"6\", \"13\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"7\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"6\", \"15\"), type: \"straight\" },\n  {\n    pos: getCoord(\"5\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"4\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"5\", \"13\"),\n    type: \"straight\",\n    curveCheckPoints: [\n      getCoord(\"12\", \"13\"),\n      getCoord(\"13\", \"12\"),\n      getCoord(\"12.5\", \"11\"),\n      getCoord(\"12\", \"10.5\"),\n      getCoord(\"11\", \"10\"),\n      getCoord(\"10\", \"10.5\"),\n      getCoord(\"9\", \"11\"),\n      getCoord(\"8\", \"10\"),\n      getCoord(\"8\", \"9.5\"),\n    ],\n  },\n  {\n    pos: getCoord(\"8\", \"9\"),\n    type: \"straight\",\n  },\n];\n\nconst ghost1HomePathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"1\", \"10\"), type: \"straight\" },\n  {\n    pos: getCoord(\"1\", \"6\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"2\", \"5\"), type: \"straight\" },\n  {\n    pos: getCoord(\"3\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"4\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"5\", \"3\"), type: \"straight\" },\n  {\n    pos: getCoord(\"9\", \"3\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"10\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"9\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"8\", \"6\"),\n    type: \"straight\",\n    curveCheckPoints: [\n      getCoord(\"8\", \"10\"),\n      getCoord(\"9\", \"11\"),\n      getCoord(\"10\", \"10.5\"),\n      getCoord(\"11\", \"10\"),\n      getCoord(\"12\", \"10.5\"),\n      getCoord(\"13\", \"11\"),\n      getCoord(\"15\", \"11\"),\n      getCoord(\"16\", \"10.5\"),\n      getCoord(\"17\", \"10\"),\n      getCoord(\"18\", \"10.5\"),\n      getCoord(\"19\", \"11\"),\n      getCoord(\"20\", \"10\"),\n    ],\n  },\n  {\n    pos: getCoord(\"20\", \"6\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"19\", \"5\"), type: \"straight\" },\n  {\n    pos: getCoord(\"9\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"8\", \"6\"),\n    type: \"straight\",\n    curveCheckPoints: [\n      getCoord(\"8\", \"8\"),\n      getCoord(\"7\", \"9\"),\n      getCoord(\"6\", \"10\"),\n      getCoord(\"5.5\", \"11\"),\n      getCoord(\"5\", \"12\"),\n      getCoord(\"6\", \"13\"),\n      getCoord(\"7\", \"14\"),\n      getCoord(\"6\", \"15\"),\n      getCoord(\"5\", \"15\"),\n      getCoord(\"4\", \"14\"),\n      getCoord(\"4.5\", \"13\"),\n      getCoord(\"5\", \"12\"),\n      getCoord(\"4\", \"11\"),\n    ],\n  },\n  { pos: getCoord(\"1\", \"10\"), type: \"straight\" },\n];\n\nconst ghost2HomePathPoints: MazePathPoint[] = [\n  {\n    pos: getCoord(\"5\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n    curveCheckPoints: [getCoord(\"5.5\", \"11\")],\n  },\n  {\n    pos: getCoord(\"6\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"5\", \"9\"), type: \"straight\" },\n  {\n    pos: getCoord(\"4\", \"9\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"3\", \"8\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"4\", \"7\"), type: \"straight\" },\n  {\n    pos: getCoord(\"7\", \"7\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"8\", \"8\"), type: \"straight\" },\n  {\n    pos: getCoord(\"8\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n    curveCheckPoints: [getCoord(\"8.5\", \"11\"), getCoord(\"9\", \"12\")],\n  },\n  { pos: getCoord(\"10\", \"13\"), type: \"straight\" },\n  {\n    pos: getCoord(\"12\", \"13\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"13\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"14\", \"15\"), type: \"straight\" },\n  {\n    pos: getCoord(\"19\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"20\", \"14\"), type: \"straight\" },\n  {\n    pos: getCoord(\"20\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"19\", \"3\"), type: \"straight\" },\n  {\n    pos: getCoord(\"17\", \"3\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"16\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"15\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"14\", \"4\"), type: \"straight\" },\n  {\n    pos: getCoord(\"14\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"13\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n    curveCheckPoints: [getCoord(\"12\", \"1.5\")],\n  },\n  {\n    pos: getCoord(\"11\", \"2\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"10\", \"3\"), type: \"straight\" },\n  {\n    pos: getCoord(\"10\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"9\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"8\", \"6\"), type: \"straight\" },\n  {\n    pos: getCoord(\"8\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n    curveCheckPoints: [getCoord(\"8.5\", \"11\")],\n  },\n  {\n    pos: getCoord(\"9\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"8\", \"13\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"7\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"6\", \"15\"), type: \"straight\" },\n  {\n    pos: getCoord(\"5\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"4\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n    curveCheckPoints: [getCoord(\"4.5\", \"13\"), getCoord(\"5\", \"12\")],\n  },\n];\n\nconst ghost3HomePathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"14\", \"10.5\"), type: \"straight\" },\n  {\n    pos: getCoord(\"14\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"13\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n    curveCheckPoints: [\n      getCoord(\"12\", \"1.5\"),\n      getCoord(\"11\", \"2\"),\n      getCoord(\"10\", \"1.5\"),\n    ],\n  },\n  { pos: getCoord(\"9\", \"1\"), type: \"straight\" },\n  {\n    pos: getCoord(\"7\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"6\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"7\", \"3\"), type: \"straight\" },\n  {\n    pos: getCoord(\"9\", \"3\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"10\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"11\", \"5\"), type: \"straight\" },\n  {\n    pos: getCoord(\"19\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"20\", \"6\"), type: \"straight\" },\n  {\n    pos: getCoord(\"20\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"19\", \"11\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n    curveCheckPoints: [\n      getCoord(\"18\", \"10.5\"),\n      getCoord(\"17\", \"10\"),\n      getCoord(\"16\", \"10.5\"),\n      getCoord(\"15.5\", \"11\"),\n    ],\n  },\n  { pos: getCoord(\"15\", \"12\"), type: \"straight\" },\n  {\n    pos: getCoord(\"15\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"14\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"13\", \"14\"), type: \"straight\" },\n  {\n    pos: getCoord(\"13\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n    curveCheckPoints: [\n      getCoord(\"12.5\", \"11\"),\n      getCoord(\"12\", \"10.5\"),\n      getCoord(\"10\", \"10.5\"),\n    ],\n  },\n  {\n    pos: getCoord(\"9\", \"11\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"8\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"7\", \"9\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"6\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n    curveCheckPoints: [getCoord(\"5.5\", \"11\")],\n  },\n  {\n    pos: getCoord(\"5\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"6\", \"13\"), type: \"straight\" },\n  {\n    pos: getCoord(\"12\", \"13\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"13\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"13.5\", \"11\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"14\", \"10.5\"), type: \"straight\" },\n];\n\nconst ghost4HomePathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"16\", \"7\"), type: \"straight\" },\n  {\n    pos: getCoord(\"16\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"15\", \"11\"), type: \"straight\" },\n  {\n    pos: getCoord(\"14\", \"11\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"13\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"12\", \"13\"), type: \"straight\" },\n  {\n    pos: getCoord(\"8\", \"13\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"7\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"6\", \"15\"), type: \"straight\" },\n  {\n    pos: getCoord(\"2\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"1\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n    curveCheckPoints: [\n      getCoord(\"1.5\", \"13\"),\n      getCoord(\"2\", \"12\"),\n      getCoord(\"1.5\", \"11\"),\n    ],\n  },\n  { pos: getCoord(\"1\", \"10\"), type: \"straight\" },\n  {\n    pos: getCoord(\"1\", \"6\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"2\", \"5\"), type: \"straight\" },\n  {\n    pos: getCoord(\"5\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"6\", \"6\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"7\", \"7\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"8\", \"6\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"9\", \"5\"), type: \"straight\" },\n  {\n    pos: getCoord(\"13\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"14\", \"4\"), type: \"straight\" },\n  {\n    pos: getCoord(\"14\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"15\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"16\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"17\", \"3\"), type: \"straight\" },\n  {\n    pos: getCoord(\"19\", \"3\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"20\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"19\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"18\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"19\", \"3\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"20\", \"4\"), type: \"straight\" },\n  {\n    pos: getCoord(\"20\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"19\", \"11\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n    curveCheckPoints: [getCoord(\"18\", \"10.5\")],\n  },\n  {\n    pos: getCoord(\"17\", \"10\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"16\", \"9\"), type: \"straight\" },\n  { pos: getCoord(\"16\", \"7\"), type: \"straight\" },\n];\n\nconst ghost5HomePathPoints: MazePathPoint[] = [\n  {\n    pos: getCoord(\"10\", \"3.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"9\", \"3\"), type: \"straight\" },\n  {\n    pos: getCoord(\"5\", \"3\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"4\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"3\", \"1\"), type: \"straight\" },\n  {\n    pos: getCoord(\"2\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"1\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"1.5\", \"3\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"2\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"3\", \"5\"), type: \"straight\" },\n  {\n    pos: getCoord(\"5\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"6\", \"6\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"5\", \"7\"), type: \"straight\" },\n  {\n    pos: getCoord(\"4\", \"7\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"3\", \"8\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"4\", \"9\"), type: \"straight\" },\n  {\n    pos: getCoord(\"7\", \"9\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"8\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"8.5\", \"11\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"9\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"10\", \"13\"), type: \"straight\" },\n  {\n    pos: getCoord(\"12\", \"13\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"13\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"14\", \"11\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"15\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"15\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"16\", \"15\"), type: \"straight\" },\n  {\n    pos: getCoord(\"19\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"20\", \"14\"), type: \"straight\" },\n  {\n    pos: getCoord(\"20\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"19\", \"1\"), type: \"straight\" },\n  {\n    pos: getCoord(\"17\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"16\", \"2\"), type: \"straight\" },\n  {\n    pos: getCoord(\"16\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"15\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"14\", \"4\"), type: \"straight\" },\n  {\n    pos: getCoord(\"14\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"13\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"12\", \"1.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"11\", \"2\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"10\", \"3.5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n];\n\nconst cameraHomeScrollPathPoints: CameraPathPoint[] = [\n  { pos: startPosition, lookAt: lookAtPosition },\n  { pos: secondPosition, lookAt: cameraLookAtSecondPosition },\n  { pos: thirdPosition, lookAt: cameraHomeScrollEndLookAt },\n  { pos: cameraHomeScrollEndPathPoint, lookAt: cameraHomeScrollEndLookAt },\n];\n\nconst cameraPOVPathPoints: MazePathPoint[] = [\n  {\n    pos: new THREE.Vector3(X[\"11\"], 0.40625, Z[\"7.5\"]),\n    type: \"straight\",\n    lookAtSequence: [\n      new THREE.Vector3(X[\"11\"], 0.2, Z[\"8\"]),\n      new THREE.Vector3(X[\"11\"], 1.2, Z[\"16\"]),\n      new THREE.Vector3(X[\"11\"], 0.55, Z[\"16\"]),\n    ],\n  },\n  {\n    pos: getCoord(\"11\", \"7.5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"11\", \"9\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n    curveCheckPoints: [\n      new THREE.Vector3(X[\"11\"], Y, 0.6525),\n      getCoord(\"11.5\", \"10\"),\n      getCoord(\"12\", \"10.5\"),\n      getCoord(\"12.5\", \"11\"),\n    ],\n  },\n  {\n    pos: getCoord(\"13\", \"11\"),\n    type: \"straight\",\n  },\n  {\n    pos: getCoord(\"14.5\", \"11\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"15\", \"11.5\"),\n    type: \"straight\",\n  },\n  {\n    pos: getCoord(\"15\", \"14.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"14.5\", \"15\"),\n    type: \"straight\",\n  },\n  {\n    pos: getCoord(\"13.5\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"13\", \"14.5\"),\n    type: \"straight\",\n  },\n  {\n    pos: getCoord(\"13\", \"13.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"12.5\", \"13\"),\n    type: \"straight\",\n  },\n  {\n    pos: getCoord(\"7.5\", \"13\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"7\", \"13.5\"),\n    type: \"straight\",\n  },\n  {\n    pos: getCoord(\"7\", \"14.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"7.5\", \"15\"),\n    type: \"straight\",\n  },\n  {\n    pos: getCoord(\"10.5\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"11\", \"16\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n];\n\nconst ghost1POVPathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"16\", \"10\"), type: \"straight\" },\n  {\n    pos: getCoord(\"16\", \"10.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"15.5\", \"11\"), type: \"straight\" },\n  { pos: getCoord(\"14.5\", \"11\"), type: \"straight\" },\n];\n\nconst ghost2POVPathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"16\", \"15\"), type: \"straight\" },\n  {\n    pos: getCoord(\"15.5\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"15\", \"14.5\"), type: \"straight\" },\n  { pos: getCoord(\"15\", \"13.5\"), type: \"straight\" },\n];\n\nconst ghost3POVPathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"9\", \"12\"), type: \"straight\" },\n  {\n    pos: getCoord(\"9\", \"12.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"9.5\", \"13\"), type: \"straight\" },\n  { pos: getCoord(\"10.5\", \"13\"), type: \"straight\" },\n];\n\nconst ghost4POVPathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"7\", \"14\"), type: \"straight\" },\n  {\n    pos: getCoord(\"7\", \"13.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"7.5\", \"13\"), type: \"straight\" },\n  { pos: getCoord(\"8.5\", \"13\"), type: \"straight\" },\n];\n\nconst ghost5POVPathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"11\", \"16\"), type: \"straight\" },\n  {\n    pos: getCoord(\"11\", \"15.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"10.5\", \"15\"), type: \"straight\" },\n  { pos: getCoord(\"9.5\", \"15\"), type: \"straight\" },\n];\n\nexport const povTriggerPositions = {\n  ghost1: {\n    triggerPos: new THREE.Vector3(0.65725, 0.55, 0.75325),\n    ghostStartFadeIn: new THREE.Vector3(0.7075, 0.55, 0.8035),\n    ghostEndFadeIn: new THREE.Vector3(0.725, 0.55, 0.8035),\n    ghostStartFadeOut: new THREE.Vector3(0.75, 0.55, 0.8035),\n    camStartFadeIn: new THREE.Vector3(0.75775, 0.55, 0.8035),\n    camEndFadeIn: new THREE.Vector3(0.775, 0.55, 0.8035),\n    camStartFadeOut: new THREE.Vector3(0.84, 0.55, 0.8035),\n    endPosition: new THREE.Vector3(0.85825, 0.55, 0.8035),\n    forceEndProgress: {\n      start: 0.1,\n      end: 0.16,\n    },\n  },\n  ghost2: {\n    triggerPos: new THREE.Vector3(0.9085, 0.55, 0.8035),\n    ghostStartFadeIn: new THREE.Vector3(0.95875, 0.55, 0.85375),\n    ghostEndFadeIn: new THREE.Vector3(0.95875, 0.55, 0.875),\n    ghostStartFadeOut: new THREE.Vector3(0.95875, 0.55, 0.89),\n    camStartFadeIn: new THREE.Vector3(0.95875, 0.55, 0.904),\n    camEndFadeIn: new THREE.Vector3(0.95875, 0.55, 0.93),\n    camStartFadeOut: new THREE.Vector3(0.95875, 0.55, 0.9975),\n    endPosition: new THREE.Vector3(0.95875, 0.55, 1.0045),\n    forceEndProgress: {\n      start: 0.17,\n      end: 0.22,\n    },\n  },\n  ghost3: {\n    triggerPos: new THREE.Vector3(0.75775, 0.55, 1.05475),\n    ghostStartFadeIn: new THREE.Vector3(0.7075, 0.55, 1.0045),\n    ghostEndFadeIn: new THREE.Vector3(0.7075, 0.55, 1.0045),\n    ghostStartFadeOut: new THREE.Vector3(0.6825, 0.55, 1.0045),\n    camStartFadeIn: new THREE.Vector3(0.65725, 0.55, 1.0045),\n    camEndFadeIn: new THREE.Vector3(0.65725, 0.55, 1.0045),\n    camStartFadeOut: new THREE.Vector3(0.6065, 0.55, 1.0045),\n    endPosition: new THREE.Vector3(0.55675, 0.55, 1.0045),\n    forceEndProgress: {\n      start: 0.23,\n      end: 0.33,\n    },\n  },\n  ghost4: {\n    triggerPos: new THREE.Vector3(0.65725, 0.55, 1.0045),\n    ghostStartFadeIn: new THREE.Vector3(0.5565, 0.55, 1.0045),\n    ghostEndFadeIn: new THREE.Vector3(0.5065, 0.55, 1.0045),\n    ghostStartFadeOut: new THREE.Vector3(0.4815, 0.55, 1.0045),\n    camStartFadeIn: new THREE.Vector3(0.45625, 0.55, 1.0045),\n    camEndFadeIn: new THREE.Vector3(0.45625, 0.55, 1.0045),\n    camStartFadeOut: new THREE.Vector3(0.4065, 0.55, 1.0045),\n    endPosition: new THREE.Vector3(0.35575, 0.55, 1.0045),\n    forceEndProgress: {\n      start: 0.38,\n      end: 0.47,\n    },\n  },\n  ghost5: {\n    triggerPos: new THREE.Vector3(0.15475, 0.55, 1.15525),\n    ghostStartFadeIn: new THREE.Vector3(0.1795, 0.55, 1.18),\n    ghostEndFadeIn: new THREE.Vector3(0.205, 0.55, 1.2055),\n    ghostStartFadeOut: new THREE.Vector3(0.23025, 0.55, 1.2055),\n    camStartFadeIn: new THREE.Vector3(0.25525, 0.55, 1.2055),\n    camEndFadeIn: new THREE.Vector3(0.25525, 0.55, 1.2055),\n    camStartFadeOut: new THREE.Vector3(0.3055, 0.55, 1.2055),\n    endPosition: new THREE.Vector3(0.35575, 0.55, 1.2055),\n    forceEndProgress: {\n      start: 0.52,\n      end: 0.59,\n    },\n  },\n};\n\nexport function getStartPosition() {\n  return startPosition;\n}\n\nexport function getLookAtPosition() {\n  return lookAtPosition;\n}\n\nexport const homePaths = {\n  pacman: pacmanHomePathPoints,\n  ghost1: ghost1HomePathPoints,\n  ghost2: ghost2HomePathPoints,\n  ghost3: ghost3HomePathPoints,\n  ghost4: ghost4HomePathPoints,\n  ghost5: ghost5HomePathPoints,\n} as const;\n\nexport const povPaths = {\n  camera: cameraPOVPathPoints,\n  ghost1: ghost1POVPathPoints,\n  ghost2: ghost2POVPathPoints,\n  ghost3: ghost3POVPathPoints,\n  ghost4: ghost4POVPathPoints,\n  ghost5: ghost5POVPathPoints,\n} as const;\n\nexport function createHomeScrollPathPoints(\n  pausedPositions: Record<string, THREE.Vector3>\n): Record<string, PathPoint[]> {\n  const scrollPaths: Record<string, PathPoint[]> = {};\n\n  Object.entries(pausedPositions).forEach(([key, pausedPos]) => {\n    const arcPoint = new THREE.Vector3(\n      pausedPos.x * (1 / 4) + objectHomeScrollEndPathPoint.x * (3 / 4),\n      2,\n      pausedPos.z * (1 / 4) + objectHomeScrollEndPathPoint.z * (3 / 4)\n    );\n\n    scrollPaths[key] = [\n      { pos: pausedPos.clone() },\n      { pos: arcPoint },\n      { pos: objectHomeScrollEndPathPoint },\n    ];\n  });\n\n  return scrollPaths;\n}\n\nexport function getCameraHomeScrollPathPoints(): CameraPathPoint[] {\n  return cameraHomeScrollPathPoints;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import * as THREE from \"three\";\nimport gsap from \"gsap\";\nimport ScrollTrigger from \"gsap/ScrollTrigger\";\nimport { camera } from \"../core/camera\";\nimport { ghosts, pacmanMixer, pill } from \"../core/objects\";\nimport { clock, onFrame, scene } from \"../core/scene\";\nimport { getHomePaths, TangentSmoother } from \"../paths/paths\";\nimport { initHomeScrollAnimation } from \"./home-scroll\";\nimport { calculateObjectOrientation, OBJECT_KEYS } from \"./util\";\nimport { applyHomeLoopPreset } from \"./scene-presets\";\nimport {\n  SCALE,\n  TANGENT_SMOOTHING,\n  ROTATION_TRANSITION_DURATION,\n} from \"./constants\";\nimport { setObjectScale } from \"./scene-utils\";\nimport {\n  updateObjectPosition,\n  updateObjectRotation,\n  setHomeLoopActive,\n  updateHomeLoopT,\n  getHomeLoopStartRotations,\n  setHomeLoopStartT,\n  getHomeLoopStartT,\n} from \"./object-state\";\nimport { isCurrencySymbol } from \"./util\";\n\nconst LOOP_DURATION = 50;\nlet isHomeLoopActive = true;\nlet animationTime = 0;\nlet homeLoopFrameRegistered = false;\nlet rotationTransitionTime = 0;\nlet startRotations: Record<string, THREE.Quaternion> = {};\nlet hasBeenPausedBefore = false;\n\nconst homeLoopTangentSmoothers: Record<string, TangentSmoother> = {};\nlet pillGuides: THREE.Group | null = null;\n// Cache Object.entries to avoid recreating array every frame\nconst ghostEntries = Object.entries(ghosts);\n// Reusable temp objects to avoid allocations\nconst tempObject = new THREE.Object3D();\nconst tempQuaternion = new THREE.Quaternion();\n// Track last scale values to avoid unnecessary updates\nconst lastScales: Record<string, number> = {};\n\nfunction createPillPositionGuides(pillPos: THREE.Vector3) {\n  // Remove existing guides if they exist\n  if (pillGuides) {\n    scene.remove(pillGuides);\n    pillGuides = null;\n  }\n\n  pillGuides = new THREE.Group();\n  pillGuides.name = \"pillPositionGuides\";\n\n  const guideSize = 1.0; // Much larger for visibility\n\n  // Create axes helper (larger)\n  const axesHelper = new THREE.AxesHelper(guideSize);\n  axesHelper.position.copy(pillPos);\n  pillGuides.add(axesHelper);\n\n  // Create a large visible sphere at pill position\n  const sphereGeometry = new THREE.SphereGeometry(0.2, 16, 16);\n  const sphereMaterial = new THREE.MeshBasicMaterial({\n    color: 0xff0000,\n    transparent: true,\n    opacity: 0.7,\n    wireframe: true,\n  });\n  const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);\n  sphere.position.copy(pillPos);\n  pillGuides.add(sphere);\n\n  // Create a wireframe box to show the area (larger)\n  const boxGeometry = new THREE.BoxGeometry(guideSize, guideSize, guideSize);\n  const boxMaterial = new THREE.LineBasicMaterial({\n    color: 0x00ff00,\n    linewidth: 2,\n  });\n  const boxEdges = new THREE.EdgesGeometry(boxGeometry);\n  const boxWireframe = new THREE.LineSegments(boxEdges, boxMaterial);\n  boxWireframe.position.copy(pillPos);\n  pillGuides.add(boxWireframe);\n\n  // Create bright lines from origin to pill position\n  const lineMaterial = new THREE.LineBasicMaterial({\n    color: 0xffff00,\n    linewidth: 3,\n  });\n\n  // X-axis line (red)\n  const xLineGeometry = new THREE.BufferGeometry().setFromPoints([\n    new THREE.Vector3(0, pillPos.y, pillPos.z),\n    pillPos,\n  ]);\n  const xLine = new THREE.Line(\n    xLineGeometry,\n    new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 })\n  );\n  pillGuides.add(xLine);\n\n  // Y-axis line (green)\n  const yLineGeometry = new THREE.BufferGeometry().setFromPoints([\n    new THREE.Vector3(pillPos.x, 0, pillPos.z),\n    pillPos,\n  ]);\n  const yLine = new THREE.Line(\n    yLineGeometry,\n    new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2 })\n  );\n  pillGuides.add(yLine);\n\n  // Z-axis line (blue)\n  const zLineGeometry = new THREE.BufferGeometry().setFromPoints([\n    new THREE.Vector3(pillPos.x, pillPos.y, 0),\n    pillPos,\n  ]);\n  const zLine = new THREE.Line(\n    zLineGeometry,\n    new THREE.LineBasicMaterial({ color: 0x0000ff, linewidth: 2 })\n  );\n  pillGuides.add(zLine);\n\n  console.log(\"Pill guides created at position:\", pillPos);\n  scene.add(pillGuides);\n  console.log(\"Pill guides added to scene\");\n}\n\nfunction removePillPositionGuides() {\n  if (pillGuides) {\n    scene.remove(pillGuides);\n    pillGuides = null;\n  }\n}\n\nfunction initializeHomeLoopTangentSmoothers() {\n  const smoothingFactor = TANGENT_SMOOTHING.HOME_LOOP;\n  const initialVector = new THREE.Vector3(1, 0, 0);\n\n  OBJECT_KEYS.forEach((key) => {\n    homeLoopTangentSmoothers[key] = new TangentSmoother(\n      initialVector.clone(),\n      smoothingFactor\n    );\n  });\n}\n\nfunction stopHomeLoop() {\n  if (!isHomeLoopActive) return;\n  isHomeLoopActive = false;\n  setHomeLoopActive(false);\n  hasBeenPausedBefore = true;\n\n  const exactT = (animationTime % LOOP_DURATION) / LOOP_DURATION;\n  setHomeLoopStartT(exactT);\n\n  Object.entries(ghosts).forEach(([key, ghost]) => {\n    updateObjectPosition(key, ghost.position.clone(), true, true);\n    updateObjectRotation(key, ghost.quaternion.clone(), true);\n  });\n\n  initHomeScrollAnimation();\n}\n\nexport function startHomeLoop() {\n  isHomeLoopActive = true;\n  setHomeLoopActive(true);\n\n  const homePaths = getHomePaths();\n  const homeLoopStartRot = getHomeLoopStartRotations();\n  const savedT = getHomeLoopStartT();\n\n  if (hasBeenPausedBefore && savedT !== null) {\n    animationTime = savedT * LOOP_DURATION;\n  }\n\n  rotationTransitionTime = 0;\n  startRotations = {};\n\n  // Smooth camera transition to home loop start position\n  const { getStartPosition, getLookAtPosition } = require(\"../paths/pathpoints\");\n  const targetCameraPos = getStartPosition();\n  const currentCameraPos = camera.position.clone();\n  const cameraDistance = currentCameraPos.distanceTo(targetCameraPos);\n\n  // Check if we're coming from home-scroll\n  const homeScrollTrigger = ScrollTrigger.getById(\"homeScroll\");\n  const wasInHomeScroll = homeScrollTrigger && homeScrollTrigger.progress > 0;\n\n  // Always transition if distance is significant\n  if (cameraDistance > 0.1) {\n    gsap.killTweensOf(camera.position);\n    \n    // Use longer transition when coming from home-scroll\n    const transitionDuration = wasInHomeScroll ? 1.0 : 0.5;\n    \n    gsap.to(camera.position, {\n      x: targetCameraPos.x,\n      y: targetCameraPos.y,\n      z: targetCameraPos.z,\n      duration: transitionDuration,\n      ease: \"power2.out\",\n      onUpdate: () => {\n        camera.updateProjectionMatrix();\n      },\n    });\n\n    // Also transition lookAt\n    const targetLookAt = getLookAtPosition();\n    const lookAtProps = { t: 0 };\n    const startLookAt = new THREE.Vector3();\n    camera.getWorldDirection(startLookAt);\n    startLookAt.multiplyScalar(10).add(currentCameraPos);\n\n    gsap.to(lookAtProps, {\n      t: 1,\n      duration: transitionDuration,\n      ease: \"power2.out\",\n      onUpdate: () => {\n        const currentLookAt = startLookAt\n          .clone()\n          .lerp(targetLookAt, lookAtProps.t);\n        camera.lookAt(currentLookAt);\n        camera.updateProjectionMatrix();\n      },\n    });\n  } else {\n    // If already close, just set directly\n    camera.position.copy(targetCameraPos);\n    const targetLookAt = getLookAtPosition();\n    camera.lookAt(targetLookAt);\n    camera.updateProjectionMatrix();\n  }\n\n  applyHomeLoopPreset(true);\n\n  initializeHomeLoopTangentSmoothers();\n\n  Object.entries(ghosts).forEach(([key, ghost]) => {\n    const path = homePaths[key];\n    if (path) {\n      if (hasBeenPausedBefore && savedT !== null) {\n        const targetPosition = path.getPointAt(savedT);\n        if (targetPosition) {\n          // Get current position BEFORE any changes to avoid first frame jump\n          const currentPosition = ghost.position.clone();\n          const distance = currentPosition.distanceTo(targetPosition);\n\n          // Check if we're transitioning from home-scroll\n          const homeScrollTrigger = ScrollTrigger.getById(\"homeScroll\");\n          const isTransitioningFromHomeScroll =\n            homeScrollTrigger && homeScrollTrigger.isActive;\n\n          // Always use smooth transition when coming from home-scroll or if distance is significant\n          if (distance > 0.001 || isTransitioningFromHomeScroll) {\n            // Kill any existing position animations\n            gsap.killTweensOf(ghost.position);\n\n            // IMPORTANT: Set initial position to current to prevent first frame jump\n            ghost.position.copy(currentPosition);\n\n            // Smooth transition to target position\n            // Use longer duration when transitioning from scroll for smoother effect\n            gsap.to(ghost.position, {\n              x: targetPosition.x,\n              y: targetPosition.y,\n              z: targetPosition.z,\n              duration: isTransitioningFromHomeScroll ? 0.8 : 0.5,\n              ease: \"power2.out\",\n              onUpdate: () => {\n                updateObjectPosition(key, ghost.position);\n              },\n              onComplete: () => {\n                updateObjectPosition(key, targetPosition);\n              },\n            });\n          } else {\n            // If very close and not transitioning, just set directly\n            ghost.position.copy(targetPosition);\n            updateObjectPosition(key, targetPosition);\n          }\n        }\n      }\n\n      const savedRotation = homeLoopStartRot[key];\n\n      if (savedRotation) {\n        // Smooth rotation transition\n        const currentQuat = ghost.quaternion.clone();\n        const angle = currentQuat.angleTo(savedRotation);\n\n        // Only animate if there's a significant rotation difference\n        if (angle > 0.01) {\n          gsap.killTweensOf(ghost.quaternion);\n\n          // Create a temporary object to animate quaternion\n          const quatProps = { t: 0 };\n          gsap.to(quatProps, {\n            t: 1,\n            duration: 0.5,\n            ease: \"power2.out\",\n            onUpdate: () => {\n              ghost.quaternion\n                .copy(currentQuat)\n                .slerp(savedRotation, quatProps.t);\n              updateObjectRotation(key, ghost.quaternion);\n            },\n            onComplete: () => {\n              ghost.quaternion.copy(savedRotation);\n              updateObjectRotation(key, savedRotation);\n              if (hasBeenPausedBefore) {\n                startRotations[key] = savedRotation.clone();\n              }\n            },\n          });\n        } else {\n          ghost.quaternion.copy(savedRotation);\n          updateObjectRotation(key, savedRotation);\n          if (hasBeenPausedBefore) {\n            startRotations[key] = savedRotation.clone();\n          }\n        }\n      } else {\n        updateObjectRotation(key, ghost.quaternion);\n        if (hasBeenPausedBefore) {\n          startRotations[key] = ghost.quaternion.clone();\n        }\n      }\n\n      if (key !== \"pacman\") {\n        ghost.visible = true;\n      }\n      setObjectScale(ghost, key, \"home\");\n\n      if (homeLoopTangentSmoothers[key] && savedT !== null) {\n        const initialTangent = path.getTangentAt(savedT);\n        if (initialTangent) {\n          homeLoopTangentSmoothers[key].reset(initialTangent);\n        }\n      }\n    }\n  });\n\n  if (!homeLoopFrameRegistered) {\n    let lastTime = clock.getElapsedTime();\n    onFrame(() => {\n      if (document.hidden) {\n        lastTime = clock.getElapsedTime();\n        return;\n      }\n\n      const currentTime = clock.getElapsedTime();\n      const delta = currentTime - lastTime;\n      lastTime = currentTime;\n\n      updateHomeLoop(delta);\n    });\n    homeLoopFrameRegistered = true;\n  }\n}\n\nfunction updateHomeLoop(delta: number) {\n  if (!isHomeLoopActive) return;\n\n  const introScrollTrigger = ScrollTrigger.getById(\"introScroll\");\n  if (introScrollTrigger?.isActive) return;\n  \n  // Don't update if home-scroll is active (to prevent rotation conflicts)\n  const homeScrollTrigger = ScrollTrigger.getById(\"homeScroll\");\n  if (homeScrollTrigger?.isActive) return;\n\n  const maxDelta = 0.1;\n  const clampedDelta = Math.min(delta, maxDelta);\n\n  animationTime += clampedDelta;\n  rotationTransitionTime += clampedDelta;\n\n  const t = (animationTime % LOOP_DURATION) / LOOP_DURATION;\n\n  updateHomeLoopT(t, animationTime);\n\n  const homePaths = getHomePaths();\n  if (pacmanMixer) {\n    pacmanMixer.update(delta);\n  }\n\n  const transitionProgress = Math.min(\n    rotationTransitionTime / ROTATION_TRANSITION_DURATION,\n    1\n  );\n  const isTransitioning = hasBeenPausedBefore && transitionProgress < 1;\n\n  // Use cached entries instead of Object.entries() every frame\n  for (let i = 0; i < ghostEntries.length; i++) {\n    const [key, ghost] = ghostEntries[i];\n    const path = homePaths[key];\n    if (path) {\n      const objectT = t;\n\n      const position = path.getPointAt(objectT);\n      if (position) {\n        ghost.position.copy(position);\n        updateObjectPosition(key, position);\n      }\n\n      // Only update scale if it changed\n      const expectedScale =\n        key === \"pacman\" ? SCALE.PACMAN_HOME : SCALE.GHOST_NORMAL;\n      if (lastScales[key] !== expectedScale) {\n        setObjectScale(ghost, key, \"home\");\n        lastScales[key] = expectedScale;\n      }\n\n      // Reuse tempQuaternion instead of creating new one\n      tempQuaternion.set(0, 0, 0, 1);\n      if (homeLoopTangentSmoothers[key] && objectT > 0) {\n        const rawTangent = path.getTangentAt(objectT);\n        if (rawTangent && rawTangent.length() > 0) {\n          const smoothTangent =\n            homeLoopTangentSmoothers[key].update(rawTangent);\n          const objectType = key === \"pacman\" ? \"pacman\" : \"ghost\";\n\n          // Reuse tempObject instead of creating new one\n          calculateObjectOrientation(tempObject, smoothTangent, objectType);\n          tempQuaternion.copy(tempObject.quaternion);\n        }\n      }\n\n      if (isTransitioning && startRotations[key]) {\n        const easedProgress =\n          transitionProgress *\n          transitionProgress *\n          (3 - 2 * transitionProgress);\n        // Use tempQuaternion for slerp result instead of cloning\n        const slerpResult = startRotations[key]\n          .clone()\n          .slerp(tempQuaternion, easedProgress);\n        ghost.quaternion.copy(slerpResult);\n      } else {\n        ghost.quaternion.copy(tempQuaternion);\n      }\n\n      updateObjectRotation(key, ghost.quaternion);\n    }\n  }\n}\n\nexport function homeLoopHandler() {\n  if (window.scrollY === 0) {\n    startHomeLoop();\n  }\n}\n\nexport function setupHomeLoopScrollHandler() {\n  window.addEventListener(\"scroll\", () => {\n    if (window.scrollY === 0) {\n      if (!isHomeLoopActive) {\n        startHomeLoop();\n      }\n    } else {\n      if (isHomeLoopActive) {\n        stopHomeLoop();\n      }\n    }\n  });\n}\n","import gsap from \"gsap\";\nimport ScrollTrigger from \"gsap/ScrollTrigger\";\nimport * as THREE from \"three\";\nimport { camera } from \"../core/camera\";\nimport { ghosts } from \"../core/objects\";\nimport { getPovPaths, TangentSmoother } from \"../paths/paths\";\nimport {\n  povTriggerPositions,\n  povPaths as pathPointsData,\n} from \"../paths/pathpoints\";\nimport { DOM_ELEMENTS } from \"../config/dom-elements\";\nimport { calculateObjectOrientation } from \"./util\";\nimport { applyPovScrollPreset, getScrollDirection } from \"./scene-presets\";\nimport {\n  SCALE,\n  TANGENT_SMOOTHING,\n  PARAMETER_SMOOTHING_FACTOR,\n  GHOST_FADE_THRESHOLD,\n  GHOST_FADE_OUT_DURATION,\n  FIND_CLOSEST_SAMPLES,\n  SCRUB_DURATION,\n  POV_SEQUENCE_PHASE_END,\n  POV_TRANSITION_PHASE_END,\n  POV_Y_CONSTRAINT_THRESHOLD,\n  OPACITY_VISIBILITY_THRESHOLD,\n  clamp,\n} from \"./constants\";\nimport { setObjectScale } from \"./scene-utils\";\nimport { setObjectOpacity } from \"../core/material-utils\";\n\nconst domElementCache: Record<\n  number,\n  {\n    parent: HTMLElement | null;\n    povElements: NodeListOf<Element>;\n    camElements: NodeListOf<Element>;\n  }\n> = {};\n\ngsap.registerPlugin(ScrollTrigger);\n\nlet povScrollTimeline: gsap.core.Timeline | null = null;\n\nlet previousCameraPosition: THREE.Vector3 | null = null;\nlet rotationStarted = false;\nlet startedInitEndScreen = false;\n\nconst startRotationPoint = new THREE.Vector3(0.55675, 0.55, 1.306);\nconst endRotationPoint = new THREE.Vector3(-0.14675, 1, 1.8085);\n\nconst wideFOV = 80;\n\nlet cachedStartYAngle: number | null = null;\n\nconst ghostStates: Record<string, any> = {};\n\nconst povTangentSmoothers: Record<string, TangentSmoother> = {};\n\nfunction getCustomLookAtForProgress(\n  progress: number,\n  povPaths: Record<string, THREE.CurvePath<THREE.Vector3>>\n): THREE.Vector3 | null {\n  const cameraPathPoints = pathPointsData.camera;\n\n  if (progress <= POV_SEQUENCE_PHASE_END) {\n    const firstPoint = cameraPathPoints[0];\n\n    if (\"lookAtSequence\" in firstPoint && firstPoint.lookAtSequence?.length) {\n      const sequenceProgress = progress / POV_SEQUENCE_PHASE_END;\n      const sequenceLength = firstPoint.lookAtSequence.length;\n\n      const segmentSize = 1 / sequenceLength;\n      const currentSegment = Math.floor(sequenceProgress / segmentSize);\n      const segmentProgress = (sequenceProgress % segmentSize) / segmentSize;\n\n      const fromIndex = Math.min(currentSegment, sequenceLength - 1);\n      const toIndex = Math.min(currentSegment + 1, sequenceLength - 1);\n\n      if (fromIndex === toIndex) {\n        return firstPoint.lookAtSequence[fromIndex];\n      } else {\n        const fromTarget = firstPoint.lookAtSequence[fromIndex];\n        const toTarget = firstPoint.lookAtSequence[toIndex];\n        return fromTarget.clone().lerp(toTarget, segmentProgress);\n      }\n    }\n  } else if (progress <= POV_TRANSITION_PHASE_END) {\n    const firstPoint = cameraPathPoints[0];\n\n    if (\"lookAtSequence\" in firstPoint && firstPoint.lookAtSequence?.length) {\n      const finalSequenceLookAt =\n        firstPoint.lookAtSequence[firstPoint.lookAtSequence.length - 1];\n\n      const position = povPaths.camera.getPointAt(progress);\n      const tangent = povPaths.camera.getTangentAt(progress).normalize();\n\n      const constrainedTangent = new THREE.Vector3(\n        tangent.x,\n        0,\n        tangent.z\n      ).normalize();\n      const defaultLookAt = position.clone().add(constrainedTangent);\n\n      const transitionProgress =\n        (progress - POV_SEQUENCE_PHASE_END) /\n        (POV_TRANSITION_PHASE_END - POV_SEQUENCE_PHASE_END);\n\n      return finalSequenceLookAt\n        .clone()\n        .lerp(defaultLookAt, transitionProgress);\n    }\n  }\n\n  return null;\n}\n\nfunction initializePovTangentSmoothers() {\n  const smoothingFactor = TANGENT_SMOOTHING.POV;\n\n  povTangentSmoothers.camera = new TangentSmoother(\n    new THREE.Vector3(0, 0, -1),\n    smoothingFactor\n  );\n\n  for (let i = 1; i <= 5; i++) {\n    povTangentSmoothers[`ghost${i}`] = new TangentSmoother(\n      new THREE.Vector3(1, 0, 0),\n      smoothingFactor\n    );\n  }\n}\n\nexport function initPovScrollAnimation() {\n  if (povScrollTimeline) {\n    povScrollTimeline.kill();\n    povScrollTimeline = null;\n  }\n\n  initializePovTangentSmoothers();\n\n  Object.keys(povTriggerPositions).forEach((key) => {\n    ghostStates[key] = {\n      hasBeenTriggered: false,\n      triggerCameraProgress: null,\n      ghostStartFadeInProgress: null,\n      ghostEndFadeInProgress: null,\n      ghostStartFadeOutProgress: null,\n      camStartFadeInProgress: null,\n      camEndFadeInProgress: null,\n      camStartFadeOutProgress: null,\n      endCameraProgress: null,\n      currentPathT: 0,\n    };\n  });\n\n  povScrollTimeline = gsap\n    .timeline({\n      scrollTrigger: {\n        id: \"povScroll\",\n        trigger: DOM_ELEMENTS.povSection,\n        start: \"top bottom\",\n        end: \"bottom top\",\n        markers: false,\n        scrub: SCRUB_DURATION,\n        toggleActions: \"play none none reverse\",\n        onEnter: () => {\n          const scrollDir = getScrollDirection();\n          applyPovScrollPreset(true, scrollDir);\n        },\n        onEnterBack: () => {\n          const scrollDir = getScrollDirection();\n          applyPovScrollPreset(true, scrollDir);\n        },\n      },\n    })\n    .addLabel(\"pov-animation-start\", 0)\n    .to(\n      { progress: 0 },\n      {\n        progress: 1,\n        immediateRender: false,\n        onStart: handleAnimationStart,\n        onUpdate: function (this: gsap.core.Tween) {\n          handleAnimationUpdate.call(this);\n        },\n        onReverseComplete: () => {\n          handleLeavePOV();\n          resetState();\n        },\n        onComplete: () => {\n          handleLeavePOV();\n          resetState();\n        },\n      }\n    )\n    .addLabel(\"pov-animation-sequence-phase\", POV_SEQUENCE_PHASE_END)\n    .addLabel(\"pov-animation-transition-phase\", POV_TRANSITION_PHASE_END)\n    .addLabel(\"pov-animation-end\", 1);\n}\n\nfunction handleAnimationStart() {\n  const povPaths = getPovPaths();\n\n  if (povTangentSmoothers.camera && povPaths.camera) {\n    const initialCameraTangent = povPaths.camera.getTangentAt(0);\n    if (initialCameraTangent) {\n      povTangentSmoothers.camera.reset(initialCameraTangent);\n    }\n  }\n\n  Object.entries(ghosts).forEach(([key, ghost]) => {\n    if (povPaths[key] && key !== \"pacman\") {\n      const position = povPaths[key].getPointAt(0);\n      ghost.position.copy(position);\n      const tangent = povPaths[key].getTangentAt(0).normalize();\n      ghost.lookAt(position.clone().add(tangent));\n      ghost.visible = false;\n      setObjectScale(ghost, key, \"pov\");\n    }\n  });\n\n  if (ghosts.pacman) {\n    ghosts.pacman.visible = false;\n  }\n}\n\nfunction handleAnimationUpdate(this: gsap.core.Tween) {\n  const overallProgress = (this.targets()[0] as any).progress;\n\n  const povPaths = getPovPaths();\n\n  if (!povPaths.camera) return;\n\n  const cameraPosition = povPaths.camera.getPointAt(overallProgress);\n\n  if (previousCameraPosition) {\n    updateCamera(overallProgress, povPaths, cameraPosition);\n    updateGhosts(cameraPosition, overallProgress, povPaths);\n    previousCameraPosition.copy(cameraPosition);\n  } else {\n    previousCameraPosition = cameraPosition.clone();\n  }\n}\n\nfunction updateCamera(\n  progress: number,\n  povPaths: Record<string, THREE.CurvePath<THREE.Vector3>>,\n  position: THREE.Vector3\n) {\n  const introScrollTrigger = ScrollTrigger.getById(\"introScroll\");\n  const isIntroScrollActive = introScrollTrigger && introScrollTrigger.isActive;\n\n  if (isIntroScrollActive) {\n    return;\n  }\n\n  camera.position.copy(position);\n  camera.fov = wideFOV;\n\n  const customLookAt = getCustomLookAtForProgress(progress, povPaths);\n  if (customLookAt) {\n    camera.lookAt(customLookAt);\n    camera.updateProjectionMatrix();\n    return;\n  }\n\n  const rawTangent = povPaths.camera.getTangentAt(progress).normalize();\n  let smoothTangent = rawTangent;\n\n  if (povTangentSmoothers.camera && progress > 0) {\n    smoothTangent = povTangentSmoothers.camera.update(rawTangent);\n  }\n\n  if (progress <= POV_Y_CONSTRAINT_THRESHOLD) {\n    smoothTangent = new THREE.Vector3(\n      smoothTangent.x,\n      0,\n      smoothTangent.z\n    ).normalize();\n  }\n\n  const defaultLookAt = position.clone().add(smoothTangent);\n  handleDefaultOrientation(progress, defaultLookAt);\n\n  camera.updateProjectionMatrix();\n}\n\nfunction handleDefaultOrientation(\n  progress: number,\n  defaultLookAt: THREE.Vector3\n) {\n  const povPaths = getPovPaths();\n  const startRotationProgress = findClosestProgressOnPath(\n    povPaths.camera,\n    startRotationPoint\n  );\n  const endRotationProgress = findClosestProgressOnPath(\n    povPaths.camera,\n    endRotationPoint\n  );\n\n  if (\n    (progress < startRotationProgress || progress > endRotationProgress) &&\n    !startedInitEndScreen\n  ) {\n    cachedStartYAngle = null;\n    rotationStarted = false;\n    startedInitEndScreen = false;\n  }\n\n  if (!rotationStarted && !startedInitEndScreen) {\n    camera.lookAt(defaultLookAt);\n  }\n}\n\nfunction updateGhosts(\n  cameraPosition: THREE.Vector3,\n  overallProgress: number,\n  povPaths: Record<string, THREE.CurvePath<THREE.Vector3>>\n) {\n  Object.entries(povTriggerPositions).forEach(([key, triggerData]) => {\n    const ghost = ghosts[key];\n    const path = povPaths[key];\n\n    if (!ghost || !path || key === \"pacman\") return;\n    const forceEndProgress =\n      overallProgress > triggerData.forceEndProgress.start &&\n      overallProgress < triggerData.forceEndProgress.end;\n\n    updateGhost(\n      key,\n      ghost,\n      path,\n      cameraPosition,\n      triggerData,\n      forceEndProgress\n    );\n  });\n}\n\nfunction updateGhost(\n  key: string,\n  ghost: THREE.Object3D,\n  path: THREE.CurvePath<THREE.Vector3>,\n  cameraPosition: THREE.Vector3,\n  triggerData: any,\n  forceEndProgress: boolean\n) {\n  const {\n    triggerPos,\n    ghostStartFadeIn,\n    ghostEndFadeIn,\n    ghostStartFadeOut,\n    camStartFadeIn,\n    camEndFadeIn,\n    camStartFadeOut,\n    endPosition,\n  } = triggerData;\n  const state = ghostStates[key];\n\n  const ghostIndex = parseInt(key.replace(\"ghost\", \"\")) - 1;\n  let cached = domElementCache[ghostIndex];\n\n  if (!cached) {\n    const parentElements = document.querySelectorAll(\".cmp--pov.cmp\");\n    const parent = parentElements[ghostIndex] as HTMLElement;\n    cached = {\n      parent: parent || null,\n      povElements: parent\n        ? parent.querySelectorAll(\".pov\")\n        : (document.querySelectorAll(\".nonexistent\") as NodeListOf<Element>),\n      camElements: parent\n        ? parent.querySelectorAll(\".cam\")\n        : (document.querySelectorAll(\".nonexistent\") as NodeListOf<Element>),\n    };\n    domElementCache[ghostIndex] = cached;\n  }\n\n  const { parent, povElements, camElements } = cached;\n  if (!parent || !povElements.length || !camElements.length) return;\n\n  const povPaths = getPovPaths();\n  if (state.triggerCameraProgress === null) {\n    state.triggerCameraProgress = findClosestProgressOnPath(\n      povPaths.camera,\n      triggerPos,\n      FIND_CLOSEST_SAMPLES\n    );\n    state.ghostStartFadeInProgress = findClosestProgressOnPath(\n      povPaths.camera,\n      ghostStartFadeIn,\n      FIND_CLOSEST_SAMPLES\n    );\n    state.ghostEndFadeInProgress = findClosestProgressOnPath(\n      povPaths.camera,\n      ghostEndFadeIn,\n      FIND_CLOSEST_SAMPLES\n    );\n    state.ghostStartFadeOutProgress = findClosestProgressOnPath(\n      povPaths.camera,\n      ghostStartFadeOut,\n      FIND_CLOSEST_SAMPLES\n    );\n    state.camStartFadeInProgress = findClosestProgressOnPath(\n      povPaths.camera,\n      camStartFadeIn,\n      FIND_CLOSEST_SAMPLES\n    );\n    state.camEndFadeInProgress = findClosestProgressOnPath(\n      povPaths.camera,\n      camEndFadeIn,\n      FIND_CLOSEST_SAMPLES\n    );\n    state.camStartFadeOutProgress = findClosestProgressOnPath(\n      povPaths.camera,\n      camStartFadeOut,\n      FIND_CLOSEST_SAMPLES\n    );\n    state.endCameraProgress = findClosestProgressOnPath(\n      povPaths.camera,\n      endPosition,\n      FIND_CLOSEST_SAMPLES\n    );\n  }\n\n  const currentCameraProgress = findClosestProgressOnPath(\n    povPaths.camera,\n    cameraPosition,\n    FIND_CLOSEST_SAMPLES\n  );\n\n  if (\n    currentCameraProgress >= state.triggerCameraProgress &&\n    currentCameraProgress <= state.endCameraProgress\n  ) {\n    if (!ghost.visible) {\n      ghost.visible = true;\n      state.hasBeenTriggered = true;\n\n      if (povTangentSmoothers[key]) {\n        const initialTangent = path.getTangentAt(0);\n        if (initialTangent) {\n          povTangentSmoothers[key].reset(initialTangent);\n        }\n      }\n    }\n\n    const normalizedProgress =\n      (currentCameraProgress - state.triggerCameraProgress) /\n      (state.endCameraProgress - state.triggerCameraProgress);\n    let ghostProgress = clamp(normalizedProgress);\n\n    if (state.currentPathT === undefined) {\n      state.currentPathT = ghostProgress;\n    } else {\n      state.currentPathT +=\n        (ghostProgress - state.currentPathT) * PARAMETER_SMOOTHING_FACTOR;\n    }\n\n    ghostProgress = state.currentPathT;\n\n    const pathPoint = path.getPointAt(ghostProgress);\n    ghost.position.copy(pathPoint);\n\n    if (povTangentSmoothers[key] && ghostProgress > 0) {\n      const rawTangent = path.getTangentAt(ghostProgress);\n      if (rawTangent && rawTangent.length() > 0) {\n        const smoothTangent = povTangentSmoothers[key].update(rawTangent);\n        calculateObjectOrientation(ghost, smoothTangent, \"ghost\");\n      }\n    }\n\n    const targetOpacity =\n      ghostProgress > GHOST_FADE_THRESHOLD\n        ? 1 - (ghostProgress - GHOST_FADE_THRESHOLD) / GHOST_FADE_OUT_DURATION\n        : 1.0;\n    setObjectOpacity(ghost, targetOpacity, {\n      preserveTransmission: true,\n      skipCurrencySymbols: true,\n    });\n  } else {\n    ghost.visible = false;\n    state.hasBeenTriggered = false;\n  }\n\n  updateTextVisibility(\n    key,\n    currentCameraProgress,\n    state,\n    parent,\n    povElements,\n    camElements,\n    forceEndProgress\n  );\n}\n\nfunction calculateTextOpacities(\n  currentCameraProgress: number,\n  state: any\n): { targetGhostOpacity: number; targetCamOpacity: number } {\n  let targetGhostOpacity = 0;\n  let targetCamOpacity = 0;\n\n  if (\n    currentCameraProgress >= state.ghostStartFadeInProgress &&\n    currentCameraProgress <= state.ghostEndFadeInProgress\n  ) {\n    const fadeProgress =\n      (currentCameraProgress - state.ghostStartFadeInProgress) /\n      (state.ghostEndFadeInProgress - state.ghostStartFadeInProgress);\n    targetGhostOpacity = Math.min(1, fadeProgress);\n  } else if (\n    currentCameraProgress > state.ghostEndFadeInProgress &&\n    currentCameraProgress < state.ghostStartFadeOutProgress\n  ) {\n    targetGhostOpacity = 1;\n  } else if (\n    currentCameraProgress >= state.ghostStartFadeOutProgress &&\n    currentCameraProgress <= state.camStartFadeInProgress\n  ) {\n    const fadeOutProgress =\n      (currentCameraProgress - state.ghostStartFadeOutProgress) /\n      (state.camStartFadeInProgress - state.ghostStartFadeOutProgress);\n    targetGhostOpacity = Math.max(0, 1 - fadeOutProgress);\n  }\n\n  if (\n    currentCameraProgress >= state.camStartFadeInProgress &&\n    currentCameraProgress <= state.camEndFadeInProgress\n  ) {\n    const fadeProgress =\n      (currentCameraProgress - state.camStartFadeInProgress) /\n      (state.camEndFadeInProgress - state.camStartFadeInProgress);\n    targetCamOpacity = Math.min(1, fadeProgress);\n  } else if (\n    currentCameraProgress > state.camEndFadeInProgress &&\n    currentCameraProgress < state.camStartFadeOutProgress\n  ) {\n    targetCamOpacity = 1;\n  } else if (\n    currentCameraProgress >= state.camStartFadeOutProgress &&\n    currentCameraProgress <= state.endCameraProgress\n  ) {\n    const fadeOutProgress =\n      (currentCameraProgress - state.camStartFadeOutProgress) /\n      (state.endCameraProgress - state.camStartFadeOutProgress);\n    targetCamOpacity = Math.max(0, 1 - fadeOutProgress);\n  }\n\n  return { targetGhostOpacity, targetCamOpacity };\n}\n\nfunction updateTextElementVisibility(\n  elements: NodeListOf<Element>,\n  targetOpacity: number\n): void {\n  elements.forEach((element) => {\n    const el = element as HTMLElement;\n    if (targetOpacity > OPACITY_VISIBILITY_THRESHOLD) {\n      el.classList.remove(\"no-visibility\");\n      el.style.opacity = targetOpacity.toString();\n    } else if (\n      targetOpacity <= OPACITY_VISIBILITY_THRESHOLD &&\n      !el.classList.contains(\"no-visibility\")\n    ) {\n      el.classList.add(\"no-visibility\");\n      el.style.opacity = \"0\";\n    }\n  });\n}\n\nfunction updateTextVisibility(\n  key: string,\n  currentCameraProgress: number,\n  state: any,\n  parent: HTMLElement,\n  povElements: NodeListOf<Element>,\n  camElements: NodeListOf<Element>,\n  forceEndProgress: boolean = false\n) {\n  if (forceEndProgress) {\n    parent.style.opacity = \"0\";\n    parent.classList.add(\"no-visibility\");\n    hideTextElements(povElements);\n    hideTextElements(camElements);\n    return;\n  }\n\n  const { targetGhostOpacity, targetCamOpacity } = calculateTextOpacities(\n    currentCameraProgress,\n    state\n  );\n\n  if (currentCameraProgress >= state.camStartFadeOutProgress) {\n    parent.style.opacity = targetCamOpacity.toString();\n  } else if (\n    currentCameraProgress >= state.ghostStartFadeInProgress &&\n    currentCameraProgress <= state.ghostEndFadeInProgress\n  ) {\n    parent.style.opacity = targetGhostOpacity.toString();\n  }\n\n  const isPassed =\n    targetCamOpacity > OPACITY_VISIBILITY_THRESHOLD &&\n    targetGhostOpacity > OPACITY_VISIBILITY_THRESHOLD;\n  const hasNoVisibility = parent.classList.contains(\"no-visibility\");\n\n  if (isPassed && !hasNoVisibility) {\n    parent.classList.add(\"no-visibility\");\n  } else if (!isPassed && hasNoVisibility) {\n    parent.classList.remove(\"no-visibility\");\n  }\n\n  if (targetGhostOpacity > OPACITY_VISIBILITY_THRESHOLD) {\n    updateTextElementVisibility(povElements, targetGhostOpacity);\n  } else {\n    hideTextElements(povElements);\n  }\n\n  if (targetCamOpacity > OPACITY_VISIBILITY_THRESHOLD) {\n    updateTextElementVisibility(camElements, targetCamOpacity);\n  } else {\n    hideTextElements(camElements);\n  }\n}\n\nfunction resetTangentSmoothers() {\n  Object.keys(povTangentSmoothers).forEach((key) => {\n    if (povTangentSmoothers[key]) {\n      const resetVector =\n        key === \"camera\"\n          ? new THREE.Vector3(0, 0, -1)\n          : new THREE.Vector3(1, 0, 0);\n      povTangentSmoothers[key].reset(resetVector);\n    }\n  });\n}\n\nfunction hideTextElements(elements: NodeListOf<Element>) {\n  elements.forEach((element) => {\n    const el = element as HTMLElement;\n    el.classList.add(\"no-visibility\");\n    el.style.opacity = \"0\";\n  });\n}\n\nfunction handleLeavePOV() {\n  Object.entries(ghosts).forEach(([key, ghost]) => {\n    if (key !== \"pacman\") {\n      ghost.visible = false;\n\n      const ghostIndex = parseInt(key.replace(\"ghost\", \"\")) - 1;\n      const cached = domElementCache[ghostIndex];\n\n      if (cached?.parent) {\n        hideTextElements(cached.povElements);\n        hideTextElements(cached.camElements);\n        cached.parent.classList.add(\"no-visibility\");\n      }\n\n      setObjectOpacity(ghost, 1.0, {\n        preserveTransmission: true,\n        skipCurrencySymbols: true,\n      });\n    }\n  });\n\n  if (ghosts.pacman) {\n    ghosts.pacman.visible = true;\n  }\n\n  resetTangentSmoothers();\n}\n\nfunction resetState() {\n  if (ghosts.pacman) {\n    ghosts.pacman.visible = true;\n  }\n\n  rotationStarted = false;\n  cachedStartYAngle = null;\n  startedInitEndScreen = false;\n\n  Object.keys(ghostStates).forEach((key) => {\n    ghostStates[key] = {\n      hasBeenTriggered: false,\n      triggerCameraProgress: null,\n      ghostStartFadeInProgress: null,\n      ghostEndFadeInProgress: null,\n      ghostStartFadeOutProgress: null,\n      camStartFadeInProgress: null,\n      camEndFadeInProgress: null,\n      camStartFadeOutProgress: null,\n      endCameraProgress: null,\n      currentPathT: 0,\n    };\n  });\n\n  resetTangentSmoothers();\n}\n\nfunction findClosestProgressOnPath(\n  path: THREE.CurvePath<THREE.Vector3>,\n  targetPoint: THREE.Vector3,\n  samples: number = FIND_CLOSEST_SAMPLES\n): number {\n  if (!path || !targetPoint) return 0;\n\n  let closestProgress = 0;\n  let closestDistance = Infinity;\n\n  for (let i = 0; i < samples; i++) {\n    try {\n      const t = i / (samples - 1);\n      const pointOnPath = path.getPointAt(t);\n      if (!pointOnPath) continue;\n\n      const distance = pointOnPath.distanceTo(targetPoint);\n      if (distance < closestDistance) {\n        closestDistance = distance;\n        closestProgress = t;\n      }\n    } catch (error) {}\n  }\n\n  return closestProgress;\n}\n","import gsap from \"gsap\";\nimport { applyOutroScrollPreset, getScrollDirection } from \"./scene-presets\";\nimport {\n  SCROLL_SELECTORS,\n  SCRUB_DURATION,\n  KEYFRAME_SCALE,\n  KEYFRAME_DURATION,\n  OPACITY,\n} from \"./constants\";\n\nlet outroScrollTimeline: gsap.core.Timeline | null = null;\n\nexport function initOutroScrollAnimation() {\n  outroScrollTimeline = gsap\n    .timeline({\n    scrollTrigger: {\n        trigger: SCROLL_SELECTORS.OUTRO,\n      start: \"top center\",\n      end: \"bottom bottom\",\n        scrub: SCRUB_DURATION,\n        markers: false,\n      onEnter: () => {\n        const scrollDir = getScrollDirection();\n        applyOutroScrollPreset(true, scrollDir);\n      },\n      onEnterBack: () => {\n        const scrollDir = getScrollDirection();\n        applyOutroScrollPreset(true, scrollDir);\n      },\n      },\n    })\n    .addLabel(\"outro-text-start\", 0)\n    .fromTo(\n      \".sc_b--outro\",\n      { scale: KEYFRAME_SCALE.START, opacity: OPACITY.HIDDEN },\n    {\n      keyframes: [\n          {\n            scale: KEYFRAME_SCALE.START,\n            opacity: OPACITY.HIDDEN,\n            duration: KEYFRAME_DURATION.NONE,\n          },\n          {\n            scale: KEYFRAME_SCALE.MID,\n            opacity: OPACITY.FULL,\n            duration: KEYFRAME_DURATION.FADE_IN,\n          },\n          {\n            scale: KEYFRAME_SCALE.LARGE,\n            opacity: OPACITY.FULL,\n            duration: KEYFRAME_DURATION.HOLD,\n          },\n          {\n            scale: KEYFRAME_SCALE.END,\n            opacity: OPACITY.HIDDEN,\n            duration: KEYFRAME_DURATION.FADE_OUT,\n          },\n        ],\n      }\n    )\n    .addLabel(\"outro-text-fade-in\", KEYFRAME_DURATION.NONE)\n    .addLabel(\n      \"outro-text-hold\",\n      KEYFRAME_DURATION.NONE + KEYFRAME_DURATION.FADE_IN\n    )\n    .addLabel(\n      \"outro-text-fade-out\",\n      KEYFRAME_DURATION.NONE +\n        KEYFRAME_DURATION.FADE_IN +\n        KEYFRAME_DURATION.HOLD\n    )\n    .addLabel(\n      \"outro-text-end\",\n      KEYFRAME_DURATION.NONE +\n        KEYFRAME_DURATION.FADE_IN +\n        KEYFRAME_DURATION.HOLD +\n        KEYFRAME_DURATION.FADE_OUT\n  );\n}\n","import {\n  startRenderLoop,\n  initRenderer,\n  setupLighting,\n  createEnvironmentMap,\n  scene,\n} from \"./core/scene\";\nimport {\n  setupHomeLoopScrollHandler,\n  startHomeLoop,\n} from \"./animation/home-loop\";\nimport { initPovScrollAnimation } from \"./animation/pov-scroll\";\nimport { loadModel } from \"./core/objects\";\nimport { setupCamera } from \"./core/camera\";\nimport { initIntroScrollAnimation } from \"./animation/intro-scroll\";\nimport { initOutroScrollAnimation } from \"./animation/outro-scroll\";\nimport { initializeObjectStates } from \"./animation/object-state\";\nimport { createIntroPacmanRotationHUD } from \"./core/debug-hud\";\n\nfunction initSkipButton() {\n  const skipButton = document.querySelector(\".wr_p--skip.wr_p\");\n  if (skipButton) {\n    const finalSection = document.querySelector(\".sc--testimonials\");\n    if (finalSection) {\n      skipButton.addEventListener(\"click\", () => {\n        finalSection.scrollIntoView({\n          behavior: \"smooth\",\n          block: \"start\",\n          inline: \"nearest\",\n        });\n      });\n    }\n  }\n}\n\nasync function main() {\n  initRenderer();\n  setupLighting();\n  createEnvironmentMap();\n  setupCamera();\n  await loadModel(scene);\n\n  initializeObjectStates();\n\n  setupHomeLoopScrollHandler();\n  if (window.scrollY === 0) {\n    startHomeLoop();\n  }\n\n  initPovScrollAnimation();\n  initIntroScrollAnimation();\n  initOutroScrollAnimation();\n  initSkipButton();\n\n  // Create intro-scroll Pacman rotation HUD\n  createIntroPacmanRotationHUD();\n\n  startRenderLoop();\n}\n\nmain();\n"],"names":["SELECTORS","mazeContainer","canvas","homeSection","HOME","introSection","INTRO","povSection","POV","finalSection","OUTRO","finalContainer","scrollComponent","parentElements","pov","cam","DOM_ELEMENTS","document","querySelector","querySelectorAll","mazeTexture","load","mazeMaterial","matcap","topMaterial","color","metalness","roughness","envMapIntensity","ghostMaterial","opacity","transparent","depthWrite","depthTest","blending","side","transmission","floorMaterial","pacmanMaterials","blue","white","default","pillFrontGlass","thickness","ior","reflectivity","clearcoat","clearcoatRoughness","pillBackGlass","pillMaterials","shell","shellFront","shellBack","bitcoin","materialMap","CAM_Pacman_Backframe","CAM_Pacman_Logo_1","CAM_Pacman_Logo_2","pillMaterialMap","PACMAN_ROTATION_OFFSETS","x","y","z","homeScrollTimeline","originalFOV","startPositions","allObjects","clonedMaterials","cachedPaths","cachedPathsKey","initHomeScrollAnimation","kill","cameraPathPoints","getCameraHomeScrollPathPoints","cameraPath","length","cameraCurve","pos","add","disposeClonedMaterials","forEach","mat","dispose","handleScrollLeave","key","object","preserveTransmission","skipCurrencySymbols","handleScrollEnter","requestAnimationFrame","introScrollTrigger","isActive","homeLoopStartPos","homeLoopStartRot","scrollDir","Object","entries","ghosts","position","copy","clone","quaternion","rotationsToUse","keys","createObjectAnimations","scrollTrigger","id","trigger","start","end","scrub","markers","refreshPriority","invalidateOnRefresh","onEnter","onEnterBack","onUpdate","self","curves","progress","clampedProgress","Math","min","max","cameraProgress","pow","cameraPoint","getPointAt","lookAtPoints","point","lookAt","push","lookAtPoint","targetZRotation","currentEuler","setFromQuaternion","PI","setFromEuler","euler","console","log","toFixed","fov","updateProjectionMatrix","onLeave","onLeaveBack","clear","pathsKey","JSON","stringify","homeScrollPaths","animPropsArray","animationData","currentMaterialOpacity","mesh","clonedMat","values","includes","material","Array","isArray","index","indexOf","newMaterials","startRot","startEuler","endEuler","offsets","xRotation","setFromAxisAngle","yRotation","zRotation","pacmanLayDown","multiply","path","animProps","rotX","rotY","rotZ","objectTimings","data","timing","startPercent","endPercent","startTime","duration","startPathPoint","fromTo","HIDDEN","ease","immediateRender","homeScrollTrigger","rawProgress","easedProgress","pathPoint","finalRotX","finalRotY","finalRotZ","finalOpacity","newEndEuler","pacmanMixer","update","getDelta","rotation","set","updateMatrixWorld","FULL","fadeProgress","pillYRotationDegrees","getPillYRotationDegrees","pacmanRotationX","pacmanRotationY","pacmanRotationZ","getPacmanRotationOffsets","introPacmanRotationX","introPacmanRotationY","introPacmanRotationZ","getIntroPacmanRotation","applyPillRotation","pill","targetEuler","hudContainer","isVisible","pacmanHudContainer","isPacmanHudVisible","createPillDebugHUD","createElement","style","cssText","toggleBtn","textContent","addEventListener","e","stopPropagation","preventDefault","display","body","appendChild","innerHTML","slider","valueDisplay","target","parseFloat","value","updateHUD","refreshInterval","startHUDRefresh","intervalMs","clearInterval","stopHUDRefresh","createPacmanRotationHUD","xSlider","ySlider","zSlider","xValueDisplay","yValueDisplay","zValueDisplay","updatePacmanHUD","introPacmanHudContainer","isIntroPacmanHudVisible","createIntroPacmanRotationHUD","pacmanObj","pacman","introScrollModule","pacmanTargetQuaternion","updateIntroPacmanRotation","updateIntroPacmanHUD","newQuaternion","error","SCALE","PACMAN_HOME","PACMAN_INTRO","GHOST_NORMAL","GHOST_INTRO","GHOST_POV","OPACITY","SCROLL_SELECTORS","TANGENT_SMOOTHING","HOME_LOOP","PARAMETER_SMOOTHING_FACTOR","GHOST_FADE_THRESHOLD","GHOST_FADE_OUT_DURATION","INTRO_WALK_DISTANCE","INTRO_FADE_IN_DURATION","INTRO_POSITION_OFFSET","FIND_CLOSEST_SAMPLES","SCRUB_DURATION","STAGGER_AMOUNT","ROTATION_TRANSITION_DURATION","POV_SEQUENCE_PHASE_END","POV_TRANSITION_PHASE_END","POV_Y_CONSTRAINT_THRESHOLD","OPACITY_VISIBILITY_THRESHOLD","KEYFRAME_SCALE","START","MID","LARGE","END","KEYFRAME_DURATION","NONE","FADE_IN","HOLD","FADE_OUT","INTRO_GHOST_OFFSETS","GHOST1","GHOST2","GHOST3","GHOST4","GHOST5","clamp","module","exports","gsap","setObjectOpacity","options","forEachMaterial","setMaterialOpacity","currentOpacity","currentTransparent","abs","shouldBeTransparent","undefined","needsUpdate","setMaterialTransparent","getObjectOpacity","found","resetGhostMaterialsToFullOpacity","callback","skipPacmanParts","objectKey","traverse","child","isMesh","childName","name","applyHomeLoopPreset","isEntering","scrollDirection","visible","applyHomeScrollPreset","pausedPositions","pausedRotations","applyPovScrollPreset","applyOutroScrollPreset","lastScrollY","window","scrollY","getScrollDirection","currentScrollY","direction","isMobile","innerWidth","ASSETS","mazeModel","introScrollTimeline","isIntroScrollActive","lastUpdateProgress","ghostTargetQuaternion","introInitialRotations","cachedCameraPosition","lastCameraUpdateFrame","introGridGuides","resetIntroScrollCache","setIntroScrollLocked","locked","obj","userData","introScrollLocked","restoreFloor","floorState","lastFloorState","createIntroGridGuides","remove","gridGroup","gridYPosition","xLinesMaterial","i","gridSize","xLineGeometry","setFromPoints","xLine","renderOrder","zLinesMaterial","zLineGeometry","zLine","yLineGeometry","yLineMaterial","yLine","labelColor","floor","markerGeometry","markerMaterial","marker","width","height","context","getContext","fillStyle","font","textAlign","textBaseline","fillText","toString","texture","spriteMaterial","map","sprite","scale","originGeometry","originMaterial","originMarker","removeIntroGridGuides","initIntroScrollAnimation","startColor","endColor","fontSize","fontWeight","indent","timeScale","currentFrame","performance","now","camX","camY","camZ","isFinite","tempVector","quat","tempObj","axis","angle","ghostObj","ghost1","initializeQuaternions","pacmanQuat","ghostQuat","walkStart","walkEnd","objectsToAnimate","behindOffset","zOffset","xOffset","yOffset","zPhase","normalizedProgress","baseX","pacmanX","pacmanY","pacmanZ","baseGhostOpacity","staticYOffset","zBounce","sin","animatedYOffset","finalX","finalY","finalZ","targetQuat","targetOpacity","updateObjectsWalkBy","addLabel","keyframes","homeLoopState","t","animationTime","currentObjectStates","homeLoopStartPositions","homeLoopStartRotations","homeLoopStartT","isHomeLoopActive","setHomeLoopActive","active","updateHomeLoopT","initializeObjectStates","initialOpacity","getCurrentPositions","positions","state","getCurrentRotations","rotations","updateObjectPosition","force","preserveHomeLoopStart","getHomeLoopStartPositions","updateObjectRotation","getHomeLoopStartRotations","reduce","acc","rot","setHomeLoopStartT","getHomeLoopStartT","pathCache","Map","TangentSmoother","constructor","initialTangent","smoothing","this","currentTangent","targetTangent","lerp","normalize","reset","newTangent","getCurrentTangent","setSmoothingFactor","createMazePath","pathPoints","cacheKey","p","type","arc","join","has","get","current","next","curveCheckPoints","catmullPoints","midPoint","createNormalCurveMidPoint","curveType","createCameraHomeScrollPath","curve","getHomePaths","paths","homePaths","getHomeScrollPaths","scrollPathPoints","createHomeScrollPathPoints","camera","createHomeScrollPath","getPovPaths","povPaths","scene","renderer","antialias","alpha","powerPreference","precision","clock","frameCallbacks","initRenderer","setPixelRatio","devicePixelRatio","shadowMap","enabled","setSize","clientWidth","clientHeight","domElement","innerHeight","render","pixelRatio","aspect","setupLighting","ambientLight","directionalLight","shadow","mapSize","left","right","top","bottom","near","far","bias","radius","castShadow","createEnvironmentMap","envScene","geometry","skybox","cubeRenderTarget","environment","startRenderLoop","onFrame","setFloorPlane","setHex","setObjectScale","sceneType","killObjectAnimations","setupCamera","startPosition","getStartPosition","lookAtPosition","getLookAtPosition","ScrollTrigger","OBJECT_KEYS","CURRENCY_SYMBOLS","isCurrencySymbol","some","symbol","isPacmanPart","calculateObjectOrientation","tangent","objectType","targetRotation","atan2","baseLayDownQuat","LAY_DOWN_QUAT_1","LAY_DOWN_QUAT_2","slerpToLayDown","startQuat","angleTo","slerp","applyRotations","result","axisVector","rotateQuaternionAroundAxis","THREE","mergeAttributes","attributes","TypedArray","itemSize","normalized","gpuType","arrayLength","attribute","isInterleavedBufferAttribute","array","offset","BufferAttribute","loader","ghost2","ghost3","ghost4","ghost5","ghostContainers","Ghost_EUR","Ghost_CHF","Ghost_YEN","Ghost_USD","Ghost_GBP","async","loadModel","ghost","Promise","resolve","reject","gltf","model","children","subChild","item","pacmanActions","animations","clip","action","clipAction","getMixer","getRoot","skipAnimation","updateMorphTargets","setEffectiveWeight","play","ghostContainer","ghostGroup","startsWith","toLowerCase","pillGroup","shellMeshes","otherMeshes","subChildName","clonedMesh","lowerName","isShell","isBitcoin","transformedGeometries","applyMatrix4","matrixWorld","combinedGeometry","geometries","useGroups","isIndexed","attributesUsed","Set","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","BufferGeometry","attributesCount","size","count","addGroup","indexOffset","mergedIndex","j","getX","setIndex","mergedAttribute","setAttribute","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","mergeGeometries","computeBoundingBox","bbox","boundingBox","centerY","geo","topGeometry","bottomGeometry","splitY","toNonIndexed","topPositions","bottomPositions","centroidY","trianglePositions","Float32Array","computeVertexNormals","splitGeometryByY","topMesh","receiveShadow","bottomMesh","clonedChild","X","Z","getCoord","objectHomeScrollEndPathPoint","cameraPathPointsConfig","startMobile","startDesktop","secondMobile","secondDesktop","mobileLookAt","desktopLookAt","cameraLookAtSecondDesktop","cameraLookAtSecondMobile","cameraHomeScrollEndLookAt","thirdPosition","cameraHomeScrollEndPathPoint","secondPosition","cameraLookAtSecondPosition","pacmanHomePathPoints","ghost1HomePathPoints","ghost2HomePathPoints","ghost3HomePathPoints","ghost4HomePathPoints","ghost5HomePathPoints","cameraHomeScrollPathPoints","cameraPOVPathPoints","lookAtSequence","ghost1POVPathPoints","ghost2POVPathPoints","ghost3POVPathPoints","ghost4POVPathPoints","ghost5POVPathPoints","povTriggerPositions","triggerPos","ghostStartFadeIn","ghostEndFadeIn","ghostStartFadeOut","camStartFadeIn","camEndFadeIn","camStartFadeOut","endPosition","forceEndProgress","scrollPaths","pausedPos","arcPoint","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","n","getter","__esModule","d","a","definition","o","defineProperty","enumerable","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","homeLoopFrameRegistered","rotationTransitionTime","startRotations","hasBeenPausedBefore","homeLoopTangentSmoothers","ghostEntries","tempObject","tempQuaternion","lastScales","startHomeLoop","savedT","targetCameraPos","currentCameraPos","cameraDistance","distanceTo","wasInHomeScroll","transitionDuration","targetLookAt","lookAtProps","startLookAt","getWorldDirection","multiplyScalar","currentLookAt","smoothingFactor","initialVector","initializeHomeLoopTangentSmoothers","targetPosition","currentPosition","distance","isTransitioningFromHomeScroll","onComplete","savedRotation","currentQuat","quatProps","getTangentAt","lastTime","getElapsedTime","hidden","currentTime","delta","clampedDelta","transitionProgress","isTransitioning","objectT","expectedScale","rawTangent","smoothTangent","slerpResult","updateHomeLoop","domElementCache","povScrollTimeline","previousCameraPosition","rotationStarted","startedInitEndScreen","startRotationPoint","endRotationPoint","cachedStartYAngle","ghostStates","povTangentSmoothers","initPovScrollAnimation","initializePovTangentSmoothers","hasBeenTriggered","triggerCameraProgress","ghostStartFadeInProgress","ghostEndFadeInProgress","ghostStartFadeOutProgress","camStartFadeInProgress","camEndFadeInProgress","camStartFadeOutProgress","endCameraProgress","currentPathT","toggleActions","to","onStart","handleAnimationStart","handleAnimationUpdate","onReverseComplete","handleLeavePOV","resetState","initialCameraTangent","overallProgress","targets","cameraPosition","customLookAt","firstPoint","sequenceProgress","sequenceLength","segmentSize","currentSegment","segmentProgress","fromIndex","toIndex","fromTarget","toTarget","finalSequenceLookAt","constrainedTangent","defaultLookAt","getCustomLookAtForProgress","startRotationProgress","findClosestProgressOnPath","endRotationProgress","handleDefaultOrientation","updateCamera","triggerData","ghostIndex","parseInt","replace","cached","parent","povElements","camElements","currentCameraProgress","ghostProgress","classList","hideTextElements","targetGhostOpacity","targetCamOpacity","fadeOutProgress","calculateTextOpacities","isPassed","hasNoVisibility","contains","updateTextElementVisibility","updateTextVisibility","updateGhost","updateGhosts","elements","element","el","resetTangentSmoothers","resetVector","targetPoint","samples","closestProgress","closestDistance","Infinity","pointOnPath","outroScrollTimeline","exactT","stopHomeLoop","skipButton","scrollIntoView","behavior","block","inline","initSkipButton","main"],"sourceRoot":""}