{"version":3,"file":"script.js","mappings":"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","sources":["webpack://cam-3d-animation/webpack/bootstrap","webpack://cam-3d-animation/webpack/runtime/compat get default export","webpack://cam-3d-animation/webpack/runtime/define property getters","webpack://cam-3d-animation/webpack/runtime/hasOwnProperty shorthand","webpack://cam-3d-animation/external var \"THREE\"","webpack://cam-3d-animation/./src/config/config.ts","webpack://cam-3d-animation/./src/config/dom-elements.ts","webpack://cam-3d-animation/external var \"gsap\"","webpack://cam-3d-animation/external var \"ScrollTrigger\"","webpack://cam-3d-animation/./src/paths/coordinates.ts","webpack://cam-3d-animation/./src/paths/pathpoints.ts","webpack://cam-3d-animation/./src/core/camera.ts","webpack://cam-3d-animation/./src/core/scene.ts","webpack://cam-3d-animation/./src/core/materials.ts","webpack://cam-3d-animation/./src/core/objects.ts","webpack://cam-3d-animation/./src/paths/paths.ts","webpack://cam-3d-animation/./src/animation/util.ts","webpack://cam-3d-animation/./src/animation/scene-presets.ts","webpack://cam-3d-animation/./src/animation/home-scroll.ts","webpack://cam-3d-animation/./src/animation/home-loop.ts","webpack://cam-3d-animation/./src/animation/pov-scroll.ts","webpack://cam-3d-animation/./src/animation/intro-scroll.ts","webpack://cam-3d-animation/./src/animation/outro-scroll.ts","webpack://cam-3d-animation/./src/main.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const __WEBPACK_NAMESPACE_OBJECT__ = THREE;","export const isMobile = window.innerWidth < 768;\n\nexport const ASSETS = {\n  mazeTexture: \"https://c-am.b-cdn.net/CAM/matcap24.png\",\n  mazeModel: \"https://c-am.b-cdn.net/CAM/c-am-assets-3.glb\",\n};\n","const SELECTORS = {\n  mazeContainer: \".el--home-maze.el\",\n  canvas: \"canvas\",\n\n  homeSection: \".sc--home.sc\",\n  introSection: \".sc--intro.sc\",\n  povSection: \".sc--pov.sc\",\n  finalSection: \".sc--outro.sc\",\n  finalContainer: \".cr--outro.cr\",\n\n  scrollComponent: \".cmp--scroll.cmp\",\n  parentElements: \".cmp--pov.cmp\",\n\n  pov: \".pov\",\n  cam: \".cam\",\n};\n\nexport const DOM_ELEMENTS = {\n  mazeContainer: document.querySelector(SELECTORS.mazeContainer) as HTMLElement,\n  canvas: document.querySelector(SELECTORS.canvas) as HTMLCanvasElement,\n\n  homeSection: document.querySelector(SELECTORS.homeSection) as HTMLElement,\n  introSection: document.querySelector(SELECTORS.introSection) as HTMLElement,\n  povSection: document.querySelector(SELECTORS.povSection) as HTMLElement,\n  finalSection: document.querySelector(SELECTORS.finalSection) as HTMLElement,\n  finalContainer: document.querySelector(\n    SELECTORS.finalContainer\n  ) as HTMLElement,\n\n  parentElements: document.querySelectorAll(\n    SELECTORS.parentElements\n  ) as NodeListOf<Element>,\n};\n","const __WEBPACK_NAMESPACE_OBJECT__ = gsap;","const __WEBPACK_NAMESPACE_OBJECT__ = ScrollTrigger;","export type XCoordKey =\n  | \"0\"\n  | \"0.5\"\n  | \"1\"\n  | \"1.5\"\n  | \"2\"\n  | \"2.5\"\n  | \"3\"\n  | \"3.5\"\n  | \"4\"\n  | \"4.5\"\n  | \"5\"\n  | \"5.5\"\n  | \"6\"\n  | \"6.5\"\n  | \"7\"\n  | \"7.5\"\n  | \"8\"\n  | \"8.5\"\n  | \"9\"\n  | \"9.5\"\n  | \"10\"\n  | \"10.5\"\n  | \"11\"\n  | \"11.5\"\n  | \"12\"\n  | \"12.5\"\n  | \"13\"\n  | \"13.5\"\n  | \"14\"\n  | \"14.5\"\n  | \"15\"\n  | \"15.5\"\n  | \"16\"\n  | \"16.5\"\n  | \"17\"\n  | \"17.5\"\n  | \"18\"\n  | \"18.5\"\n  | \"19\"\n  | \"19.5\"\n  | \"20\"\n\nexport type ZCoordKey =\n  | \"0\"\n  | \"0.5\"\n  | \"1\"\n  | \"1.5\"\n  | \"2\"\n  | \"2.5\"\n  | \"3\"\n  | \"3.5\"\n  | \"4\"\n  | \"4.5\"\n  | \"5\"\n  | \"5.5\"\n  | \"6\"\n  | \"6.5\"\n  | \"7\"\n  | \"7.5\"\n  | \"8\"\n  | \"8.5\"\n  | \"9\"\n  | \"9.5\"\n  | \"10\"\n  | \"10.5\"\n  | \"11\"\n  | \"11.5\"\n  | \"12\"\n  | \"12.5\"\n  | \"13\"\n  | \"13.5\"\n  | \"14\"\n  | \"14.5\"\n  | \"15\"\n  | \"15.5\"\n  | \"16\"\n\nexport const Y = 0.55;\n\nexport const X: Record<XCoordKey, number> = {\n  \"0\": -0.54875,\n  \"0.5\": -0.4985,\n  \"1\": -0.44825,\n  \"1.5\": -0.398,\n  \"2\": -0.34775,\n  \"2.5\": -0.2975,\n  \"3\": -0.24725,\n  \"3.5\": -0.197,\n  \"4\": -0.14675,\n  \"4.5\": -0.0965,\n  \"5\": -0.04625,\n  \"5.5\": 0.004,\n  \"6\": 0.05425,\n  \"6.5\": 0.1045,\n  \"7\": 0.15475,\n  \"7.5\": 0.205,\n  \"8\": 0.25525,\n  \"8.5\": 0.3055,\n  \"9\": 0.35575,\n  \"9.5\": 0.406,\n  \"10\": 0.45625,\n  \"10.5\": 0.5065,\n  \"11\": 0.55675,\n  \"11.5\": 0.607,\n  \"12\": 0.65725,\n  \"12.5\": 0.7075,\n  \"13\": 0.75775,\n  \"13.5\": 0.808,\n  \"14\": 0.85825,\n  \"14.5\": 0.9085,\n  \"15\": 0.95875,\n  \"15.5\": 1.009,\n  \"16\": 1.05925,\n  \"16.5\": 1.1095,\n  \"17\": 1.15975,\n  \"17.5\": 1.21,\n  \"18\": 1.26025,\n  \"18.5\": 1.3105,\n  \"19\": 1.36075,\n  \"19.5\": 1.411,\n  \"20\": 1.46125,\n};\n\nexport const Z: Record<ZCoordKey, number> = {\n  \"0\": -0.302,\n  \"0.5\": -0.25175,\n  \"1\": -0.2015,\n  \"1.5\": -0.15125,\n  \"2\": -0.101,\n  \"2.5\": -0.05075,\n  \"3\": -0.0005,\n  \"3.5\": 0.04975,\n  \"4\": 0.1,\n  \"4.5\": 0.15025,\n  \"5\": 0.2005,\n  \"5.5\": 0.25075,\n  \"6\": 0.301,\n  \"6.5\": 0.35125,\n  \"7\": 0.4015,\n  \"7.5\": 0.45175,\n  \"8\": 0.502,\n  \"8.5\": 0.55225,\n  \"9\": 0.6025,\n  \"9.5\": 0.65275,\n  \"10\": 0.703,\n  \"10.5\": 0.75325,\n  \"11\": 0.8035,\n  \"11.5\": 0.85375,\n  \"12\": 0.904,\n  \"12.5\": 0.95425,\n  \"13\": 1.0045,\n  \"13.5\": 1.05475,\n  \"14\": 1.105,\n  \"14.5\": 1.15525,\n  \"15\": 1.2055,\n  \"15.5\": 1.25575,\n  \"16\": 1.306,\n}\n\nexport const getCoord = (x: XCoordKey, z: ZCoordKey) => {\n  return new THREE.Vector3(X[x], Y, Z[z])\n};","import * as THREE from \"three\";\nimport { MazePathPoint, PathPoint, CameraPathPoint } from \"../types/types\";\nimport { isMobile } from \"../config/config\";\nimport { getCoord, X, Y, Z } from \"./coordinates\";\n\n// TODO - add curveCheckPoints to all curves where needed\n\nconst objectHomeScrollEndPathPoint = new THREE.Vector3(0.55675, 0.35, 0.45175);\n\nconst cameraPathPointsConfig = {\n  startMobile: new THREE.Vector3(0.5, 2.5, 2.5),\n  startDesktop: new THREE.Vector3(-2, 2.5, 2),\n  secondMobile: new THREE.Vector3(0.5, 2.5, 2),\n  secondDesktop: new THREE.Vector3(-1.5, 3, 0.75),\n  mobileLookAt: new THREE.Vector3(0.5, 0.5, -1.5),\n  desktopLookAt: new THREE.Vector3(-1.25, 0.5, 0.25),\n  cameraLookAtSecondDesktop: new THREE.Vector3(-0.75, 0.5, -0.75),\n  cameraLookAtSecondMobile: new THREE.Vector3(-0.75, 0.5, -0.75), // TODO\n\n  cameraHomeScrollEndLookAt: new THREE.Vector3(0.55675, -5, 0.35),\n  thirdPosition: new THREE.Vector3(0.55675, 3, 0.45175),\n\n  cameraHomeScrollEndPathPoint: new THREE.Vector3(0.55675, 0.5, 0.45175),\n};\n\n// determine positions and look at - changed if is mobile\nconst startPosition = isMobile\n  ? cameraPathPointsConfig.startMobile\n  : cameraPathPointsConfig.startDesktop;\nconst secondPosition = isMobile\n  ? cameraPathPointsConfig.secondMobile\n  : cameraPathPointsConfig.secondDesktop;\nconst lookAtPosition = isMobile\n  ? cameraPathPointsConfig.mobileLookAt\n  : cameraPathPointsConfig.desktopLookAt;\nconst cameraLookAtSecondPosition = isMobile\n  ? cameraPathPointsConfig.cameraLookAtSecondMobile\n  : cameraPathPointsConfig.cameraLookAtSecondDesktop;\n\nconst thirdPosition = cameraPathPointsConfig.thirdPosition;\nconst cameraHomeScrollEndLookAt =\n  cameraPathPointsConfig.cameraHomeScrollEndLookAt;\nconst cameraHomeScrollEndPathPoint =\n  cameraPathPointsConfig.cameraHomeScrollEndPathPoint;\n\nconst pacmanHomePathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"8\", \"9\"), type: \"straight\" },\n  {\n    pos: getCoord(\"8\", \"6\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"9\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"10\", \"4\"), type: \"straight\" },\n  {\n    pos: getCoord(\"10\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"9\", \"1\"), type: \"straight\" },\n  {\n    pos: getCoord(\"7\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"6\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"5\", \"3\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"4\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"3\", \"1\"),\n    type: \"straight\",\n    curveCheckPoints: [\n      getCoord(\"2\", \"1\"),\n      getCoord(\"1\", \"2\"),\n      getCoord(\"1\", \"2.5\"),\n      getCoord(\"1.5\", \"3\"),\n      getCoord(\"2\", \"3.5\"),\n    ],\n  },\n  {\n    pos: getCoord(\"2\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"3\", \"5\"), type: \"straight\" },\n  {\n    pos: getCoord(\"5\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"6\", \"6\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"5\", \"7\"), type: \"straight\" },\n  {\n    pos: getCoord(\"4\", \"7\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"3\", \"8\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"4\", \"9\"), type: \"straight\" },\n  {\n    pos: getCoord(\"5\", \"9\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"6\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"5\", \"11\"),\n    type: \"straight\",\n    curveCheckPoints: [\n      getCoord(\"3\", \"11\"),\n      getCoord(\"2\", \"12\"),\n      getCoord(\"1.5\", \"13\"),\n      getCoord(\"1\", \"14\"),\n      getCoord(\"2\", \"15\"),\n      getCoord(\"3\", \"15\"),\n      getCoord(\"4\", \"14\"),\n      getCoord(\"5\", \"13\"),\n    ],\n  },\n  {\n    pos: getCoord(\"6\", \"13\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"7\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"6\", \"15\"), type: \"straight\" },\n  {\n    pos: getCoord(\"5\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"4\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"5\", \"13\"),\n    type: \"straight\",\n    curveCheckPoints: [\n      getCoord(\"12\", \"13\"),\n      getCoord(\"13\", \"12\"),\n      getCoord(\"12.5\", \"11\"),\n      getCoord(\"12\", \"10.5\"),\n      getCoord(\"11\", \"10\"),\n      getCoord(\"10\", \"10.5\"),\n      getCoord(\"9\", \"11\"),\n      getCoord(\"8\", \"10\"),\n      getCoord(\"8\", \"9.5\"),\n    ],\n  },\n  {\n    pos: getCoord(\"8\", \"9\"),\n    type: \"straight\",\n  },\n];\n\nconst ghost1HomePathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"1\", \"10\"), type: \"straight\" },\n  {\n    pos: getCoord(\"1\", \"6\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"2\", \"5\"), type: \"straight\" },\n  {\n    pos: getCoord(\"3\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"4\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"5\", \"3\"), type: \"straight\" },\n  {\n    pos: getCoord(\"9\", \"3\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"10\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"9\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"8\", \"6\"),\n    type: \"straight\",\n    curveCheckPoints: [\n      getCoord(\"8\", \"10\"),\n      getCoord(\"9\", \"11\"),\n      getCoord(\"10\", \"10.5\"),\n      getCoord(\"11\", \"10\"),\n      getCoord(\"12\", \"10.5\"),\n      getCoord(\"13\", \"11\"),\n      getCoord(\"15\", \"11\"),\n      getCoord(\"16\", \"10.5\"),\n      getCoord(\"17\", \"10\"),\n      getCoord(\"18\", \"10.5\"),\n      getCoord(\"19\", \"11\"),\n      getCoord(\"20\", \"10\"),\n    ],\n  },\n  {\n    pos: getCoord(\"20\", \"6\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"19\", \"5\"), type: \"straight\" },\n  {\n    pos: getCoord(\"9\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"8\", \"6\"),\n    type: \"straight\",\n    curveCheckPoints: [\n      getCoord(\"8\", \"8\"),\n      getCoord(\"7\", \"9\"),\n      getCoord(\"6\", \"10\"),\n      getCoord(\"5.5\", \"11\"),\n      getCoord(\"5\", \"12\"),\n      getCoord(\"6\", \"13\"),\n      getCoord(\"7\", \"14\"),\n      getCoord(\"6\", \"15\"),\n      getCoord(\"5\", \"15\"),\n      getCoord(\"4\", \"14\"),\n      getCoord(\"4.5\", \"13\"),\n      getCoord(\"5\", \"12\"),\n      getCoord(\"4\", \"11\"),\n    ],\n  },\n  { pos: getCoord(\"1\", \"10\"), type: \"straight\" },\n];\n\nconst ghost2HomePathPoints: MazePathPoint[] = [\n  {\n    pos: getCoord(\"5\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n    curveCheckPoints: [getCoord(\"5.5\", \"11\")],\n  },\n  {\n    pos: getCoord(\"6\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"5\", \"9\"), type: \"straight\" },\n  {\n    pos: getCoord(\"4\", \"9\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"3\", \"8\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"4\", \"7\"), type: \"straight\" },\n  {\n    pos: getCoord(\"7\", \"7\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"8\", \"8\"), type: \"straight\" },\n  {\n    pos: getCoord(\"8\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n    curveCheckPoints: [getCoord(\"8.5\", \"11\"), getCoord(\"9\", \"12\")],\n  },\n  { pos: getCoord(\"10\", \"13\"), type: \"straight\" },\n  {\n    pos: getCoord(\"12\", \"13\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"13\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"14\", \"15\"), type: \"straight\" },\n  {\n    pos: getCoord(\"19\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"20\", \"14\"), type: \"straight\" },\n  {\n    pos: getCoord(\"20\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"19\", \"3\"), type: \"straight\" },\n  {\n    pos: getCoord(\"17\", \"3\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"16\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"15\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"14\", \"4\"), type: \"straight\" },\n  {\n    pos: getCoord(\"14\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"13\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n    curveCheckPoints: [getCoord(\"12\", \"1.5\")],\n  },\n  {\n    pos: getCoord(\"11\", \"2\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"10\", \"3\"), type: \"straight\" },\n  {\n    pos: getCoord(\"10\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"9\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"8\", \"6\"), type: \"straight\" },\n  {\n    pos: getCoord(\"8\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n    curveCheckPoints: [getCoord(\"8.5\", \"11\")],\n  },\n  {\n    pos: getCoord(\"9\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"8\", \"13\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"7\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"6\", \"15\"), type: \"straight\" },\n  {\n    pos: getCoord(\"5\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"4\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n    curveCheckPoints: [getCoord(\"4.5\", \"13\"), getCoord(\"5\", \"12\")],\n  },\n];\n\nconst ghost3HomePathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"14\", \"10.5\"), type: \"straight\" },\n  {\n    pos: getCoord(\"14\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"13\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n    curveCheckPoints: [\n      getCoord(\"12\", \"1.5\"),\n      getCoord(\"11\", \"2\"),\n      getCoord(\"10\", \"1.5\"),\n    ],\n  },\n  { pos: getCoord(\"9\", \"1\"), type: \"straight\" },\n  {\n    pos: getCoord(\"7\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"6\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"7\", \"3\"), type: \"straight\" },\n  {\n    pos: getCoord(\"9\", \"3\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"10\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"11\", \"5\"), type: \"straight\" },\n  {\n    pos: getCoord(\"19\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"20\", \"6\"), type: \"straight\" },\n  {\n    pos: getCoord(\"20\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"19\", \"11\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n    curveCheckPoints: [\n      getCoord(\"18\", \"10.5\"),\n      getCoord(\"17\", \"10\"),\n      getCoord(\"16\", \"10.5\"),\n      getCoord(\"15.5\", \"11\"),\n    ],\n  },\n  { pos: getCoord(\"15\", \"12\"), type: \"straight\" },\n  {\n    pos: getCoord(\"15\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"14\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"13\", \"14\"), type: \"straight\" },\n  {\n    pos: getCoord(\"13\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n    curveCheckPoints: [\n      getCoord(\"12.5\", \"11\"),\n      getCoord(\"12\", \"10.5\"),\n      getCoord(\"10\", \"10.5\"),\n    ],\n  },\n  {\n    pos: getCoord(\"9\", \"11\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"8\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"7\", \"9\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"6\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n    curveCheckPoints: [getCoord(\"5.5\", \"11\")],\n  },\n  {\n    pos: getCoord(\"5\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"6\", \"13\"), type: \"straight\" },\n  {\n    pos: getCoord(\"12\", \"13\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"13\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"13.5\", \"11\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"14\", \"10.5\"), type: \"straight\" },\n];\n\nconst ghost4HomePathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"16\", \"7\"), type: \"straight\" },\n  {\n    pos: getCoord(\"16\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"15\", \"11\"), type: \"straight\" },\n  {\n    pos: getCoord(\"14\", \"11\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"13\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"12\", \"13\"), type: \"straight\" },\n  {\n    pos: getCoord(\"8\", \"13\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"7\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"6\", \"15\"), type: \"straight\" },\n  {\n    pos: getCoord(\"2\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"1\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n    curveCheckPoints: [\n      getCoord(\"1.5\", \"13\"),\n      getCoord(\"2\", \"12\"),\n      getCoord(\"1.5\", \"11\"),\n    ],\n  },\n  { pos: getCoord(\"1\", \"10\"), type: \"straight\" },\n  {\n    pos: getCoord(\"1\", \"6\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"2\", \"5\"), type: \"straight\" },\n  {\n    pos: getCoord(\"5\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"6\", \"6\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"7\", \"7\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"8\", \"6\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"9\", \"5\"), type: \"straight\" },\n  {\n    pos: getCoord(\"13\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"14\", \"4\"), type: \"straight\" },\n  {\n    pos: getCoord(\"14\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"15\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"16\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"17\", \"3\"), type: \"straight\" },\n  {\n    pos: getCoord(\"19\", \"3\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"20\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"19\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"18\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"19\", \"3\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"20\", \"4\"), type: \"straight\" },\n  {\n    pos: getCoord(\"20\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"19\", \"11\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n    curveCheckPoints: [getCoord(\"18\", \"10.5\")],\n  },\n  {\n    pos: getCoord(\"17\", \"10\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"16\", \"9\"), type: \"straight\" },\n  { pos: getCoord(\"16\", \"7\"), type: \"straight\" },\n];\n\nconst ghost5HomePathPoints: MazePathPoint[] = [\n  {\n    pos: getCoord(\"10\", \"3.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"9\", \"3\"), type: \"straight\" },\n  {\n    pos: getCoord(\"5\", \"3\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"4\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"3\", \"1\"), type: \"straight\" },\n  {\n    pos: getCoord(\"2\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"1\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"1.5\", \"3\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"2\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"3\", \"5\"), type: \"straight\" },\n  {\n    pos: getCoord(\"5\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"6\", \"6\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"5\", \"7\"), type: \"straight\" },\n  {\n    pos: getCoord(\"4\", \"7\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"3\", \"8\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"4\", \"9\"), type: \"straight\" },\n  {\n    pos: getCoord(\"7\", \"9\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"8\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"8.5\", \"11\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"9\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"10\", \"13\"), type: \"straight\" },\n  {\n    pos: getCoord(\"12\", \"13\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"13\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"14\", \"11\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"15\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"15\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"16\", \"15\"), type: \"straight\" },\n  {\n    pos: getCoord(\"19\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"20\", \"14\"), type: \"straight\" },\n  {\n    pos: getCoord(\"20\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"19\", \"1\"), type: \"straight\" },\n  {\n    pos: getCoord(\"17\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"16\", \"2\"), type: \"straight\" },\n  {\n    pos: getCoord(\"16\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"15\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"14\", \"4\"), type: \"straight\" },\n  {\n    pos: getCoord(\"14\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"13\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"12\", \"1.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"11\", \"2\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"10\", \"3.5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n];\n\nconst cameraHomeScrollPathPoints: CameraPathPoint[] = [\n  { pos: startPosition, lookAt: lookAtPosition },\n  // { pos: thirdPosition, lookAt: cameraHomeScrollEndLookAt },\n  { pos: secondPosition, lookAt: cameraLookAtSecondPosition },\n  { pos: thirdPosition, lookAt: cameraHomeScrollEndLookAt },\n  { pos: cameraHomeScrollEndPathPoint, lookAt: cameraHomeScrollEndLookAt },\n];\n\nconst cameraPOVPathPoints: MazePathPoint[] = [\n  {\n    pos: new THREE.Vector3(X[\"11\"], 0.40625, Z[\"7.5\"]),\n    type: \"straight\",\n    lookAtSequence: [\n      new THREE.Vector3(X[\"11\"], 0.2, Z[\"8\"]), // Look forward first\n      new THREE.Vector3(X[\"11\"], 1.2, Z[\"16\"]), // Look up\n      new THREE.Vector3(X[\"11\"], 0.55, Z[\"16\"]), // Look forward again\n    ],\n  },\n  {\n    pos: getCoord(\"11\", \"7.5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"11\", \"9\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n    curveCheckPoints: [\n      new THREE.Vector3(X[\"11\"], Y, 0.6525),\n      getCoord(\"11.5\", \"10\"),\n      getCoord(\"12\", \"10.5\"),\n      getCoord(\"12.5\", \"11\"),\n    ],\n  },\n  {\n    pos: getCoord(\"13\", \"11\"),\n    type: \"straight\",\n  },\n  {\n    pos: getCoord(\"14.5\", \"11\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"15\", \"11.5\"),\n    type: \"straight\",\n  },\n  {\n    pos: getCoord(\"15\", \"14.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"14.5\", \"15\"),\n    type: \"straight\",\n  },\n  {\n    pos: getCoord(\"13.5\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"13\", \"14.5\"),\n    type: \"straight\",\n  },\n  {\n    pos: getCoord(\"13\", \"13.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"12.5\", \"13\"),\n    type: \"straight\",\n  },\n  {\n    pos: getCoord(\"7.5\", \"13\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"7\", \"13.5\"),\n    type: \"straight\",\n  },\n  {\n    pos: getCoord(\"7\", \"14.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"7.5\", \"15\"),\n    type: \"straight\",\n  },\n  {\n    pos: getCoord(\"10.5\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"11\", \"16\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n];\n\nconst ghost1POVPathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"16\", \"10\"), type: \"straight\" },\n  {\n    pos: getCoord(\"16\", \"10.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"15.5\", \"11\"), type: \"straight\" },\n  { pos: getCoord(\"14.5\", \"11\"), type: \"straight\" },\n];\n\nconst ghost2POVPathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"16\", \"15\"), type: \"straight\" },\n  {\n    pos: getCoord(\"15.5\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"15\", \"14.5\"), type: \"straight\" },\n  { pos: getCoord(\"15\", \"13.5\"), type: \"straight\" },\n];\n\nconst ghost3POVPathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"9\", \"12\"), type: \"straight\" },\n  {\n    pos: getCoord(\"9\", \"12.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"9.5\", \"13\"), type: \"straight\" },\n  { pos: getCoord(\"10.5\", \"13\"), type: \"straight\" },\n];\n\nconst ghost4POVPathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"7\", \"14\"), type: \"straight\" },\n  {\n    pos: getCoord(\"7\", \"13.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"7.5\", \"13\"), type: \"straight\" },\n  { pos: getCoord(\"8.5\", \"13\"), type: \"straight\" },\n];\n\nconst ghost5POVPathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"11\", \"16\"), type: \"straight\" },\n  {\n    pos: getCoord(\"11\", \"15.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"10.5\", \"15\"), type: \"straight\" },\n  { pos: getCoord(\"9.5\", \"15\"), type: \"straight\" },\n];\n\n// start position, end position, ghost fade: 10, 20, cam fade: 50, 60, text start fade out: 90\n\n// @philipp - check ghost 3 - 5\n\nexport const povTriggerPositions = {\n  ghost1: {\n    triggerPos: new THREE.Vector3(0.65725, 0.55, 0.75325), // start ghost path\n    ghostStartFadeIn: new THREE.Vector3(0.7075, 0.55, 0.8035), // start ghost text fade in\n    ghostEndFadeIn: new THREE.Vector3(0.725, 0.55, 0.8035), // end ghost text fade in\n    ghostStartFadeOut: new THREE.Vector3(0.75, 0.55, 0.8035), // start ghost text fade out\n    camStartFadeIn: new THREE.Vector3(0.75775, 0.55, 0.8035), // start cam fade in\n    camEndFadeIn: new THREE.Vector3(0.775, 0.55, 0.8035), // end cam fade in\n    camStartFadeOut: new THREE.Vector3(0.84, 0.55, 0.8035), // start cam fade out\n    endPosition: new THREE.Vector3(0.85825, 0.55, 0.8035), // end of path\n    forceEndProgress: {\n      start: 0.1, // start of force end\n      end: 0.16, // end of force end\n    },\n  },\n  ghost2: {\n    triggerPos: new THREE.Vector3(0.9085, 0.55, 0.8035),\n    ghostStartFadeIn: new THREE.Vector3(0.95875, 0.55, 0.85375),\n    ghostEndFadeIn: new THREE.Vector3(0.95875, 0.55, 0.875),\n    ghostStartFadeOut: new THREE.Vector3(0.95875, 0.55, 0.89),\n    camStartFadeIn: new THREE.Vector3(0.95875, 0.55, 0.904),\n    camEndFadeIn: new THREE.Vector3(0.95875, 0.55, 0.93),\n    camStartFadeOut: new THREE.Vector3(0.95875, 0.55, 0.9975),\n    endPosition: new THREE.Vector3(0.95875, 0.55, 1.0045),\n    forceEndProgress: {\n      start: 0.17,\n      end: 0.22,\n    },\n  },\n  ghost3: {\n    triggerPos: new THREE.Vector3(0.75775, 0.55, 1.05475),\n    ghostStartFadeIn: new THREE.Vector3(0.7075, 0.55, 1.0045),\n    ghostEndFadeIn: new THREE.Vector3(0.7075, 0.55, 1.0045),\n    ghostStartFadeOut: new THREE.Vector3(0.6825, 0.55, 1.0045),\n    camStartFadeIn: new THREE.Vector3(0.65725, 0.55, 1.0045),\n    camEndFadeIn: new THREE.Vector3(0.65725, 0.55, 1.0045),\n    camStartFadeOut: new THREE.Vector3(0.6065, 0.55, 1.0045),\n    endPosition: new THREE.Vector3(0.55675, 0.55, 1.0045),\n    forceEndProgress: {\n      start: 0.23,\n      end: 0.33,\n    },\n  },\n  ghost4: {\n    triggerPos: new THREE.Vector3(0.65725, 0.55, 1.0045),\n    ghostStartFadeIn: new THREE.Vector3(0.5565, 0.55, 1.0045),\n    ghostEndFadeIn: new THREE.Vector3(0.5065, 0.55, 1.0045),\n    ghostStartFadeOut: new THREE.Vector3(0.4815, 0.55, 1.0045),\n    camStartFadeIn: new THREE.Vector3(0.45625, 0.55, 1.0045),\n    camEndFadeIn: new THREE.Vector3(0.45625, 0.55, 1.0045),\n    camStartFadeOut: new THREE.Vector3(0.4065, 0.55, 1.0045),\n    endPosition: new THREE.Vector3(0.35575, 0.55, 1.0045),\n    forceEndProgress: {\n      start: 0.38,\n      end: 0.47,\n    },\n  },\n  ghost5: {\n    triggerPos: new THREE.Vector3(0.15475, 0.55, 1.15525),\n    ghostStartFadeIn: new THREE.Vector3(0.1795, 0.55, 1.18),\n    ghostEndFadeIn: new THREE.Vector3(0.205, 0.55, 1.2055),\n    ghostStartFadeOut: new THREE.Vector3(0.23025, 0.55, 1.2055),\n    camStartFadeIn: new THREE.Vector3(0.25525, 0.55, 1.2055),\n    camEndFadeIn: new THREE.Vector3(0.25525, 0.55, 1.2055),\n    camStartFadeOut: new THREE.Vector3(0.3055, 0.55, 1.2055),\n    endPosition: new THREE.Vector3(0.35575, 0.55, 1.2055),\n    forceEndProgress: {\n      start: 0.52,\n      end: 0.59,\n    },\n  },\n};\n\nexport function getStartPosition() {\n  return startPosition;\n}\n\nexport function getSecondPosition() {\n  return secondPosition;\n}\n\nexport function getLookAtPosition() {\n  return lookAtPosition;\n}\n\nexport const homePaths = {\n  pacman: pacmanHomePathPoints,\n  ghost1: ghost1HomePathPoints,\n  ghost2: ghost2HomePathPoints,\n  ghost3: ghost3HomePathPoints,\n  ghost4: ghost4HomePathPoints,\n  ghost5: ghost5HomePathPoints,\n} as const;\n\nexport const povPaths = {\n  camera: cameraPOVPathPoints,\n  ghost1: ghost1POVPathPoints,\n  ghost2: ghost2POVPathPoints,\n  ghost3: ghost3POVPathPoints,\n  ghost4: ghost4POVPathPoints,\n  ghost5: ghost5POVPathPoints,\n} as const;\n\nexport function createHomeScrollPathPoints(\n  pausedPositions: Record<string, THREE.Vector3>\n): Record<string, PathPoint[]> {\n  const scrollPaths: Record<string, PathPoint[]> = {};\n\n  Object.entries(pausedPositions).forEach(([key, pausedPos]) => {\n    const arcPoint = new THREE.Vector3(\n      pausedPos.x * (1 / 4) + objectHomeScrollEndPathPoint.x * (3 / 4),\n      1.5,\n      pausedPos.z * (1 / 4) + objectHomeScrollEndPathPoint.z * (3 / 4)\n    );\n\n    scrollPaths[key] = [\n      { pos: pausedPos.clone() },\n      { pos: arcPoint },\n      { pos: objectHomeScrollEndPathPoint },\n    ];\n  });\n\n  return scrollPaths;\n}\n\nexport function getCameraHomeScrollPathPoints(): CameraPathPoint[] {\n  return cameraHomeScrollPathPoints;\n}\n","import * as THREE from \"three\";\nimport gsap from \"gsap\";\nimport ScrollTrigger from \"gsap/ScrollTrigger\";\nimport { getLookAtPosition, getStartPosition } from \"../paths/pathpoints\";\n\ngsap.registerPlugin(ScrollTrigger);\n\nconst CAMERA_CONFIG = {\n  originalFOV: 50,\n  wideFOV: 80,\n  near: 0.001,\n  far: 100,\n};\n\nexport const camera = new THREE.PerspectiveCamera(\n  50,\n  window.innerWidth / window.innerHeight,\n  CAMERA_CONFIG.near,\n  CAMERA_CONFIG.far\n);\n\nexport function setupCamera(): void {\n  const startPosition = getStartPosition();\n  const lookAtPosition = getLookAtPosition();\n  camera.position.set(startPosition.x, startPosition.y, startPosition.z);\n  camera.lookAt(lookAtPosition.x, lookAtPosition.y, lookAtPosition.z);\n}\n","import * as THREE from \"three\";\nimport { isMobile } from \"../config/config\";\nimport { DOM_ELEMENTS } from \"../config/dom-elements\";\nimport { camera } from \"./camera\";\n\nexport const scene = new THREE.Scene();\n\nconst renderer = new THREE.WebGLRenderer({\n  antialias: true,\n  alpha: true,\n  powerPreference: \"high-performance\",\n  precision: \"highp\",\n});\n\nconst clock = new THREE.Clock();\nconst frameCallbacks: (() => void)[] = [];\n\nexport function initRenderer(): void {\n  enhanceAntiAliasing();\n\n  if (DOM_ELEMENTS.mazeContainer) {\n    renderer.setSize(\n      DOM_ELEMENTS.mazeContainer.clientWidth,\n      DOM_ELEMENTS.mazeContainer.clientHeight\n    );\n    DOM_ELEMENTS.mazeContainer.appendChild(renderer.domElement);\n  } else {\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(renderer.domElement);\n  }\n\n  setPixelRatio();\n  window.addEventListener(\"resize\", setPixelRatio);\n\n  renderer.render(scene, camera);\n}\n\nfunction enhanceAntiAliasing(): void {\n  if (isMobile) {\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n  } else {\n    renderer.setPixelRatio(window.devicePixelRatio);\n  }\n  renderer.shadowMap.enabled = true;\n  renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n}\n\nfunction setPixelRatio(): void {\n  const pixelRatio = Math.min(window.devicePixelRatio, isMobile ? 2 : 3);\n  renderer.setPixelRatio(pixelRatio);\n\n  if (DOM_ELEMENTS.mazeContainer) {\n    renderer.setSize(\n      DOM_ELEMENTS.mazeContainer.clientWidth,\n      DOM_ELEMENTS.mazeContainer.clientHeight\n    );\n    camera.aspect =\n      DOM_ELEMENTS.mazeContainer.clientWidth /\n      DOM_ELEMENTS.mazeContainer.clientHeight;\n  } else {\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    camera.aspect = window.innerWidth / window.innerHeight;\n  }\n\n  camera.updateProjectionMatrix();\n}\n\nexport function setupLighting(): void {\n  const ambientLight = new THREE.AmbientLight(0xffffff);\n  scene.add(ambientLight);\n\n  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n  scene.add(directionalLight);\n  directionalLight.position.set(-5, 15, 10);\n  directionalLight.shadow.mapSize.width = 4096;\n  directionalLight.shadow.mapSize.height = 4096;\n  directionalLight.shadow.camera.left = -20;\n  directionalLight.shadow.camera.right = 20;\n  directionalLight.shadow.camera.top = 20;\n  directionalLight.shadow.camera.bottom = -20;\n  directionalLight.shadow.camera.near = 0.1;\n  directionalLight.shadow.camera.far = 50;\n  directionalLight.shadow.bias = -0.001;\n  directionalLight.shadow.radius = 3;\n  directionalLight.castShadow = true;\n}\n\nexport function createDebugLines(): void {\n  // Red line at z: 0.5, lying along x-axis at y: 0.55 (same height as ghosts)\n  const redLineGeometry = new THREE.BufferGeometry().setFromPoints([\n    new THREE.Vector3(-5, -0.55, 0),\n    new THREE.Vector3(5, -0.55, 0),\n  ]);\n  const redLineMaterial = new THREE.LineBasicMaterial({\n    color: 0xff0000,\n    linewidth: 3,\n  });\n  const redLine = new THREE.Line(redLineGeometry, redLineMaterial);\n  redLine.renderOrder = 999; // Render on top\n  scene.add(redLine);\n\n  // Green line at z: 1.5, lying along x-axis at y: 0.55 (same height as ghosts)\n  const greenLineGeometry = new THREE.BufferGeometry().setFromPoints([\n    new THREE.Vector3(-5, -0.55, 1),\n    new THREE.Vector3(5, -0.55, 1),\n  ]);\n  const greenLineMaterial = new THREE.LineBasicMaterial({\n    color: 0x00ff00,\n    linewidth: 3,\n  });\n  const greenLine = new THREE.Line(greenLineGeometry, greenLineMaterial);\n  greenLine.renderOrder = 999; // Render on top\n  scene.add(greenLine);\n}\n\nexport function startRenderLoop(): void {\n  const render = () => {\n    frameCallbacks.forEach((callback) => callback());\n\n    renderer.render(scene, camera);\n\n    requestAnimationFrame(render);\n  };\n  render();\n}\n\nexport function onFrame(callback: () => void): void {\n  frameCallbacks.push(callback);\n}\n\nexport { renderer, clock };\n","import * as THREE from \"three\";\nimport { ASSETS } from \"../config/config\";\n\nconst textureLoader = new THREE.TextureLoader();\n\nconst mazeTexture = textureLoader.load(ASSETS.mazeTexture);\n\nexport const mazeMaterial = new THREE.MeshMatcapMaterial({\n  matcap: mazeTexture,\n});\n\nexport const topMaterial = new THREE.MeshStandardMaterial({\n  color: 0xf2f9f9,\n  metalness: 0.4,\n  roughness: 0,\n  envMapIntensity: 10,\n});\n\nexport const ghostMaterial = new THREE.MeshPhysicalMaterial({\n  color: 0xffffff,\n  opacity: 1,\n  transparent: true,\n  depthWrite: false,\n  depthTest: true,\n  blending: THREE.NormalBlending,\n  side: THREE.DoubleSide,\n  roughness: 0.75,\n  metalness: 0.2,\n  transmission: 0.5,\n});\n\nexport const floorMaterial = new THREE.MeshStandardMaterial({\n  color: 0xffffff,\n  opacity: 0.8,\n  transparent: true,\n  roughness: 0.5,\n  metalness: 0.1,\n});\n\nconst pacmanMaterials = {\n  blue: new THREE.MeshBasicMaterial({\n    color: 0x1469d3,\n    transparent: true,\n    opacity: 1,\n  }),\n  white: new THREE.MeshBasicMaterial({\n    color: 0xffffff,\n    transparent: true,\n    opacity: 1,\n  }),\n  default: new THREE.MeshBasicMaterial({\n    color: 0x1469d3,\n    transparent: true,\n    opacity: 1,\n  }),\n};\n\n// @philipp - comment out the comments to change colors\n\nexport const materialMap = {\n  CAM_Pacman_Backframe: pacmanMaterials.blue,\n  \"CAM-Pacman_Bitcoin_1\": pacmanMaterials.white,\n  \"CAM-Pacman_Bitcoin_2\": pacmanMaterials.white,\n  \"CAM-Pacman_Bottom\": pacmanMaterials.blue,\n  \"CAM-Pacman_Top\": pacmanMaterials.blue,\n  \"CAM-Pacman_Eye\": pacmanMaterials.white,\n  // CAM_Pacman_Logo_1: pacmanMaterials.blue, // logo in the back, left side\n  // CAM_Pacman_Logo_2: pacmanMaterials.blue, // logo in the back, right side\n  CAM_Pacman_Logo_1: pacmanMaterials.white,\n  CAM_Pacman_Logo_2: pacmanMaterials.white,\n  \"CAM-Pacman_Shell_Boolean\": pacmanMaterials.blue,\n  \"CAM-Pacman_Shell\": pacmanMaterials.blue,\n  // \"CAM-Pacman_Bottom_electronic\": pacmanMaterials.blue,\n  // \"CAM-Pacman_Top_electronic\": pacmanMaterials.blue,\n  \"CAM-Pacman_Bottom_electronic\": pacmanMaterials.white, // bitcoin in the middle, left side\n  \"CAM-Pacman_Top_electronic\": pacmanMaterials.white, // bitcoin in the middle, right side\n  \"CAM-Pacman_Bottom_Text\": pacmanMaterials.white,\n  \"CAM-Pacman_Top_Text\": pacmanMaterials.white,\n  // \"CAM-Pacman_Bottom_Text\": pacmanMaterials.blue, // text on the bottom of pacman\n  // \"CAM-Pacman_Top_Text\": pacmanMaterials.blue, // text on the top of pacman\n  default: pacmanMaterials.blue,\n};\n","import * as THREE from \"three\";\nimport { ASSETS } from \"../config/config\";\nimport { GhostContainer } from \"../types/types\";\nimport { clock } from \"./scene\";\nimport {\n  mazeMaterial,\n  topMaterial,\n  ghostMaterial,\n  floorMaterial,\n  materialMap,\n} from \"./materials\";\n\nexport { clock };\n\nconst loader = new THREE.GLTFLoader();\n\nexport let pacmanMixer: THREE.AnimationMixer;\n\nexport const pacman = new THREE.Group();\n\nexport const ghosts: GhostContainer = {\n  pacman: pacman,\n  ghost1: new THREE.Mesh(new THREE.BufferGeometry(), ghostMaterial),\n  ghost2: new THREE.Mesh(new THREE.BufferGeometry(), ghostMaterial),\n  ghost3: new THREE.Mesh(new THREE.BufferGeometry(), ghostMaterial),\n  ghost4: new THREE.Mesh(new THREE.BufferGeometry(), ghostMaterial),\n  ghost5: new THREE.Mesh(new THREE.BufferGeometry(), ghostMaterial),\n};\n\nconst ghostContainers = {\n  Ghost_EUR: ghosts.ghost1,\n  Ghost_CHF: ghosts.ghost2,\n  Ghost_YEN: ghosts.ghost3,\n  Ghost_USD: ghosts.ghost4,\n  Ghost_GBP: ghosts.ghost5,\n};\n\n// CAM-Pacman_Shell -> should not be visible\n// CAM-Pacman_Shell_Boolean -> should not be visible\n// CAM-Pacman_Backframe -> should be visible (below the logo)\n// CAM-Pacman_Bottom -> should be visible (bottom)\n// CAM-Pacman_Bitcoin_1 -> should be visible (bitcoin in logo - left)\n// CAM-Pacman_Bitcoin_2 -> should be visible (bitcoin in logo - right)\n// CAM_Pacman_Logo_1 -> should be visible (octagon background of logo - left)\n// CAM_Pacman_Logo_2 -> should be visible (octagon background of logo - right)\n// CAM-Pacman_Eye -> should be visible (eyes)\n// CAM-Pacman_Bottom_electronic -> should be visible (bottom of bitcoin on pacman)\n// CAM-Pacman_Top_electronic -> should be visible (top of bitcoin on pacman)\n// CAM-Pacman_Bottom_Text -> should be visible (text on bottom of pacman)\n// CAM-Pacman_Top_Text -> should be visible (text on top of pacman)\n// CAM-Pacman_Top -> should be visible (top)\n\nconst greenMaterial = new THREE.MeshBasicMaterial({\n  color: 0x00ff00,\n  opacity: 1,\n  transparent: false,\n  depthWrite: true,\n  depthTest: true,\n});\n\nexport async function loadModel(scene: THREE.Scene): Promise<void> {\n  Object.values(ghosts).forEach((ghost) => scene.add(ghost));\n  scene.add(pacman);\n  return new Promise((resolve, reject) => {\n    loader.load(\n      ASSETS.mazeModel,\n      function (gltf) {\n        const model = gltf.scene;\n\n        // Print all elements in the 3D model\n        model.traverse((obj: THREE.Object3D) => {});\n\n        model.traverse((child: THREE.Object3D) => {\n          if (child.name === \"CAM-Pacman\") {\n            const children: THREE.Object3D[] = [];\n            child.traverse((subChild: THREE.Object3D) => {\n              if (\n                (subChild as any).isMesh &&\n                subChild.name !== \"CAM-Pacman_Shell\" &&\n                subChild.name !== \"CAM-Pacman_Shell_Boolean\" &&\n                subChild.name !== \"CAM-Pacman_Bitcoin_1\" &&\n                subChild.name !== \"CAM-Pacman_Bitcoin_2\"\n              ) {\n                const material =\n                  materialMap[subChild.name as keyof typeof materialMap] ||\n                  materialMap.default;\n                (subChild as THREE.Mesh).material = material;\n                children.push(subChild);\n              } else if (\n                subChild.name === \"CAM-Pacman_Shell\" ||\n                subChild.name === \"CAM-Pacman_Shell_Boolean\" ||\n                subChild.name === \"CAM-Pacman_Bitcoin_1\" ||\n                subChild.name === \"CAM-Pacman_Bitcoin_2\"\n              ) {\n                subChild.visible = false;\n              }\n            });\n\n            children.forEach((item) => ghosts.pacman.add(item));\n            ghosts.pacman.scale.set(0.05, 0.05, 0.05);\n            ghosts.pacman.rotation.set(Math.PI / 2, Math.PI / 2, Math.PI / 4);\n\n            pacmanMixer = new THREE.AnimationMixer(ghosts.pacman);\n            const pacmanActions: { [key: string]: THREE.AnimationAction } = {};\n\n            gltf.animations.forEach((clip: THREE.AnimationClip) => {\n              const action = pacmanMixer.clipAction(clip);\n\n              action.getMixer().addEventListener(\"loop\", function (e) {\n                e.action.getRoot().traverse(function (obj) {\n                  if (obj.userData && obj.userData.skipAnimation) {\n                    (obj as any).updateMorphTargets = function () {};\n                  }\n                });\n              });\n\n              pacmanActions[clip.name] = action;\n              action.setEffectiveWeight(0);\n              action.play();\n            });\n            Object.values(pacmanActions).forEach((action) => {\n              action.setEffectiveWeight(1);\n            });\n          } else if (\n            child.name &&\n            ghostContainers[child.name as keyof typeof ghostContainers]\n          ) {\n            const ghostContainer =\n              ghostContainers[child.name as keyof typeof ghostContainers];\n            const ghostGroup = new THREE.Group();\n\n            child.rotation.z = Math.PI;\n            child.rotation.x = Math.PI / 2;\n            child.scale.set(0.75, 0.75, 0.75);\n\n            const children: THREE.Object3D[] = [];\n            child.traverse((subChild: THREE.Object3D) => {\n              if ((subChild as any).isMesh) {\n                if (subChild.name && subChild.name.startsWith(\"Ghost_Mesh\")) {\n                  (subChild as THREE.Mesh).material = ghostMaterial;\n                } else if (\n                  subChild.name &&\n                  [\"EUR\", \"CHF\", \"YEN\", \"USD\", \"GBP\"].includes(subChild.name)\n                ) {\n                  subChild.visible = false;\n                }\n                children.push(subChild);\n              }\n            });\n\n            children.forEach((item) => {\n              if (\n                item.name &&\n                (item.name.includes(\"EUR\") ||\n                  item.name.startsWith(\"Ghost_Mesh\"))\n              ) {\n                item.rotation.z = Math.PI;\n                item.rotation.x = Math.PI / 2;\n              } else {\n                item.rotation.set(0, 0, 0);\n              }\n              ghostGroup.add(item);\n            });\n\n            if (ghostContainer) {\n              ghostContainer.add(ghostGroup);\n            } else {\n              console.warn(`ghostContainer for ${child.name} is undefined!`);\n            }\n          }\n\n          if ((child as any).isMesh) {\n            if (child.name === \"CAM-Arena_LowRes_Top\") {\n              (child as THREE.Mesh).material = topMaterial;\n              child.castShadow = true;\n            } else if (child.name === \"CAM-Arena_LowRes_Bottom\") {\n              (child as THREE.Mesh).material = mazeMaterial;\n              child.castShadow = true;\n            } else if (child.name === \"CAM-Floor\") {\n              const clonedChild = child.clone();\n              child.position.y = -0.1;\n              child.position.x = 0;\n              child.position.z = 0;\n              (child as THREE.Mesh).material = new THREE.MeshBasicMaterial({\n                color: 0xffffff,\n                opacity: 1,\n                transparent: false,\n                depthWrite: true,\n                depthTest: true,\n                side: THREE.FrontSide,\n              });\n              child.receiveShadow = false;\n              child.castShadow = true;\n              child.scale.set(0.5, 0.5, 0.5);\n\n              (clonedChild as THREE.Mesh).material = floorMaterial;\n              clonedChild.position.y = -0.5;\n              clonedChild.receiveShadow = true;\n              scene.add(clonedChild);\n            } else {\n              (child as THREE.Mesh).visible = false;\n            }\n          }\n        });\n\n        model.traverse(function (node: THREE.Object3D) {\n          if ((node as any).isMesh) {\n            node.castShadow = true;\n            node.receiveShadow = true;\n          }\n        });\n\n        scene.add(model);\n        model.position.set(0.5, 0.5, 0.5);\n\n        resolve();\n      },\n      function (progress: any) {},\n      function (error: any) {\n        reject(error);\n      }\n    );\n  });\n}\n","import * as THREE from \"three\";\nimport { MazePathPoint, PathPoint, CameraPathPoint } from \"../types/types\";\nimport {\n  homePaths,\n  povPaths,\n  createHomeScrollPathPoints,\n  getCameraHomeScrollPathPoints,\n} from \"./pathpoints\";\n\n// Cache for created paths\nconst pathCache = new Map<string, THREE.CurvePath<THREE.Vector3>>();\n\n// Optional utility for smoothing tangent directions when following paths\nexport class TangentSmoother {\n  private currentTangent: THREE.Vector3;\n  private smoothing: number;\n\n  constructor(initialTangent: THREE.Vector3, smoothing: number = 0.06) {\n    this.currentTangent = initialTangent.clone();\n    this.smoothing = smoothing;\n  }\n\n  update(targetTangent: THREE.Vector3): THREE.Vector3 {\n    this.currentTangent.lerp(targetTangent, this.smoothing);\n    return this.currentTangent.normalize();\n  }\n\n  reset(newTangent: THREE.Vector3): void {\n    this.currentTangent.copy(newTangent);\n  }\n\n  getCurrentTangent(): THREE.Vector3 {\n    return this.currentTangent.clone();\n  }\n\n  setSmoothingFactor(smoothing: number): void {\n    this.smoothing = Math.max(0.001, Math.min(1, smoothing));\n  }\n}\n\nfunction createMazePath(\n  pathPoints: MazePathPoint[],\n  pathName?: string\n): THREE.CurvePath<THREE.Vector3> {\n  const cacheKey = pathPoints\n    .map((p) => `${p.pos.x},${p.pos.y},${p.pos.z},${p.type},${p.arc || \"\"}`)\n    .join(\"|\");\n\n  if (pathCache.has(cacheKey)) {\n    return pathCache.get(cacheKey)!;\n  }\n\n  const path = new THREE.CurvePath<THREE.Vector3>();\n\n  let i = 0;\n  while (i < pathPoints.length - 1) {\n    const current = pathPoints[i];\n    const next = pathPoints[i + 1];\n\n    // Check if current point has curveCheckPoints\n    if (current.curveCheckPoints && current.curveCheckPoints.length > 0) {\n      // Create CatmullRomCurve3 with start point, checkpoints, and end point\n      const catmullPoints = [\n        current.pos,\n        ...current.curveCheckPoints,\n        next.pos,\n      ];\n      path.add(\n        new THREE.CatmullRomCurve3(catmullPoints, false, \"centripetal\", 0)\n      );\n    } else if (current.type === \"straight\") {\n      path.add(new THREE.LineCurve3(current.pos, next.pos));\n    } else {\n      // Create curve using existing logic\n      const midPoint = createNormalCurveMidPoint(current, next);\n      path.add(\n        new THREE.QuadraticBezierCurve3(current.pos, midPoint, next.pos)\n      );\n    }\n\n    i++;\n  }\n\n  pathCache.set(cacheKey, path);\n  return path;\n}\n\nfunction createNormalCurveMidPoint(\n  current: MazePathPoint,\n  next: MazePathPoint\n): THREE.Vector3 {\n  if (current.arc) {\n    const curveType = current.arc;\n\n    if (curveType === \"upperArc\") {\n      return new THREE.Vector3(current.pos.x, current.pos.y, next.pos.z);\n    } else if (curveType === \"lowerArc\") {\n      return new THREE.Vector3(next.pos.x, current.pos.y, current.pos.z);\n    } else if (curveType === \"forwardDownArc\") {\n      return new THREE.Vector3(current.pos.x, next.pos.y, current.pos.z);\n    }\n  }\n\n  return new THREE.Vector3(current.pos.x, current.pos.y, next.pos.z);\n}\n\nfunction createHomeScrollPath(\n  pathPoints: PathPoint[]\n): THREE.CurvePath<THREE.Vector3> {\n  const path = new THREE.CurvePath<THREE.Vector3>();\n\n  if (pathPoints.length === 3) {\n    const curve = new THREE.QuadraticBezierCurve3(\n      pathPoints[0].pos,\n      pathPoints[1].pos,\n      pathPoints[2].pos\n    );\n    path.add(curve);\n  }\n\n  return path;\n}\n\nfunction createCameraHomeScrollPath(\n  pathPoints: CameraPathPoint[]\n): THREE.CurvePath<THREE.Vector3> {\n  const path = new THREE.CurvePath<THREE.Vector3>();\n\n  if (pathPoints.length === 4) {\n    const curve = new THREE.CubicBezierCurve3(\n      pathPoints[0].pos,\n      pathPoints[1].pos,\n      pathPoints[2].pos,\n      pathPoints[3].pos\n    );\n    path.add(curve);\n  }\n\n  return path;\n}\n\nfunction createCameraPath(\n  pathPoints: CameraPathPoint[]\n): THREE.CurvePath<THREE.Vector3> {\n  const path = new THREE.CurvePath<THREE.Vector3>();\n\n  for (let i = 0; i < pathPoints.length - 1; i++) {\n    const current = pathPoints[i];\n    const next = pathPoints[i + 1];\n\n    // Check if it's a MazePathPoint-like structure\n    if (\"type\" in current && current.type === \"straight\") {\n      path.add(new THREE.LineCurve3(current.pos, next.pos));\n    } else if (\n      \"type\" in current &&\n      current.type === \"curve\" &&\n      \"arc\" in current\n    ) {\n      // Create curve using existing logic\n      const midPoint = createCameraCurveMidPoint(current, next);\n      path.add(\n        new THREE.QuadraticBezierCurve3(current.pos, midPoint, next.pos)\n      );\n    } else {\n      // Default to straight line for other types\n      path.add(new THREE.LineCurve3(current.pos, next.pos));\n    }\n  }\n\n  return path;\n}\n\nfunction createCameraCurveMidPoint(\n  current: CameraPathPoint,\n  next: CameraPathPoint\n): THREE.Vector3 {\n  if (\"arc\" in current && current.arc) {\n    const curveType = current.arc;\n\n    if (curveType === \"upperArc\") {\n      return new THREE.Vector3(current.pos.x, current.pos.y, next.pos.z);\n    } else if (curveType === \"lowerArc\") {\n      return new THREE.Vector3(next.pos.x, current.pos.y, current.pos.z);\n    } else if (curveType === \"forwardDownArc\") {\n      return new THREE.Vector3(current.pos.x, next.pos.y, current.pos.z);\n    }\n  }\n\n  return new THREE.Vector3(current.pos.x, current.pos.y, next.pos.z);\n}\n\nexport function getHomePaths(): Record<string, THREE.CurvePath<THREE.Vector3>> {\n  const paths: Record<string, THREE.CurvePath<THREE.Vector3>> = {};\n\n  Object.entries(homePaths).forEach(([key, pathPoints]) => {\n    paths[key] = createMazePath(pathPoints, key);\n  });\n\n  return paths;\n}\n\n// when scrolling, this is where the ghosts are going into the void\nexport function getHomeScrollPaths(\n  pausedPositions: Record<string, THREE.Vector3>\n): Record<string, THREE.CurvePath<THREE.Vector3>> {\n  const scrollPathPoints = createHomeScrollPathPoints(pausedPositions);\n  const cameraPathPoints = getCameraHomeScrollPathPoints();\n\n  const paths: Record<string, THREE.CurvePath<THREE.Vector3>> = {\n    camera: createCameraHomeScrollPath(cameraPathPoints),\n  };\n\n  Object.entries(scrollPathPoints).forEach(([key, pathPoints]) => {\n    paths[key] = createHomeScrollPath(pathPoints);\n  });\n\n  return paths;\n}\n\nexport function getPovPaths(): Record<string, THREE.CurvePath<THREE.Vector3>> {\n  const paths: Record<string, THREE.CurvePath<THREE.Vector3>> = {};\n\n  Object.entries(povPaths).forEach(([key, pathPoints]) => {\n    if (key === \"camera\") {\n      // Camera path uses CameraPathPoint[] and needs special handling\n      paths[key] = createMazePath(pathPoints as MazePathPoint[], key);\n    } else {\n      // Ghost paths use MazePathPoint[]\n      paths[key] = createMazePath(pathPoints as MazePathPoint[], key);\n    }\n  });\n\n  return paths;\n}\n","import * as THREE from \"three\";\n\nexport function calculateObjectOrientation(\n  object: THREE.Object3D,\n  tangent: THREE.Vector3,\n  objectType: \"pacman\" | \"ghost\" | \"camera\" = \"ghost\"\n): void {\n  if (!tangent || tangent.length() === 0) return;\n\n  const targetRotation = Math.atan2(tangent.x, tangent.z);\n\n  if (objectType === \"pacman\") {\n    object.rotation.set(\n      -(Math.PI / 2),\n      Math.PI,\n      -(targetRotation + Math.PI / 2)\n    );\n  } else if (objectType === \"ghost\") {\n    object.rotation.set(0, targetRotation, 0);\n  } else if (objectType === \"camera\") {\n    const lookAtPoint = object.position.clone().add(tangent);\n    object.lookAt(lookAtPoint);\n  }\n}\n\nexport const LAY_DOWN_QUAT_1 = new THREE.Quaternion().setFromEuler(\n  new THREE.Euler(Math.PI / 2, 0, 0)\n);\nexport const LAY_DOWN_QUAT_2 = new THREE.Quaternion().setFromEuler(\n  new THREE.Euler(-Math.PI / 2, 0, 0)\n);\n\nexport function slerpToLayDown(\n  object: THREE.Object3D,\n  startQuat: THREE.Quaternion,\n  progress: number\n) {\n  const d1 = startQuat.angleTo(LAY_DOWN_QUAT_1);\n  const d2 = startQuat.angleTo(LAY_DOWN_QUAT_2);\n  const targetQuat = d1 < d2 ? LAY_DOWN_QUAT_1 : LAY_DOWN_QUAT_2;\n\n  object.quaternion.copy(startQuat.clone().slerp(targetQuat, progress));\n}\n","import gsap from \"gsap\";\nimport * as THREE from \"three\";\nimport { camera } from \"../core/camera\";\nimport { ghosts } from \"../core/objects\";\nimport { scene } from \"../core/scene\";\nimport { slerpToLayDown } from \"./util\";\n\n/**\n * SCENE PRESETS\n *\n * This file contains preset functions for each scene that set all object properties\n * when entering a scene. Modify these functions to adjust how objects appear in each scene.\n *\n * Each preset function receives:\n * - isEntering: true when entering the scene, false when leaving\n * - scrollDirection: \"up\" | \"down\" - helps determine behavior when scenes overlap\n *\n * ============================================================================\n * WHERE TO CHANGE SETTINGS:\n * ============================================================================\n *\n * 1. INTRO SCROLL PRESET (applyIntroScrollPreset):\n *    - Position offsets: INTRO_POSITION_OFFSET (lines 142-145)\n *    - Ghost colors: ghostColors object (lines 268-274)\n *    - Scale: pacman 0.1, ghosts 1.0 (lines 286-290)\n *    - Rotation: pacman uses laying down, ghosts use laying down + 180 X (lines 190-231)\n *    - Floor plane: opacity 0 (hidden) (lines 343-353)\n *\n * 2. HOME SCROLL PRESET (applyHomeScrollPreset):\n *    - Uses paused positions/rotations from home-loop\n *    - Floor plane: visible with opacity 1 (lines 79-89)\n *\n * 3. HOME LOOP PRESET (applyHomeLoopPreset):\n *    - Scale: all objects 1.0 (lines 24-29)\n *    - Floor plane: visible with opacity 1 (lines 50-60)\n *\n * 4. POV SCROLL PRESET (applyPovScrollPreset):\n *    - Pacman: hidden (lines 300-302)\n *    - Ghost scale: 0.5 (lines 307-309)\n *    - Ghost visibility: initially false (controlled by pov-scroll.ts triggers)\n *    - Floor plane: visible with opacity 1 (lines 321-331)\n *\n * 5. OUTRO SCROLL PRESET (applyOutroScrollPreset):\n *    - Currently minimal setup (add your outro-specific settings here)\n *    - Floor plane: visible with opacity 1 (lines 378-388)\n */\n\n// ============================================================================\n// HOME LOOP PRESET\n// ============================================================================\nexport function applyHomeLoopPreset(\n  isEntering: boolean,\n  scrollDirection?: \"up\" | \"down\"\n) {\n  if (!isEntering) return;\n\n  // Home loop uses paths, so positions/rotations are handled by home-loop.ts\n  // Here we just ensure visibility and scale settings\n  // Pacman scale should be 0.05 (original model size), ghosts are 1.0\n  Object.entries(ghosts).forEach(([key, object]) => {\n    gsap.set(object, { visible: true });\n\n    if (key === \"pacman\") {\n      // CRITICAL: Pacman default scale is 0.05 (from model loading)\n      // Kill any GSAP animations that might interfere\n      gsap.killTweensOf(object.scale);\n      object.scale.set(0.05, 0.05, 0.05);\n      object.updateMatrixWorld(true);\n    } else {\n      gsap.set(object.scale, { x: 1, y: 1, z: 1 });\n    }\n\n    // Ensure all meshes are visible and opaque (except currencies)\n    object.traverse((child) => {\n      if ((child as any).isMesh && (child as any).material) {\n        const mesh = child as THREE.Mesh;\n        const childName = child.name || \"\";\n\n        // Keep currency symbols hidden in all scenes - check both exact match and includes\n        if (\n          [\"EUR\", \"CHF\", \"YEN\", \"USD\", \"GBP\"].includes(childName) ||\n          childName.includes(\"EUR\") ||\n          childName.includes(\"CHF\") ||\n          childName.includes(\"YEN\") ||\n          childName.includes(\"USD\") ||\n          childName.includes(\"GBP\")\n        ) {\n          mesh.visible = false;\n          return;\n        }\n\n        mesh.visible = true;\n\n        if (Array.isArray(mesh.material)) {\n          mesh.material.forEach((mat: any) => {\n            mat.opacity = 1;\n            mat.transparent = false;\n          });\n        } else {\n          (mesh.material as any).opacity = 1;\n          (mesh.material as any).transparent = false;\n        }\n      }\n    });\n  });\n\n  // Floor plane visible\n  scene.traverse((child) => {\n    if (child.name === \"CAM-Floor\") {\n      child.visible = true;\n      if (child instanceof THREE.Mesh && child.material) {\n        const material = child.material as THREE.MeshBasicMaterial;\n        material.color.setHex(0xffffff);\n        material.opacity = 1;\n        material.transparent = false;\n      }\n    }\n  });\n}\n\n// ============================================================================\n// HOME SCROLL PRESET\n// ============================================================================\nexport function applyHomeScrollPreset(\n  isEntering: boolean,\n  scrollDirection?: \"up\" | \"down\",\n  pausedPositions?: Record<string, THREE.Vector3>,\n  pausedRotations?: Record<string, THREE.Quaternion>\n) {\n  if (!isEntering) return;\n\n  // Use paused positions/rotations if provided (from home-loop)\n  if (pausedPositions && pausedRotations) {\n    Object.entries(ghosts).forEach(([key, object]) => {\n      if (pausedPositions[key]) {\n        gsap.set(object.position, {\n          x: pausedPositions[key].x,\n          y: pausedPositions[key].y,\n          z: pausedPositions[key].z,\n        });\n      }\n\n      if (pausedRotations[key]) {\n        object.quaternion.copy(pausedRotations[key]);\n      }\n\n      gsap.set(object, { visible: true });\n\n      // CRITICAL: Set correct scales - pacman should be 0.05 (original size), ghosts 1.0\n      if (key === \"pacman\") {\n        // Kill any GSAP animations that might interfere\n        gsap.killTweensOf(object.scale);\n        object.scale.set(0.05, 0.05, 0.05);\n        object.updateMatrixWorld(true);\n      } else {\n        gsap.set(object.scale, { x: 1, y: 1, z: 1 });\n      }\n\n      // Set opacity to 1 initially (will be animated by home-scroll.ts)\n      object.traverse((child) => {\n        if ((child as any).isMesh && (child as any).material) {\n          const mesh = child as THREE.Mesh;\n          const childName = child.name || \"\";\n\n          // Keep currency symbols hidden in all scenes\n          if ([\"EUR\", \"CHF\", \"YEN\", \"USD\", \"GBP\"].includes(childName)) {\n            mesh.visible = false;\n            return;\n          }\n\n          mesh.visible = true;\n\n          if (Array.isArray(mesh.material)) {\n            mesh.material.forEach((mat: any) => {\n              mat.opacity = 1;\n              mat.transparent = true;\n            });\n          } else {\n            (mesh.material as any).opacity = 1;\n            (mesh.material as any).transparent = true;\n          }\n        }\n      });\n    });\n  }\n\n  // Floor plane visible\n  scene.traverse((child) => {\n    if (child.name === \"CAM-Floor\") {\n      child.visible = true;\n      if (child instanceof THREE.Mesh && child.material) {\n        const material = child.material as THREE.MeshBasicMaterial;\n        material.color.setHex(0xffffff);\n        material.opacity = 1;\n        material.transparent = false;\n      }\n    }\n  });\n}\n\n// ============================================================================\n// INTRO SCROLL PRESET\n// ============================================================================\n\n// Position offsets (hardcoded from previous adjuster values)\n// Export for use in intro-scroll updates\nexport const INTRO_POSITION_OFFSET = {\n  x: 4.3,\n  y: -2.0,\n  z: 0.0,\n};\n\n// Store target quaternions for intro (calculated once)\nlet pacmanTargetQuaternion: THREE.Quaternion | null = null;\nlet ghostTargetQuaternion: THREE.Quaternion | null = null;\nlet introInitialRotations: Record<string, THREE.Quaternion> = {};\n\n// Export getters for quaternions (used by intro-scroll animation updates)\nexport function getPacmanTargetQuaternion(): THREE.Quaternion | null {\n  return pacmanTargetQuaternion;\n}\n\nexport function getGhostTargetQuaternion(): THREE.Quaternion | null {\n  return ghostTargetQuaternion;\n}\n\nexport function applyIntroScrollPreset(\n  isEntering: boolean,\n  scrollDirection?: \"up\" | \"down\"\n) {\n  if (!isEntering) return;\n\n  // Calculate target quaternions ONCE (they don't change during scroll)\n  // Rotate objects 180 degrees to match camera rotation\n  if (!pacmanTargetQuaternion || !ghostTargetQuaternion) {\n    // Create rotation quaternions once\n    const xRotation180 = new THREE.Quaternion().setFromEuler(\n      new THREE.Euler(Math.PI, 0, 0)\n    );\n\n    const pacmanObj = ghosts.pacman;\n    if (pacmanObj) {\n      if (!introInitialRotations[\"pacman\"]) {\n        introInitialRotations[\"pacman\"] = pacmanObj.quaternion.clone();\n      }\n\n      pacmanTargetQuaternion = introInitialRotations[\"pacman\"].clone();\n      slerpToLayDown(pacmanObj, introInitialRotations[\"pacman\"], 1.0);\n      // Add +90 degrees rotation on X-axis\n      const pacmanRotation90 = new THREE.Quaternion().setFromEuler(\n        new THREE.Euler(Math.PI / 2, 0, 0)\n      );\n      pacmanObj.quaternion.multiply(pacmanRotation90);\n      // Rotate 180 degrees on Y-axis to match camera rotation\n      const pacmanRotationY180 = new THREE.Quaternion().setFromEuler(\n        new THREE.Euler(0, Math.PI, 0)\n      );\n      pacmanObj.quaternion.multiply(pacmanRotationY180);\n      // Rotate another 180 degrees on Y-axis (total 360 = 0, but adds to match camera)\n      pacmanObj.quaternion.multiply(pacmanRotationY180);\n      // Rotate 180 degrees on X-axis to fix upside-down orientation\n      pacmanObj.quaternion.multiply(xRotation180);\n      pacmanTargetQuaternion = pacmanObj.quaternion.clone();\n      pacmanObj.quaternion.copy(introInitialRotations[\"pacman\"]);\n    }\n\n    const ghostObj = ghosts.ghost1;\n    if (ghostObj) {\n      if (!introInitialRotations[\"ghost1\"]) {\n        introInitialRotations[\"ghost1\"] = ghostObj.quaternion.clone();\n      }\n\n      ghostTargetQuaternion = introInitialRotations[\"ghost1\"].clone();\n      slerpToLayDown(ghostObj, introInitialRotations[\"ghost1\"], 1.0);\n      // Apply 180 degrees on X-axis (current rotation that makes heads face down)\n      ghostObj.quaternion.multiply(xRotation180);\n      // Add another 180 degrees on X-axis to flip them up\n      ghostObj.quaternion.multiply(xRotation180);\n      // Rotate 180 degrees on Y-axis to match camera rotation\n      const ghostRotationY180 = new THREE.Quaternion().setFromEuler(\n        new THREE.Euler(0, Math.PI, 0)\n      );\n      ghostObj.quaternion.multiply(ghostRotationY180);\n      // Rotate another 180 degrees on Y-axis (total 360 = 0, but adds to match camera)\n      ghostObj.quaternion.multiply(ghostRotationY180);\n      // Rotate another 180 degrees on X-axis to fix upside-down orientation\n      ghostObj.quaternion.multiply(xRotation180);\n      ghostTargetQuaternion = ghostObj.quaternion.clone();\n      ghostObj.quaternion.copy(introInitialRotations[\"ghost1\"]);\n    }\n\n    // Store initial rotations for all objects\n    [\"pacman\", \"ghost1\", \"ghost2\", \"ghost3\", \"ghost4\", \"ghost5\"].forEach(\n      (key) => {\n        const obj = ghosts[key];\n        if (obj && !introInitialRotations[key]) {\n          introInitialRotations[key] = obj.quaternion.clone();\n        }\n      }\n    );\n  }\n\n  // Calculate start position (far left)\n  const baseX = camera.position.x - 5.0;\n  const startPosition = new THREE.Vector3(\n    baseX + INTRO_POSITION_OFFSET.x,\n    camera.position.y + INTRO_POSITION_OFFSET.y,\n    camera.position.z + INTRO_POSITION_OFFSET.z\n  );\n\n  const objectsToAnimate = [\n    \"pacman\",\n    \"ghost1\",\n    \"ghost2\",\n    \"ghost3\",\n    \"ghost4\",\n    \"ghost5\",\n  ];\n\n  // Ghost colors for testing\n  const ghostColors: Record<string, number> = {\n    ghost1: 0xff0000, // Red\n    ghost2: 0x00ff00, // Green\n    ghost3: 0x0000ff, // Blue\n    ghost4: 0xffff00, // Yellow\n    ghost5: 0xff00ff, // Magenta\n  };\n\n  // Use gsap.set to immediately set all properties\n  objectsToAnimate.forEach((key, index) => {\n    const object = ghosts[key];\n    if (!object) return;\n\n    // CRITICAL: For pacman, kill ALL GSAP animations first to prevent interference\n    if (key === \"pacman\") {\n      gsap.killTweensOf(object);\n      gsap.killTweensOf(object.scale);\n      gsap.killTweensOf(object.position);\n      gsap.killTweensOf(object.quaternion);\n    }\n\n    // CRITICAL: Kill any opacity/material animations that might be interfering\n    // Traverse and kill tweens on all materials\n    object.traverse((child) => {\n      if ((child as any).isMesh && (child as any).material) {\n        const mesh = child as THREE.Mesh;\n        if (Array.isArray(mesh.material)) {\n          mesh.material.forEach((mat: any) => {\n            gsap.killTweensOf(mat);\n            gsap.killTweensOf(mat.opacity);\n          });\n        } else {\n          gsap.killTweensOf(mesh.material);\n          gsap.killTweensOf((mesh.material as any).opacity);\n        }\n      }\n    });\n\n    // Calculate position with stagger\n    const behindOffset = index === 0 ? 0 : -0.5 * index;\n    const pos = new THREE.Vector3(\n      startPosition.x + behindOffset,\n      startPosition.y,\n      startPosition.z\n    );\n\n    // Set position, rotation, scale, visibility using gsap.set\n    gsap.set(object.position, {\n      x: pos.x,\n      y: pos.y,\n      z: pos.z,\n    });\n\n    // Set rotation quaternion directly\n    if (key === \"pacman\" && pacmanTargetQuaternion) {\n      object.quaternion.copy(pacmanTargetQuaternion);\n    } else if (ghostTargetQuaternion) {\n      object.quaternion.copy(ghostTargetQuaternion);\n    }\n\n    // CRITICAL: Set pacman scale BEFORE any other operations\n    // Must be 0.1 for intro-scroll - set directly and kill any tweens\n    if (key === \"pacman\") {\n      // Force set scale immediately\n      object.scale.set(0.1, 0.1, 0.1);\n      object.updateMatrixWorld(true);\n      // Use gsap.set as backup\n      gsap.set(object.scale, { x: 0.1, y: 0.1, z: 0.1 });\n    } else {\n      object.scale.set(1.0, 1.0, 1.0);\n      object.updateMatrixWorld(true);\n      gsap.set(object.scale, { x: 1.0, y: 1.0, z: 1.0 });\n    }\n\n    gsap.set(object, { visible: true });\n\n    // CRITICAL: Set opacity and visibility for all meshes IMMEDIATELY and EXPLICITLY\n    object.traverse((child) => {\n      if ((child as any).isMesh && (child as any).material) {\n        const mesh = child as THREE.Mesh;\n        const childName = child.name || \"\";\n\n        // Keep currency symbols hidden - check both exact match and includes\n        if (\n          [\"EUR\", \"CHF\", \"YEN\", \"USD\", \"GBP\"].includes(childName) ||\n          childName.includes(\"EUR\") ||\n          childName.includes(\"CHF\") ||\n          childName.includes(\"YEN\") ||\n          childName.includes(\"USD\") ||\n          childName.includes(\"GBP\")\n        ) {\n          mesh.visible = false;\n          return;\n        }\n\n        // For pacman: hide Shell and Bitcoin parts\n        if (\n          key === \"pacman\" &&\n          (childName.includes(\"Shell\") ||\n            childName.includes(\"Bitcoin_1\") ||\n            childName.includes(\"Bitcoin_2\"))\n        ) {\n          mesh.visible = false;\n          return;\n        }\n\n        // CRITICAL: Force visibility and opacity IMMEDIATELY\n        mesh.visible = true;\n\n        // Set opacity DIRECTLY on material (not via GSAP to ensure immediate effect)\n        if (Array.isArray(mesh.material)) {\n          mesh.material.forEach((mat: any) => {\n            mat.opacity = 1;\n            mat.transparent = true;\n            // Force material update\n            if (mat.needsUpdate !== undefined) {\n              mat.needsUpdate = true;\n            }\n          });\n        } else {\n          const mat = mesh.material as any;\n          mat.opacity = 1;\n          mat.transparent = true;\n          // Force material update\n          if (mat.needsUpdate !== undefined) {\n            mat.needsUpdate = true;\n          }\n        }\n\n        // Set ghost colors\n        if (ghostColors[key] && key !== \"pacman\") {\n          const newColor = ghostColors[key];\n          if (Array.isArray(mesh.material)) {\n            mesh.material.forEach((mat: any) => {\n              mat.color.setHex(newColor);\n            });\n          } else {\n            (mesh.material as any).color.setHex(newColor);\n          }\n        }\n      }\n    });\n\n    object.updateMatrixWorld(true);\n  });\n\n  // Hide floor plane (white with opacity 0)\n  scene.traverse((child) => {\n    if (child.name === \"CAM-Floor\") {\n      child.visible = true;\n      if (child instanceof THREE.Mesh && child.material) {\n        const material = child.material as THREE.MeshBasicMaterial;\n        material.color.setHex(0xffffff);\n        material.opacity = 0;\n        material.transparent = true;\n      }\n    }\n  });\n}\n\n// ============================================================================\n// POV SCROLL PRESET\n// ============================================================================\nexport function applyPovScrollPreset(\n  isEntering: boolean,\n  scrollDirection?: \"up\" | \"down\"\n) {\n  if (!isEntering) return;\n\n  // Hide pacman during POV section\n  if (ghosts.pacman) {\n    gsap.set(ghosts.pacman, { visible: false });\n  }\n\n  // Ghosts are positioned by pov-scroll.ts, but set initial visibility\n  Object.entries(ghosts).forEach(([key, object]) => {\n    if (key !== \"pacman\") {\n      // Initially invisible, will be shown by pov-scroll.ts when triggered\n      gsap.set(object, { visible: false });\n      gsap.set(object.scale, { x: 0.5, y: 0.5, z: 0.5 });\n\n      // Reset opacity\n      object.traverse((child) => {\n        if ((child as any).isMesh && (child as any).material) {\n          const mesh = child as THREE.Mesh;\n          if (Array.isArray(mesh.material)) {\n            mesh.material.forEach((mat: any) => {\n              mat.opacity = 1;\n              mat.transparent = true;\n            });\n          } else {\n            (mesh.material as any).opacity = 1;\n            (mesh.material as any).transparent = true;\n          }\n        }\n      });\n    }\n  });\n\n  // Floor plane visible\n  scene.traverse((child) => {\n    if (child.name === \"CAM-Floor\") {\n      child.visible = true;\n      if (child instanceof THREE.Mesh && child.material) {\n        const material = child.material as THREE.MeshBasicMaterial;\n        material.color.setHex(0xffffff);\n        material.opacity = 1;\n        material.transparent = false;\n      }\n    }\n  });\n}\n\n// ============================================================================\n// OUTRO SCROLL PRESET\n// ============================================================================\nexport function applyOutroScrollPreset(\n  isEntering: boolean,\n  scrollDirection?: \"up\" | \"down\"\n) {\n  if (!isEntering) return;\n\n  // Outro scroll doesn't manipulate 3D objects directly\n  // This is where you can add any outro-specific object settings\n\n  // Floor plane visible\n  scene.traverse((child) => {\n    if (child.name === \"CAM-Floor\") {\n      child.visible = true;\n      if (child instanceof THREE.Mesh && child.material) {\n        const material = child.material as THREE.MeshBasicMaterial;\n        material.color.setHex(0xffffff);\n        material.opacity = 1;\n        material.transparent = false;\n      }\n    }\n  });\n}\n\n// ============================================================================\n// UTILITY: Get scroll direction\n// ============================================================================\nlet lastScrollY = window.scrollY;\nexport function getScrollDirection(): \"up\" | \"down\" {\n  const currentScrollY = window.scrollY;\n  const direction = currentScrollY > lastScrollY ? \"down\" : \"up\";\n  lastScrollY = currentScrollY;\n  return direction;\n}\n\n// ============================================================================\n// UTILITY: Reset all preset caches (call when needed)\n// ============================================================================\nexport function resetPresetCaches() {\n  pacmanTargetQuaternion = null;\n  ghostTargetQuaternion = null;\n  introInitialRotations = {};\n}\n","import gsap from \"gsap\";\nimport * as THREE from \"three\";\nimport { camera } from \"../core/camera\";\nimport { ghosts, pacman } from \"../core/objects\";\nimport { getCameraHomeScrollPathPoints } from \"../paths/pathpoints\";\nimport { getHomeScrollPaths } from \"../paths/paths\";\nimport { homeLoopHandler } from \"./home-loop\";\nimport { slerpToLayDown } from \"./util\";\nimport { applyHomeScrollPreset, getScrollDirection } from \"./scene-presets\";\n\nlet homeScrollTimeline: gsap.core.Timeline | null = null;\nconst originalFOV = 50;\n\n// Track previous camera rotation to detect 180-degree changes\nlet previousCameraRotation: THREE.Euler | null = null;\n\nfunction checkAndLogCameraRotationChange(context: string) {\n  const currentRotation = camera.rotation.clone();\n  \n  if (previousCameraRotation) {\n    // Calculate difference in radians for each axis\n    const diffX = Math.abs(currentRotation.x - previousCameraRotation.x);\n    const diffY = Math.abs(currentRotation.y - previousCameraRotation.y);\n    const diffZ = Math.abs(currentRotation.z - previousCameraRotation.z);\n    \n    // Normalize differences to account for wrapping (e.g., 359 to 1 = 2, not 358)\n    const normalizedDiffX = Math.min(diffX, Math.PI * 2 - diffX);\n    const normalizedDiffY = Math.min(diffY, Math.PI * 2 - diffY);\n    const normalizedDiffZ = Math.min(diffZ, Math.PI * 2 - diffZ);\n    \n    // Check if any axis changed by approximately 180 degrees (Math.PI radians)\n    const PI_THRESHOLD = Math.PI * 0.9; // Allow some tolerance (90% of 180)\n    const has180DegreeChange = \n      normalizedDiffX >= PI_THRESHOLD || \n      normalizedDiffY >= PI_THRESHOLD || \n      normalizedDiffZ >= PI_THRESHOLD;\n    \n    if (has180DegreeChange) {\n      // Camera rotation change detected (logging removed)\n    }\n  }\n  \n  previousCameraRotation = currentRotation.clone();\n}\n\nconst characterSpeeds: Record<string, number> = {\n  pacman: 0.9,\n  ghost1: 1,\n  ghost2: 1.1,\n  ghost3: 1.2,\n  ghost4: 1.3,\n  ghost5: 1.4,\n};\n\nexport function initHomeScrollAnimation(\n  pausedPositions: Record<string, THREE.Vector3>,\n  pausedRotations: Record<string, THREE.Quaternion>\n) {\n  if (homeScrollTimeline) {\n    homeScrollTimeline.kill();\n    homeScrollTimeline = null;\n  }\n\n  const scrollPaths = getHomeScrollPaths(pausedPositions);\n  const cameraPathPoints = getCameraHomeScrollPathPoints();\n\n  homeScrollTimeline = gsap\n    .timeline({\n      scrollTrigger: {\n        id: \"homeScroll\",\n        trigger: \".sc--home\",\n        start: \"top top\",\n        end: \"bottom top\",\n        scrub: 0.5,\n        onEnter: () => {\n          const scrollDir = getScrollDirection();\n          applyHomeScrollPreset(true, scrollDir, pausedPositions, pausedRotations);\n        },\n        onEnterBack: () => {\n          const scrollDir = getScrollDirection();\n          applyHomeScrollPreset(true, scrollDir, pausedPositions, pausedRotations);\n        },\n        onScrubComplete: () => {\n          homeLoopHandler();\n        },\n      },\n    })\n    .to(\n      { progress: 0 },\n      {\n        progress: 1,\n        immediateRender: false,\n        onUpdate: function () {\n          const progress = this.targets()[0].progress;\n          camera.fov = originalFOV;\n          camera.updateProjectionMatrix();\n          updateScrollAnimation(\n            progress,\n            scrollPaths,\n            pausedRotations,\n            cameraPathPoints\n          );\n        },\n      }\n    );\n}\n\nfunction updateScrollAnimation(\n  progress: number,\n  paths: Record<string, THREE.CurvePath<THREE.Vector3>>,\n  pausedRotations: Record<string, THREE.Quaternion>,\n  cameraPathPoints: any[]\n) {\n  // CRITICAL: Check if intro-scroll is active - if so, don't update objects\n  // This prevents conflicts when scrolling between sections\n  const introScrollTrigger = gsap.getById(\"introScroll\");\n  const isIntroScrollActive = introScrollTrigger && introScrollTrigger.isActive;\n  \n  // Camera animation (unchanged)\n  if (paths.camera) {\n    const cameraPoint = paths.camera.getPointAt(progress);\n    camera.position.copy(cameraPoint);\n\n    const lookAtCurve = new THREE.CubicBezierCurve3(\n      cameraPathPoints[0].lookAt,\n      cameraPathPoints[1].lookAt,\n      cameraPathPoints[2].lookAt,\n      cameraPathPoints[3].lookAt\n    );\n    const lookAtPoint = lookAtCurve.getPoint(progress);\n    camera.lookAt(lookAtPoint);\n    checkAndLogCameraRotationChange(\"home-scroll (via lookAt)\");\n    camera.updateProjectionMatrix();\n  }\n\n  // CRITICAL: Don't update object opacity/position if intro-scroll is active\n  if (isIntroScrollActive) {\n    return;\n  }\n\n  // Opacity calculation (unchanged)\n  const fadeStartProgress = 0.85;\n  const fadeEndProgress = 0.95;\n  const opacity =\n    progress < fadeStartProgress\n      ? 1\n      : progress > fadeEndProgress\n      ? 0\n      : 1 -\n        (progress - fadeStartProgress) / (fadeEndProgress - fadeStartProgress);\n\n  // Apply smooth easing to rotation progress (bidirectional - reverses when scrolling up)\n  const rotationProgress = Math.pow(progress, 1.5);\n\n  // Pacman animation\n  if (paths.pacman && pacman) {\n    const pacmanSpeed = characterSpeeds[\"pacman\"] ?? 1.0;\n    const rawPacmanProgress = Math.min(progress * pacmanSpeed, 1);\n    const easedPacmanProgress = Math.pow(rawPacmanProgress, 1.25);\n    const pacmanPoint = paths.pacman.getPointAt(easedPacmanProgress);\n\n    if (pacmanPoint) {\n      pacman.position.copy(pacmanPoint);\n\n      // Apply bidirectional laying down animation\n      slerpToLayDown(pacman, pausedRotations[\"pacman\"], rotationProgress);\n\n      // Animate pacman opacity - traverse all nested meshes\n      pacman.traverse((child) => {\n        if ((child as any).isMesh && (child as any).material) {\n          const mesh = child as THREE.Mesh;\n          if (Array.isArray(mesh.material)) {\n            mesh.material.forEach((mat: any) => {\n              mat.opacity = opacity;\n              mat.transparent = true;\n            });\n          } else {\n            (mesh.material as any).opacity = opacity;\n            (mesh.material as any).transparent = true;\n          }\n        }\n      });\n    }\n  }\n\n  // Ghosts animation\n  Object.entries(ghosts).forEach(([key, ghost]) => {\n    const path = paths[key];\n    if (path) {\n      const ghostSpeed = characterSpeeds[key] ?? 1.0;\n      const rawGhostProgress = Math.min(progress * ghostSpeed, 1);\n      const easedGhostProgress = Math.pow(rawGhostProgress, 1.25);\n      const ghostPoint = path.getPointAt(easedGhostProgress);\n\n      if (ghostPoint) {\n        ghost.position.copy(ghostPoint);\n\n        // Apply bidirectional laying down animation\n        slerpToLayDown(ghost, pausedRotations[key], rotationProgress);\n\n      // Animate ghost opacity - traverse all nested meshes\n      ghost.traverse((child) => {\n        if ((child as any).isMesh && (child as any).material) {\n          const mesh = child as THREE.Mesh;\n          if (Array.isArray(mesh.material)) {\n            mesh.material.forEach((mat: any) => {\n              mat.opacity = opacity;\n              mat.transparent = true;\n            });\n          } else {\n            (mesh.material as any).opacity = opacity;\n            (mesh.material as any).transparent = true;\n          }\n        }\n      });\n      }\n    }\n  });\n}\n","import * as THREE from \"three\";\nimport { ghosts, pacmanMixer } from \"../core/objects\";\nimport { clock, onFrame } from \"../core/scene\";\nimport { getHomePaths, TangentSmoother } from \"../paths/paths\";\nimport { initHomeScrollAnimation } from \"./home-scroll\";\nimport { calculateObjectOrientation } from \"./util\";\nimport { applyHomeLoopPreset } from \"./scene-presets\";\n\nconst LOOP_DURATION = 50;\nconst ROTATION_TRANSITION_DURATION = 1.5; // Seconds to transition from laying down to upright\nlet isHomeLoopActive = true;\nlet animationTime = 0;\nlet pausedT = 0;\nlet pausedPositions: Record<string, THREE.Vector3> = {};\nlet pausedRotations: Record<string, THREE.Quaternion> = {};\nlet homeLoopFrameRegistered = false;\nlet rotationTransitionTime = 0;\nlet startRotations: Record<string, THREE.Quaternion> = {};\nlet hasBeenPausedBefore = false; // Track if we've ever stopped the loop (i.e., scrolled)\n\n// Tangent smoothers for home loop (separate from scroll smoothers)\nconst homeLoopTangentSmoothers: Record<string, TangentSmoother> = {};\n\n// Initialize home loop tangent smoothers\nfunction initializeHomeLoopTangentSmoothers() {\n  homeLoopTangentSmoothers.pacman = new TangentSmoother(\n    new THREE.Vector3(1, 0, 0),\n    0.06\n  );\n  homeLoopTangentSmoothers.ghost1 = new TangentSmoother(\n    new THREE.Vector3(1, 0, 0),\n    0.06\n  );\n  homeLoopTangentSmoothers.ghost2 = new TangentSmoother(\n    new THREE.Vector3(1, 0, 0),\n    0.06\n  );\n  homeLoopTangentSmoothers.ghost3 = new TangentSmoother(\n    new THREE.Vector3(1, 0, 0),\n    0.06\n  );\n  homeLoopTangentSmoothers.ghost4 = new TangentSmoother(\n    new THREE.Vector3(1, 0, 0),\n    0.06\n  );\n  homeLoopTangentSmoothers.ghost5 = new TangentSmoother(\n    new THREE.Vector3(1, 0, 0),\n    0.06\n  );\n}\n\nfunction stopHomeLoop() {\n  if (!isHomeLoopActive) return;\n  isHomeLoopActive = false;\n  hasBeenPausedBefore = true; // Mark that we've paused (scrolled)\n  pausedT = (animationTime % LOOP_DURATION) / LOOP_DURATION;\n  pausedPositions = {};\n  pausedRotations = {};\n\n  const homePaths = getHomePaths();\n  Object.entries(ghosts).forEach(([key, ghost]) => {\n    pausedPositions[key] = ghost.position.clone();\n\n    // Store the target tangent-based rotation, not the current transitioning rotation\n    const path = homePaths[key];\n    if (path && homeLoopTangentSmoothers[key]) {\n      const rawTangent = path.getTangentAt(pausedT);\n      if (rawTangent && rawTangent.length() > 0) {\n        const smoothTangent = homeLoopTangentSmoothers[key].getCurrentTangent();\n        const objectType = key === \"pacman\" ? \"pacman\" : \"ghost\";\n\n        // Create temp object to calculate target quaternion\n        const tempObject = new THREE.Object3D();\n        calculateObjectOrientation(tempObject, smoothTangent, objectType);\n        pausedRotations[key] = tempObject.quaternion.clone();\n      } else {\n        pausedRotations[key] = ghost.quaternion.clone();\n      }\n    } else {\n      pausedRotations[key] = ghost.quaternion.clone();\n    }\n  });\n  initHomeScrollAnimation(pausedPositions, pausedRotations);\n}\n\nfunction startHomeLoop() {\n  isHomeLoopActive = true;\n  animationTime = pausedT * LOOP_DURATION;\n  rotationTransitionTime = 0;\n  startRotations = {};\n\n  // Apply home loop preset\n  applyHomeLoopPreset(true);\n\n  // Initialize smooth tangent smoothers for home loop\n  initializeHomeLoopTangentSmoothers();\n\n  const homePaths = getHomePaths();\n  Object.entries(ghosts).forEach(([key, ghost]) => {\n    const path = homePaths[key];\n    if (path) {\n      // Only store current rotation for transition if we're returning from scroll\n      if (hasBeenPausedBefore) {\n        startRotations[key] = ghost.quaternion.clone();\n      }\n\n      const position = path.getPointAt(0);\n      if (position) ghost.position.copy(position);\n      if (key !== \"pacman\") {\n        ghost.visible = true;\n        ghost.scale.set(1, 1, 1);\n      } else {\n        // CRITICAL: Pacman scale should be 0.05 (original model size)\n        ghost.scale.set(0.05, 0.05, 0.05);\n      }\n\n      // Reset the smoother with initial tangent\n      if (homeLoopTangentSmoothers[key]) {\n        const initialTangent = path.getTangentAt(0);\n        if (initialTangent) {\n          homeLoopTangentSmoothers[key].reset(initialTangent);\n        }\n      }\n    }\n  });\n\n  if (!homeLoopFrameRegistered) {\n    onFrame(() => updateHomeLoop(clock.getDelta()));\n    homeLoopFrameRegistered = true;\n  }\n}\n\nfunction updateHomeLoop(delta: number) {\n  if (!isHomeLoopActive) return;\n  animationTime += delta;\n  rotationTransitionTime += delta;\n\n  const t = (animationTime % LOOP_DURATION) / LOOP_DURATION;\n  const homePaths = getHomePaths();\n  if (pacmanMixer) {\n    pacmanMixer.update(delta);\n  }\n\n  // Calculate rotation transition progress (0 to 1 over ROTATION_TRANSITION_DURATION)\n  // Only transition if we've been paused before (returning from scroll)\n  const transitionProgress = Math.min(\n    rotationTransitionTime / ROTATION_TRANSITION_DURATION,\n    1\n  );\n  const isTransitioning = hasBeenPausedBefore && transitionProgress < 1;\n\n  Object.entries(ghosts).forEach(([key, ghost]) => {\n    const path = homePaths[key];\n    if (path) {\n      const position = path.getPointAt(t);\n      if (position) ghost.position.copy(position);\n\n      // CRITICAL: Maintain correct scale every frame\n      // Pacman should be 0.05 (original model size), ghosts should be 1.0\n      if (key === \"pacman\") {\n        ghost.scale.set(0.05, 0.05, 0.05);\n      } else {\n        ghost.scale.set(1.0, 1.0, 1.0);\n      }\n\n      // Calculate target rotation from path tangent\n      const targetQuat = new THREE.Quaternion();\n      if (homeLoopTangentSmoothers[key] && t > 0) {\n        const rawTangent = path.getTangentAt(t);\n        if (rawTangent && rawTangent.length() > 0) {\n          const smoothTangent =\n            homeLoopTangentSmoothers[key].update(rawTangent);\n          const objectType = key === \"pacman\" ? \"pacman\" : \"ghost\";\n\n          // Create a temporary object to get target quaternion\n          const tempObject = new THREE.Object3D();\n          calculateObjectOrientation(tempObject, smoothTangent, objectType);\n          targetQuat.copy(tempObject.quaternion);\n        }\n      }\n\n      // Smoothly transition from laying down rotation to upright rotation (only when returning from scroll)\n      if (isTransitioning && startRotations[key]) {\n        // Smooth easing for rotation transition\n        const easedProgress =\n          transitionProgress *\n          transitionProgress *\n          (3 - 2 * transitionProgress); // smoothstep\n        ghost.quaternion.copy(\n          startRotations[key].clone().slerp(targetQuat, easedProgress)\n        );\n      } else {\n        // After transition or on first load, use normal rotation\n        ghost.quaternion.copy(targetQuat);\n      }\n    }\n  });\n}\n\n// when scroll is 0 - home loop is running.\n// Home= pacman and ghosts moving on their paths - scroll doesn't mattermatter\nexport function homeLoopHandler() {\n  if (window.scrollY === 0) {\n    startHomeLoop();\n  }\n}\n\nexport function setupHomeLoopScrollHandler() {\n  window.addEventListener(\"scroll\", () => {\n    if (window.scrollY !== 0) {\n      stopHomeLoop();\n    }\n  });\n}\n","import gsap from \"gsap\";\nimport ScrollTrigger from \"gsap/ScrollTrigger\";\nimport * as THREE from \"three\";\nimport { camera } from \"../core/camera\";\nimport { ghosts } from \"../core/objects\";\nimport { getPovPaths, TangentSmoother } from \"../paths/paths\";\nimport {\n  povTriggerPositions,\n  povPaths as pathPointsData,\n} from \"../paths/pathpoints\";\nimport { DOM_ELEMENTS } from \"../config/dom-elements\";\nimport { calculateObjectOrientation } from \"./util\";\nimport { applyPovScrollPreset, getScrollDirection } from \"./scene-presets\";\n\ngsap.registerPlugin(ScrollTrigger);\n\nlet povScrollTimeline: gsap.core.Timeline | null = null;\n\n// Track previous camera rotation to detect 180-degree changes\nlet previousCameraRotation: THREE.Euler | null = null;\n\nfunction checkAndLogCameraRotationChange(context: string) {\n  const currentRotation = camera.rotation.clone();\n\n  if (previousCameraRotation) {\n    // Calculate difference in radians for each axis\n    const diffX = Math.abs(currentRotation.x - previousCameraRotation.x);\n    const diffY = Math.abs(currentRotation.y - previousCameraRotation.y);\n    const diffZ = Math.abs(currentRotation.z - previousCameraRotation.z);\n\n    // Normalize differences to account for wrapping (e.g., 359 to 1 = 2, not 358)\n    const normalizedDiffX = Math.min(diffX, Math.PI * 2 - diffX);\n    const normalizedDiffY = Math.min(diffY, Math.PI * 2 - diffY);\n    const normalizedDiffZ = Math.min(diffZ, Math.PI * 2 - diffZ);\n\n    // Check if any axis changed by approximately 180 degrees (Math.PI radians)\n    const PI_THRESHOLD = Math.PI * 0.9; // Allow some tolerance (90% of 180)\n    const has180DegreeChange =\n      normalizedDiffX >= PI_THRESHOLD ||\n      normalizedDiffY >= PI_THRESHOLD ||\n      normalizedDiffZ >= PI_THRESHOLD;\n\n    if (has180DegreeChange) {\n      // Camera rotation change detected (logging removed)\n    }\n  }\n\n  previousCameraRotation = currentRotation.clone();\n}\n\n// Animation state\nlet previousCameraPosition: THREE.Vector3 | null = null;\nlet rotationStarted = false;\nlet startedInitEndScreen = false;\nlet endScreenPassed = false;\n\n// Camera rotation constants\nconst startRotationPoint = new THREE.Vector3(0.55675, 0.55, 1.306);\nconst endRotationPoint = new THREE.Vector3(-0.14675, 1, 1.8085);\nconst finalLookAt = new THREE.Vector3(-0.14675, 0, 1.8085);\n\n// Animation timing constants\nconst wideFOV = 80;\n\n// Cached values\nlet cachedStartYAngle: number | null = null;\n\n// Ghost trigger state\nconst ghostStates: Record<string, any> = {};\n\n// Tangent smoothers for POV scroll (separate from home loop smoothers)\nconst povTangentSmoothers: Record<string, TangentSmoother> = {};\n\n// Initialize POV tangent smoothers\nfunction initializePovTangentSmoothers() {\n  // Camera smoother - most important for smooth user experience\n  povTangentSmoothers.camera = new TangentSmoother(\n    new THREE.Vector3(0, 0, -1),\n    0.08\n  );\n\n  // Ghost smoothers\n  povTangentSmoothers.ghost1 = new TangentSmoother(\n    new THREE.Vector3(1, 0, 0),\n    0.08\n  );\n  povTangentSmoothers.ghost2 = new TangentSmoother(\n    new THREE.Vector3(1, 0, 0),\n    0.08\n  );\n  povTangentSmoothers.ghost3 = new TangentSmoother(\n    new THREE.Vector3(1, 0, 0),\n    0.08\n  );\n  povTangentSmoothers.ghost4 = new TangentSmoother(\n    new THREE.Vector3(1, 0, 0),\n    0.08\n  );\n  povTangentSmoothers.ghost5 = new TangentSmoother(\n    new THREE.Vector3(1, 0, 0),\n    0.08\n  );\n}\n\nexport function initPovScrollAnimation() {\n  if (povScrollTimeline) {\n    povScrollTimeline.kill();\n    povScrollTimeline = null;\n  }\n\n  // Initialize tangent smoothers for POV scroll\n  initializePovTangentSmoothers();\n\n  // Initialize ghost states\n  Object.keys(povTriggerPositions).forEach((key) => {\n    ghostStates[key] = {\n      hasBeenTriggered: false,\n      hasBeenDeactivated: false,\n      triggerCameraProgress: null,\n      ghostStartFadeInProgress: null,\n      ghostEndFadeInProgress: null,\n      ghostStartFadeOutProgress: null,\n      camStartFadeInProgress: null,\n      camEndFadeInProgress: null,\n      camStartFadeOutProgress: null,\n      endCameraProgress: null,\n      currentPathT: 0,\n      ghostTextOpacity: 0,\n      camTextOpacity: 0,\n      lastProgress: 0,\n    };\n  });\n\n  povScrollTimeline = gsap\n    .timeline({\n      scrollTrigger: {\n        id: \"povScroll\",\n        trigger: DOM_ELEMENTS.povSection,\n        start: \"top bottom\",\n        end: \"bottom top\",\n        markers: true,\n        scrub: 0.5,\n        toggleActions: \"play none none reverse\",\n        onEnter: () => {\n          const scrollDir = getScrollDirection();\n          applyPovScrollPreset(true, scrollDir);\n        },\n        onEnterBack: () => {\n          const scrollDir = getScrollDirection();\n          applyPovScrollPreset(true, scrollDir);\n        },\n      },\n    })\n    .to(\n      { progress: 0 },\n      {\n        progress: 1,\n        immediateRender: false,\n        onStart: () => {},\n        onUpdate: function () {\n          const progress = (this.targets()[0] as any).progress;\n          // Placeholder - full implementation needed\n        },\n        onReverseComplete: () => {\n          // Reset state\n        },\n        onComplete: () => {\n          // Reset state\n        },\n      }\n    );\n}\n","import gsap from \"gsap\";\nimport ScrollTrigger from \"gsap/ScrollTrigger\";\nimport * as THREE from \"three\";\nimport { camera } from \"../core/camera\";\nimport { ghosts } from \"../core/objects\";\nimport { scene } from \"../core/scene\";\nimport {\n  applyIntroScrollPreset,\n  getScrollDirection,\n  getPacmanTargetQuaternion,\n  getGhostTargetQuaternion,\n  INTRO_POSITION_OFFSET,\n} from \"./scene-presets\";\n\n// Debug helper function to check visibility issues\nfunction debugObjectVisibility(key: string, object: THREE.Object3D) {\n  const info: any = {\n    key,\n    exists: !!object,\n    visible: object?.visible,\n    scale: object?.scale\n      ? `${object.scale.x.toFixed(2)}, ${object.scale.y.toFixed(\n          2\n        )}, ${object.scale.z.toFixed(2)}`\n      : \"N/A\",\n    position: object?.position\n      ? `${object.position.x.toFixed(2)}, ${object.position.y.toFixed(\n          2\n        )}, ${object.position.z.toFixed(2)}`\n      : \"N/A\",\n    meshCount: 0,\n    visibleMeshCount: 0,\n    hiddenMeshCount: 0,\n    meshes: [] as string[],\n  };\n\n  if (object) {\n    object.traverse((child) => {\n      if ((child as any).isMesh) {\n        info.meshCount++;\n        const mesh = child as THREE.Mesh;\n        const childName = child.name || \"unnamed\";\n\n        if (mesh.visible) {\n          info.visibleMeshCount++;\n        } else {\n          info.hiddenMeshCount++;\n        }\n\n        const meshInfo = {\n          name: childName,\n          visible: mesh.visible,\n          material: mesh.material\n            ? Array.isArray(mesh.material)\n              ? `Array[${mesh.material.length}]`\n              : mesh.material.type\n            : \"No material\",\n          opacity:\n            (mesh.material as any)?.opacity !== undefined\n              ? (mesh.material as any).opacity\n              : \"N/A\",\n        };\n        info.meshes.push(meshInfo);\n      }\n    });\n  }\n\n  return info;\n}\n\n// Check if object is in camera frustum\nfunction isInCameraFrustum(object: THREE.Object3D): boolean {\n  const frustum = new THREE.Frustum();\n  const matrix = new THREE.Matrix4().multiplyMatrices(\n    camera.projectionMatrix,\n    camera.matrixWorldInverse\n  );\n  frustum.setFromProjectionMatrix(matrix);\n  return frustum.containsPoint(object.position);\n}\n\nlet introScrollTimeline: gsap.core.Timeline | null = null;\nlet isIntroScrollActive = false;\nlet lastIntroProgress = 0;\nlet isUpdating = false; // Prevent concurrent updates\nlet lastUpdateTime = 0; // Throttle updates to prevent flickering\nlet cachedObjectStates: Record<string, { opacity: number; visible: boolean }> =\n  {}; // Cache to avoid redundant updates\n\nexport function initIntroScrollAnimation() {\n  // Kill any existing timeline\n  if (introScrollTimeline) {\n    introScrollTimeline.kill();\n    introScrollTimeline = null;\n  }\n\n  introScrollTimeline = gsap\n    .timeline({\n      scrollTrigger: {\n        trigger: \".sc--intro\",\n        start: \"top top\",\n        end: \"bottom bottom\",\n        scrub: 0.5,\n        refreshPriority: 1,\n        onEnter: () => {\n          isIntroScrollActive = true;\n\n          // CRITICAL: Kill any home-scroll animations that might interfere\n          const homeScrollTrigger = gsap.getById(\"homeScroll\");\n          if (homeScrollTrigger) {\n            const homeTimeline = (homeScrollTrigger as any).timeline;\n            if (homeTimeline && homeTimeline.pause) {\n              homeTimeline.pause();\n            }\n          }\n\n          // CRITICAL: Kill any pov-scroll animations that might interfere\n          const povScrollTrigger = ScrollTrigger.getById(\"povScroll\");\n          if (povScrollTrigger) {\n            const povTimeline = (povScrollTrigger as any).timeline;\n            if (povTimeline && povTimeline.pause) {\n              povTimeline.pause();\n            }\n          }\n\n          // Kill any GSAP animations on objects\n          [\"pacman\", \"ghost1\", \"ghost2\", \"ghost3\", \"ghost4\", \"ghost5\"].forEach(\n            (key) => {\n              const obj = ghosts[key];\n              if (obj) {\n                gsap.killTweensOf(obj);\n                gsap.killTweensOf(obj.scale);\n                gsap.killTweensOf(obj.position);\n                gsap.killTweensOf(obj.quaternion);\n\n                // CRITICAL: Immediately set visibility and opacity to ensure objects are visible\n                // This overrides any opacity/visibility set by home-scroll\n                // Must traverse ALL nested meshes to restore visibility\n                obj.visible = true;\n                obj.traverse((child) => {\n                  if ((child as any).isMesh && (child as any).material) {\n                    const mesh = child as THREE.Mesh;\n                    const childName = child.name || \"\";\n\n                    // Skip currency symbols and pacman parts - they stay hidden\n                    if (\n                      [\"EUR\", \"CHF\", \"YEN\", \"USD\", \"GBP\"].includes(childName) ||\n                      childName.includes(\"EUR\") ||\n                      childName.includes(\"CHF\") ||\n                      childName.includes(\"YEN\") ||\n                      childName.includes(\"USD\") ||\n                      childName.includes(\"GBP\") ||\n                      (key === \"pacman\" &&\n                        (childName.includes(\"Shell\") ||\n                          childName.includes(\"Bitcoin_1\") ||\n                          childName.includes(\"Bitcoin_2\")))\n                    ) {\n                      return; // Skip these, keep them hidden\n                    }\n\n                    // Force visibility and opacity for all other meshes\n                    mesh.visible = true;\n                    if (Array.isArray(mesh.material)) {\n                      mesh.material.forEach((mat: any) => {\n                        mat.opacity = 1;\n                        mat.transparent = true;\n                      });\n                    } else {\n                      (mesh.material as any).opacity = 1;\n                      (mesh.material as any).transparent = true;\n                    }\n                  }\n                });\n\n                // Force update matrix to ensure changes are applied\n                obj.updateMatrixWorld(true);\n              }\n            }\n          );\n\n          const scrollDir = getScrollDirection();\n          applyIntroScrollPreset(true, scrollDir);\n\n          // CRITICAL: After preset is applied, FORCE visibility again to ensure objects are visible\n          // This is necessary because home-scroll makes objects invisible (opacity 0 or visible false)\n          [\"pacman\", \"ghost1\", \"ghost2\", \"ghost3\", \"ghost4\", \"ghost5\"].forEach(\n            (key) => {\n              const obj = ghosts[key];\n              if (obj) {\n                obj.visible = true;\n                obj.traverse((child) => {\n                  if ((child as any).isMesh && (child as any).material) {\n                    const mesh = child as THREE.Mesh;\n                    const childName = child.name || \"\";\n\n                    // Skip currency symbols and pacman parts\n                    if (\n                      [\"EUR\", \"CHF\", \"YEN\", \"USD\", \"GBP\"].includes(childName) ||\n                      childName.includes(\"EUR\") ||\n                      childName.includes(\"CHF\") ||\n                      childName.includes(\"YEN\") ||\n                      childName.includes(\"USD\") ||\n                      childName.includes(\"GBP\") ||\n                      (key === \"pacman\" &&\n                        (childName.includes(\"Shell\") ||\n                          childName.includes(\"Bitcoin_1\") ||\n                          childName.includes(\"Bitcoin_2\")))\n                    ) {\n                      return;\n                    }\n\n                    mesh.visible = true;\n                    if (Array.isArray(mesh.material)) {\n                      mesh.material.forEach((mat: any) => {\n                        mat.opacity = 1;\n                        mat.transparent = true;\n                      });\n                    } else {\n                      (mesh.material as any).opacity = 1;\n                      (mesh.material as any).transparent = true;\n                    }\n                  }\n                });\n                obj.updateMatrixWorld(true);\n              }\n            }\n          );\n\n          // CRITICAL: Reset update flags to ensure first update runs\n          isUpdating = false;\n          lastUpdateTime = 0;\n          cachedObjectStates = {};\n\n          // Immediately update objects to ensure they're visible and at correct position\n          // Call synchronously first, then also in requestAnimationFrame for safety\n          const scrollTrigger = ScrollTrigger.getById(\"introScroll\");\n          if (scrollTrigger && typeof scrollTrigger.progress === \"number\") {\n            lastIntroProgress = scrollTrigger.progress;\n            updateObjectsWalkBy(scrollTrigger.progress);\n          } else {\n            lastIntroProgress = 0;\n            updateObjectsWalkBy(0);\n          }\n\n          // Also call in requestAnimationFrame to ensure it runs after any pending updates\n          requestAnimationFrame(() => {\n            const scrollTrigger = ScrollTrigger.getById(\"introScroll\");\n            if (scrollTrigger && typeof scrollTrigger.progress === \"number\") {\n              lastIntroProgress = scrollTrigger.progress;\n              updateObjectsWalkBy(scrollTrigger.progress);\n            } else {\n              lastIntroProgress = 0;\n              updateObjectsWalkBy(0);\n            }\n          });\n        },\n        onEnterBack: () => {\n          isIntroScrollActive = true;\n\n          // CRITICAL: Kill any home-scroll animations that might interfere\n          const homeScrollTrigger = gsap.getById(\"homeScroll\");\n          if (homeScrollTrigger) {\n            const homeTimeline = (homeScrollTrigger as any).timeline;\n            if (homeTimeline && homeTimeline.pause) {\n              homeTimeline.pause();\n            }\n          }\n\n          // CRITICAL: Kill any pov-scroll animations that might interfere\n          const povScrollTrigger = ScrollTrigger.getById(\"povScroll\");\n          if (povScrollTrigger) {\n            const povTimeline = (povScrollTrigger as any).timeline;\n            if (povTimeline && povTimeline.pause) {\n              povTimeline.pause();\n            }\n          }\n\n          // Kill any GSAP animations on objects\n          [\"pacman\", \"ghost1\", \"ghost2\", \"ghost3\", \"ghost4\", \"ghost5\"].forEach(\n            (key) => {\n              const obj = ghosts[key];\n              if (obj) {\n                gsap.killTweensOf(obj);\n                gsap.killTweensOf(obj.scale);\n                gsap.killTweensOf(obj.position);\n                gsap.killTweensOf(obj.quaternion);\n\n                // CRITICAL: Immediately set visibility and opacity to ensure objects are visible\n                // This overrides any opacity/visibility set by home-scroll\n                // Must traverse ALL nested meshes to restore visibility\n                obj.visible = true;\n                obj.traverse((child) => {\n                  if ((child as any).isMesh && (child as any).material) {\n                    const mesh = child as THREE.Mesh;\n                    const childName = child.name || \"\";\n\n                    // Skip currency symbols and pacman parts - they stay hidden\n                    if (\n                      [\"EUR\", \"CHF\", \"YEN\", \"USD\", \"GBP\"].includes(childName) ||\n                      childName.includes(\"EUR\") ||\n                      childName.includes(\"CHF\") ||\n                      childName.includes(\"YEN\") ||\n                      childName.includes(\"USD\") ||\n                      childName.includes(\"GBP\") ||\n                      (key === \"pacman\" &&\n                        (childName.includes(\"Shell\") ||\n                          childName.includes(\"Bitcoin_1\") ||\n                          childName.includes(\"Bitcoin_2\")))\n                    ) {\n                      return; // Skip these, keep them hidden\n                    }\n\n                    // Force visibility and opacity for all other meshes\n                    mesh.visible = true;\n                    if (Array.isArray(mesh.material)) {\n                      mesh.material.forEach((mat: any) => {\n                        mat.opacity = 1;\n                        mat.transparent = true;\n                      });\n                    } else {\n                      (mesh.material as any).opacity = 1;\n                      (mesh.material as any).transparent = true;\n                    }\n                  }\n                });\n\n                // Force update matrix to ensure changes are applied\n                obj.updateMatrixWorld(true);\n              }\n            }\n          );\n\n          const scrollDir = getScrollDirection();\n          applyIntroScrollPreset(true, scrollDir);\n\n          // CRITICAL: After preset is applied, FORCE visibility again to ensure objects are visible\n          // This is necessary because home-scroll makes objects invisible (opacity 0 or visible false)\n          [\"pacman\", \"ghost1\", \"ghost2\", \"ghost3\", \"ghost4\", \"ghost5\"].forEach(\n            (key) => {\n              const obj = ghosts[key];\n              if (obj) {\n                obj.visible = true;\n                obj.traverse((child) => {\n                  if ((child as any).isMesh && (child as any).material) {\n                    const mesh = child as THREE.Mesh;\n                    const childName = child.name || \"\";\n\n                    // Skip currency symbols and pacman parts\n                    if (\n                      [\"EUR\", \"CHF\", \"YEN\", \"USD\", \"GBP\"].includes(childName) ||\n                      childName.includes(\"EUR\") ||\n                      childName.includes(\"CHF\") ||\n                      childName.includes(\"YEN\") ||\n                      childName.includes(\"USD\") ||\n                      childName.includes(\"GBP\") ||\n                      (key === \"pacman\" &&\n                        (childName.includes(\"Shell\") ||\n                          childName.includes(\"Bitcoin_1\") ||\n                          childName.includes(\"Bitcoin_2\")))\n                    ) {\n                      return;\n                    }\n\n                    mesh.visible = true;\n                    if (Array.isArray(mesh.material)) {\n                      mesh.material.forEach((mat: any) => {\n                        mat.opacity = 1;\n                        mat.transparent = true;\n                      });\n                    } else {\n                      (mesh.material as any).opacity = 1;\n                      (mesh.material as any).transparent = true;\n                    }\n                  }\n                });\n                obj.updateMatrixWorld(true);\n              }\n            }\n          );\n\n          // CRITICAL: Reset update flags to ensure first update runs\n          isUpdating = false;\n          lastUpdateTime = 0;\n          cachedObjectStates = {};\n\n          // Immediately update objects to ensure they're visible and at correct position\n          // Call synchronously first, then also in requestAnimationFrame for safety\n          const scrollTrigger = ScrollTrigger.getById(\"introScroll\");\n          if (scrollTrigger && typeof scrollTrigger.progress === \"number\") {\n            lastIntroProgress = scrollTrigger.progress;\n            updateObjectsWalkBy(scrollTrigger.progress);\n          } else {\n            lastIntroProgress = 0;\n            updateObjectsWalkBy(0);\n          }\n\n          // Also call in requestAnimationFrame to ensure it runs after any pending updates\n          requestAnimationFrame(() => {\n            const scrollTrigger = ScrollTrigger.getById(\"introScroll\");\n            if (scrollTrigger && typeof scrollTrigger.progress === \"number\") {\n              lastIntroProgress = scrollTrigger.progress;\n              updateObjectsWalkBy(scrollTrigger.progress);\n            } else {\n              lastIntroProgress = 0;\n              updateObjectsWalkBy(0);\n            }\n          });\n        },\n        onLeave: () => {\n          isIntroScrollActive = false;\n\n          // Restore floor to original appearance when leaving intro section\n          scene.traverse((child) => {\n            if (child.name === \"CAM-Floor\") {\n              child.visible = true;\n              if (child instanceof THREE.Mesh && child.material) {\n                const material = child.material as THREE.MeshBasicMaterial;\n                material.color.setHex(0xffffff); // White\n                material.opacity = 1;\n                material.transparent = false;\n              }\n            }\n          });\n        },\n        onLeaveBack: () => {\n          isIntroScrollActive = false;\n\n          // Restore floor to original appearance when leaving intro section\n          scene.traverse((child) => {\n            if (child.name === \"CAM-Floor\") {\n              child.visible = true;\n              if (child instanceof THREE.Mesh && child.material) {\n                const material = child.material as THREE.MeshBasicMaterial;\n                material.color.setHex(0xffffff); // White\n                material.opacity = 1;\n                material.transparent = false;\n              }\n            }\n          });\n        },\n        onUpdate: (self) => {\n          // CRITICAL: Update on every scroll event - this is the primary update source\n          // Update bidirectionally based on scroll progress (works for both scroll up and down)\n          if (\n            isIntroScrollActive &&\n            typeof self.progress === \"number\" &&\n            !isUpdating\n          ) {\n            lastIntroProgress = self.progress;\n            updateObjectsWalkBy(self.progress);\n          }\n        },\n        onRefresh: () => {\n          // Only refresh if active - don't update objects here to avoid conflicts\n          // The onUpdate callback will handle updates\n        },\n        id: \"introScroll\",\n      },\n    })\n    .fromTo(\n      \".sc_h--intro\",\n      { scale: 0.5, opacity: 0 },\n      {\n        keyframes: [\n          { scale: 0.5, opacity: 0, duration: 0 },\n          { scale: 0.8, opacity: 1, duration: 0.3 },\n          { scale: 1.2, opacity: 1, duration: 0.4 },\n          { scale: 1.5, opacity: 0, duration: 0.3 },\n        ],\n      }\n    )\n    .fromTo(\n      \".sc_b--intro\",\n      { scale: 0.5, opacity: 0 },\n      {\n        keyframes: [\n          { scale: 0.5, opacity: 0, duration: 0 },\n          { scale: 0.8, opacity: 1, duration: 0.3 },\n          { scale: 1.2, opacity: 1, duration: 0.4 },\n          { scale: 1.5, opacity: 0, duration: 0.3 },\n        ],\n      }\n    )\n    .to(\n      { progress: 0 },\n      {\n        progress: 1,\n        duration: 1,\n        immediateRender: false,\n        // Remove onUpdate here - ScrollTrigger's onUpdate handles all updates\n        // This prevents double updates that cause flickering\n        onStart: function () {},\n        onComplete: function () {\n          // CRITICAL: Ensure objects are visible even when animation completes\n          if (isIntroScrollActive) {\n            updateObjectsWalkBy(lastIntroProgress);\n          }\n        },\n        onReverseComplete: function () {\n          // CRITICAL: Ensure objects are visible even when animation reverses\n          if (isIntroScrollActive) {\n            updateObjectsWalkBy(lastIntroProgress);\n          }\n        },\n      },\n      0 // Start at the same time as the other animations\n    );\n}\n\nfunction updateObjectsWalkBy(progress: number) {\n  // CRITICAL: Only update if intro-scroll is active\n  if (!isIntroScrollActive || isUpdating) return;\n\n  isUpdating = true;\n\n  try {\n    // Ensure floor plane stays invisible (white with opacity 0) during animation\n    scene.traverse((child) => {\n      if (child.name === \"CAM-Floor\") {\n        child.visible = true;\n        if (child instanceof THREE.Mesh && child.material) {\n          const material = child.material as THREE.MeshBasicMaterial;\n          material.color.setHex(0xffffff); // White\n          material.opacity = 0;\n          material.transparent = true;\n        }\n      }\n    });\n\n    // Calculate base center point for walk path\n    const baseCenter = new THREE.Vector3(\n      camera.position.x,\n      camera.position.y,\n      camera.position.z\n    );\n\n    // Walk path symmetric around center\n    // Start 10 units left of center, end 10 units right of center\n    const walkDistance = 10.0;\n    const walkStart = baseCenter.x - walkDistance; // Start from left\n    const walkEnd = baseCenter.x + walkDistance; // End at right\n\n    // Objects to animate - ghosts walk 0.5 units behind pacman\n    const objectsToAnimate = [\n      { key: \"pacman\", behindOffset: 0 },\n      { key: \"ghost1\", behindOffset: -0.5 },\n      { key: \"ghost2\", behindOffset: -1.0 },\n      { key: \"ghost3\", behindOffset: -1.5 },\n      { key: \"ghost4\", behindOffset: -2.0 },\n      { key: \"ghost5\", behindOffset: -2.5 },\n    ];\n\n    // Calculate pacman's position using smooth interpolation\n    const normalizedProgress = Math.max(0, Math.min(1, progress));\n    const baseX = walkStart + (walkEnd - walkStart) * normalizedProgress;\n    const pacmanX = baseX + INTRO_POSITION_OFFSET.x;\n    const pacmanY = baseCenter.y + INTRO_POSITION_OFFSET.y;\n    const pacmanZ = baseCenter.z + INTRO_POSITION_OFFSET.z;\n\n    // Smooth fade-in for ghosts based on progress\n    const fadeInDuration = 0.2; // Fade in over 20% of progress\n    const ghostOpacity =\n      normalizedProgress < fadeInDuration\n        ? normalizedProgress / fadeInDuration\n        : 1.0;\n\n    objectsToAnimate.forEach(({ key, behindOffset }) => {\n      const object = ghosts[key];\n      if (!object) return;\n\n      // CRITICAL: Kill any GSAP animations that might interfere\n      gsap.killTweensOf(object);\n      gsap.killTweensOf(object.scale);\n      gsap.killTweensOf(object.position);\n      gsap.killTweensOf(object.quaternion);\n\n      // CRITICAL: Kill any opacity/material animations that might be interfering\n      object.traverse((child) => {\n        if ((child as any).isMesh && (child as any).material) {\n          const mesh = child as THREE.Mesh;\n          if (Array.isArray(mesh.material)) {\n            mesh.material.forEach((mat: any) => {\n              gsap.killTweensOf(mat);\n              gsap.killTweensOf(mat.opacity);\n            });\n          } else {\n            gsap.killTweensOf(mesh.material);\n            gsap.killTweensOf((mesh.material as any).opacity);\n          }\n        }\n      });\n\n      // Calculate position\n      const finalX = pacmanX + behindOffset;\n      const finalY = pacmanY;\n      const finalZ = pacmanZ;\n\n      // Update position directly (no GSAP interpolation for smoother updates)\n      object.position.set(finalX, finalY, finalZ);\n\n      // Set rotation quaternion directly (no recalculation - use pre-calculated quaternions)\n      const pacmanQuat = getPacmanTargetQuaternion();\n      const ghostQuat = getGhostTargetQuaternion();\n      if (key === \"pacman\" && pacmanQuat) {\n        object.quaternion.copy(pacmanQuat);\n      } else if (ghostQuat) {\n        object.quaternion.copy(ghostQuat);\n      }\n\n      // Force update matrix to ensure rotation is applied\n      object.updateMatrixWorld(true);\n\n      // CRITICAL: Force visibility, scale EVERY frame to override home-scroll\n      object.visible = true;\n      if (key === \"pacman\") {\n        object.scale.set(0.1, 0.1, 0.1);\n      } else {\n        object.scale.set(1.0, 1.0, 1.0);\n      }\n\n      // Update opacity for meshes\n      const targetOpacity = key === \"pacman\" ? 1.0 : ghostOpacity;\n\n      // Ensure child meshes are visible and maintain ghost colors\n      const ghostColors: Record<string, number> = {\n        ghost1: 0xff0000, // Red\n        ghost2: 0x00ff00, // Green\n        ghost3: 0x0000ff, // Blue\n        ghost4: 0xffff00, // Yellow\n        ghost5: 0xff00ff, // Magenta\n      };\n\n      object.traverse((child) => {\n        if ((child as any).isMesh && (child as any).material) {\n          const mesh = child as THREE.Mesh;\n          const childName = child.name || \"\";\n\n          // Keep currency symbols hidden - check both exact match and includes\n          if (\n            [\"EUR\", \"CHF\", \"YEN\", \"USD\", \"GBP\"].includes(childName) ||\n            childName.includes(\"EUR\") ||\n            childName.includes(\"CHF\") ||\n            childName.includes(\"YEN\") ||\n            childName.includes(\"USD\") ||\n            childName.includes(\"GBP\")\n          ) {\n            mesh.visible = false;\n            return;\n          }\n\n          // For pacman: hide Shell and Bitcoin parts\n          if (\n            key === \"pacman\" &&\n            (childName.includes(\"Shell\") ||\n              childName.includes(\"Bitcoin_1\") ||\n              childName.includes(\"Bitcoin_2\"))\n          ) {\n            mesh.visible = false;\n            return;\n          }\n\n          // Cache key for this mesh to avoid redundant updates\n          const cacheKey = `${key}_${childName}`;\n          const cachedState = cachedObjectStates[cacheKey];\n\n          // CRITICAL: Force visibility EVERY frame (don't check, just set it)\n          mesh.visible = true;\n\n          // CRITICAL: Force opacity EVERY frame (always set it, don't check cache or conditions)\n          // This ensures opacity is always correct even if something overrides it\n          if (Array.isArray(mesh.material)) {\n            mesh.material.forEach((mat: any) => {\n              mat.opacity = targetOpacity;\n              mat.transparent = true;\n              // Force material update\n              if (mat.needsUpdate !== undefined) {\n                mat.needsUpdate = true;\n              }\n            });\n          } else {\n            const mat = mesh.material as any;\n            mat.opacity = targetOpacity;\n            mat.transparent = true;\n            // Force material update\n            if (mat.needsUpdate !== undefined) {\n              mat.needsUpdate = true;\n            }\n          }\n\n          // Set ghost colors (only if needed)\n          if (ghostColors[key] && key !== \"pacman\") {\n            const newColor = ghostColors[key];\n            if (Array.isArray(mesh.material)) {\n              mesh.material.forEach((mat: any) => {\n                if (mat.color.getHex() !== newColor) {\n                  mat.color.setHex(newColor);\n                }\n              });\n            } else {\n              const mat = mesh.material as any;\n              if (mat.color.getHex() !== newColor) {\n                mat.color.setHex(newColor);\n              }\n            }\n          }\n        }\n      });\n\n      // CRITICAL: Force matrix update after all changes (only once per object)\n      object.updateMatrixWorld(true);\n    });\n\n    // Clear cache periodically to prevent memory buildup (every 100 frames)\n    if (Math.floor(normalizedProgress * 100) % 10 === 0) {\n      // Keep cache size reasonable\n      if (Object.keys(cachedObjectStates).length > 100) {\n        cachedObjectStates = {};\n      }\n    }\n  } finally {\n    isUpdating = false;\n  }\n}\n","import gsap from \"gsap\";\nimport { applyOutroScrollPreset, getScrollDirection } from \"./scene-presets\";\n\nlet outroScrollTimeline: gsap.core.Timeline | null = null;\n\nexport function initOutroScrollAnimation() {\n  outroScrollTimeline = gsap.timeline({\n    scrollTrigger: {\n      trigger: \".sc--outro\",\n      start: \"top center\",\n      end: \"bottom bottom\",\n      scrub: 0.5,\n      onEnter: () => {\n        const scrollDir = getScrollDirection();\n        applyOutroScrollPreset(true, scrollDir);\n      },\n      onEnterBack: () => {\n        const scrollDir = getScrollDirection();\n        applyOutroScrollPreset(true, scrollDir);\n      },\n    }\n  }).fromTo(\n    \".sc_b--outro\", { scale: 0.5, opacity: 0 },\n    {\n      keyframes: [\n        { scale: 0.5, opacity: 0, duration: 0 },\n        { scale: 0.8, opacity: 1, duration: 0.3 },\n        { scale: 1.2, opacity: 1, duration: 0.4 },\n        { scale: 1.5, opacity: 0, duration: 0.3 }\n      ]\n    }\n  );\n}","import {\n  startRenderLoop,\n  initRenderer,\n  setupLighting,\n  scene,\n  createDebugLines,\n} from \"./core/scene\";\nimport {\n  homeLoopHandler,\n  setupHomeLoopScrollHandler,\n} from \"./animation/home-loop\";\nimport { initPovScrollAnimation } from \"./animation/pov-scroll\";\nimport { loadModel } from \"./core/objects\";\nimport { setupCamera, camera } from \"./core/camera\";\nimport * as THREE from \"three\";\nimport { X, XCoordKey, Z, ZCoordKey } from \"./paths/coordinates\";\nimport { initIntroScrollAnimation } from \"./animation/intro-scroll\";\nimport { initOutroScrollAnimation } from \"./animation/outro-scroll\";\n\n// Declare global window interface for debug commands\ndeclare global {\n  interface Window {\n    lookAt: (x: XCoordKey, y: number, z: ZCoordKey) => void;\n  }\n}\n\nfunction initSkipButton() {\n  const skipButton = document.querySelector(\".wr_p--skip.wr_p\");\n  if (skipButton) {\n    const finalSection = document.querySelector(\".sc--testimonials\");\n    if (finalSection) {\n      skipButton.addEventListener(\"click\", () => {\n        finalSection.scrollIntoView({ behavior: \"smooth\", block: \"start\", inline: \"nearest\" });\n      });\n    }\n  }\n}\n\nasync function main() {\n  initRenderer();\n  setupLighting();\n  setupCamera();\n  createDebugLines();\n  await loadModel(scene);\n\n  homeLoopHandler();\n  setupHomeLoopScrollHandler();\n\n  initPovScrollAnimation();\n  initIntroScrollAnimation();\n  initOutroScrollAnimation();\n  initSkipButton();\n  startRenderLoop();\n}\n\nmain();\n"],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","THREE","isMobile","window","innerWidth","DOM_ELEMENTS","mazeContainer","document","querySelector","canvas","homeSection","introSection","povSection","finalSection","finalContainer","parentElements","querySelectorAll","gsap","ScrollTrigger","X","Z","getCoord","x","z","Vector3","objectHomeScrollEndPathPoint","cameraPathPointsConfig","startMobile","startDesktop","secondMobile","secondDesktop","mobileLookAt","desktopLookAt","cameraLookAtSecondDesktop","cameraLookAtSecondMobile","cameraHomeScrollEndLookAt","thirdPosition","cameraHomeScrollEndPathPoint","startPosition","secondPosition","lookAtPosition","cameraLookAtSecondPosition","pacmanHomePathPoints","pos","type","arc","curveCheckPoints","ghost1HomePathPoints","ghost2HomePathPoints","ghost3HomePathPoints","ghost4HomePathPoints","ghost5HomePathPoints","cameraHomeScrollPathPoints","lookAt","povTriggerPositions","ghost1","triggerPos","ghostStartFadeIn","ghostEndFadeIn","ghostStartFadeOut","camStartFadeIn","camEndFadeIn","camStartFadeOut","endPosition","forceEndProgress","start","end","ghost2","ghost3","ghost4","ghost5","getStartPosition","getLookAtPosition","homePaths","pacman","getCameraHomeScrollPathPoints","innerHeight","scene","renderer","antialias","alpha","powerPreference","precision","clock","frameCallbacks","setPixelRatio","pixelRatio","Math","min","devicePixelRatio","setSize","clientWidth","clientHeight","aspect","updateProjectionMatrix","mazeTexture","load","mazeMaterial","matcap","topMaterial","color","metalness","roughness","envMapIntensity","ghostMaterial","opacity","transparent","depthWrite","depthTest","blending","side","transmission","floorMaterial","pacmanMaterials","blue","white","default","materialMap","CAM_Pacman_Backframe","CAM_Pacman_Logo_1","CAM_Pacman_Logo_2","loader","pacmanMixer","ghosts","ghostContainers","Ghost_EUR","Ghost_CHF","Ghost_YEN","Ghost_USD","Ghost_GBP","pathCache","Map","TangentSmoother","constructor","initialTangent","smoothing","this","currentTangent","clone","update","targetTangent","lerp","normalize","reset","newTangent","copy","getCurrentTangent","setSmoothingFactor","max","createNormalCurveMidPoint","current","next","curveType","y","createCameraHomeScrollPath","pathPoints","path","length","curve","add","getHomePaths","paths","entries","forEach","cacheKey","map","p","join","has","i","catmullPoints","midPoint","set","createMazePath","calculateObjectOrientation","object","tangent","objectType","targetRotation","atan2","rotation","PI","lookAtPoint","position","LAY_DOWN_QUAT_1","setFromEuler","LAY_DOWN_QUAT_2","slerpToLayDown","startQuat","progress","targetQuat","angleTo","quaternion","slerp","applyHomeScrollPreset","isEntering","scrollDirection","pausedPositions","pausedRotations","visible","scale","updateMatrixWorld","traverse","child","isMesh","material","mesh","childName","name","includes","Array","isArray","mat","setHex","pacmanTargetQuaternion","ghostTargetQuaternion","introInitialRotations","applyIntroScrollPreset","xRotation180","pacmanObj","pacmanRotation90","multiply","pacmanRotationY180","ghostObj","ghostRotationY180","baseX","ghostColors","index","behindOffset","undefined","needsUpdate","newColor","applyPovScrollPreset","applyOutroScrollPreset","lastScrollY","scrollY","getScrollDirection","currentScrollY","direction","homeScrollTimeline","previousCameraRotation","characterSpeeds","initHomeScrollAnimation","kill","scrollPaths","scrollPathPoints","pausedPos","arcPoint","createHomeScrollPathPoints","camera","createHomeScrollPath","getHomeScrollPaths","cameraPathPoints","scrollTrigger","id","trigger","scrub","onEnter","scrollDir","onEnterBack","onScrubComplete","homeLoopHandler","to","immediateRender","onUpdate","targets","fov","introScrollTrigger","isIntroScrollActive","isActive","cameraPoint","getPointAt","getPoint","currentRotation","diffX","abs","diffY","diffZ","checkAndLogCameraRotationChange","fadeStartProgress","rotationProgress","pow","pacmanSpeed","rawPacmanProgress","easedPacmanProgress","pacmanPoint","ghost","ghostSpeed","rawGhostProgress","easedGhostProgress","ghostPoint","updateScrollAnimation","LOOP_DURATION","ROTATION_TRANSITION_DURATION","isHomeLoopActive","animationTime","pausedT","homeLoopFrameRegistered","rotationTransitionTime","startRotations","hasBeenPausedBefore","homeLoopTangentSmoothers","callback","getTangentAt","delta","t","transitionProgress","isTransitioning","rawTangent","smoothTangent","tempObject","easedProgress","updateHomeLoop","getDelta","push","startHomeLoop","povScrollTimeline","ghostStates","povTangentSmoothers","introScrollTimeline","lastIntroProgress","isUpdating","lastUpdateTime","cachedObjectStates","updateObjectsWalkBy","baseCenter","walkDistance","walkStart","walkEnd","objectsToAnimate","normalizedProgress","pacmanX","pacmanY","pacmanZ","fadeInDuration","ghostOpacity","finalX","finalY","finalZ","pacmanQuat","ghostQuat","targetOpacity","getHex","floor","keys","outroScrollTimeline","async","shadowMap","enabled","appendChild","domElement","body","addEventListener","render","ambientLight","directionalLight","shadow","mapSize","width","height","left","right","top","bottom","near","far","bias","radius","castShadow","setupLighting","setupCamera","redLineGeometry","setFromPoints","redLineMaterial","linewidth","redLine","renderOrder","greenLineGeometry","greenLineMaterial","greenLine","createDebugLines","values","Promise","resolve","reject","gltf","model","children","subChild","item","pacmanActions","animations","clip","action","clipAction","getMixer","e","getRoot","userData","skipAnimation","updateMorphTargets","setEffectiveWeight","play","ghostContainer","ghostGroup","startsWith","console","warn","clonedChild","receiveShadow","node","error","loadModel","stopHomeLoop","hasBeenTriggered","hasBeenDeactivated","triggerCameraProgress","ghostStartFadeInProgress","ghostEndFadeInProgress","ghostStartFadeOutProgress","camStartFadeInProgress","camEndFadeInProgress","camStartFadeOutProgress","endCameraProgress","currentPathT","ghostTextOpacity","camTextOpacity","lastProgress","markers","toggleActions","onStart","onReverseComplete","onComplete","refreshPriority","homeScrollTrigger","homeTimeline","timeline","pause","povScrollTrigger","povTimeline","requestAnimationFrame","onLeave","onLeaveBack","self","onRefresh","fromTo","keyframes","duration","skipButton","scrollIntoView","behavior","block","inline","initSkipButton","startRenderLoop","main"],"sourceRoot":""}