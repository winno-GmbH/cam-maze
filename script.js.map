{"version":3,"file":"script.js","mappings":"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","sources":["webpack://cam-3d-animation/webpack/bootstrap","webpack://cam-3d-animation/webpack/runtime/compat get default export","webpack://cam-3d-animation/webpack/runtime/define property getters","webpack://cam-3d-animation/webpack/runtime/hasOwnProperty shorthand","webpack://cam-3d-animation/external var \"THREE\"","webpack://cam-3d-animation/./src/config/config.ts","webpack://cam-3d-animation/./src/animation/constants.ts","webpack://cam-3d-animation/./src/config/dom-elements.ts","webpack://cam-3d-animation/external var \"gsap\"","webpack://cam-3d-animation/external var \"ScrollTrigger\"","webpack://cam-3d-animation/./src/paths/coordinates.ts","webpack://cam-3d-animation/./src/paths/pathpoints.ts","webpack://cam-3d-animation/./src/core/camera.ts","webpack://cam-3d-animation/./src/core/scene.ts","webpack://cam-3d-animation/./src/core/materials.ts","webpack://cam-3d-animation/./src/core/objects.ts","webpack://cam-3d-animation/./src/paths/paths.ts","webpack://cam-3d-animation/./src/animation/util.ts","webpack://cam-3d-animation/./src/core/material-utils.ts","webpack://cam-3d-animation/./src/animation/scene-utils.ts","webpack://cam-3d-animation/./src/animation/scene-presets.ts","webpack://cam-3d-animation/./src/animation/object-state.ts","webpack://cam-3d-animation/./src/animation/home-scroll.ts","webpack://cam-3d-animation/./src/animation/home-loop.ts","webpack://cam-3d-animation/./src/animation/pov-scroll.ts","webpack://cam-3d-animation/./src/animation/intro-scroll.ts","webpack://cam-3d-animation/./src/animation/outro-scroll.ts","webpack://cam-3d-animation/./src/main.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const __WEBPACK_NAMESPACE_OBJECT__ = THREE;","export const isMobile = window.innerWidth < 768;\n\nexport const ASSETS = {\n  mazeTexture: \"https://c-am.b-cdn.net/CAM/matcap24.png\",\n  mazeModel: \"https://c-am.b-cdn.net/CAM/c-am-assets-3.glb\",\n};\n","/**\n * ANIMATION CONSTANTS\n * \n * Centralized constants to avoid magic numbers and improve maintainability.\n * All scale, opacity, and color values used across animations should be defined here.\n */\n\n// ============================================================================\n// SCALE CONSTANTS\n// ============================================================================\nexport const SCALE = {\n  PACMAN_HOME: 0.05, // Original model size for pacman in home scene\n  PACMAN_INTRO: 0.1, // Pacman scale in intro scene\n  GHOST_NORMAL: 1.0, // Normal ghost scale\n  GHOST_POV: 0.5, // Ghost scale in POV scene\n} as const;\n\n// ============================================================================\n// OPACITY CONSTANTS\n// ============================================================================\nexport const OPACITY = {\n  FULL: 1.0,\n  HIDDEN: 0.0,\n} as const;\n\n// ============================================================================\n// COLOR CONSTANTS\n// ============================================================================\nexport const COLOR = {\n  WHITE: 0xffffff,\n} as const;\n\n// ============================================================================\n// SCROLL TRIGGER SELECTORS\n// ============================================================================\n// These should match the selectors in config/dom-elements.ts\nexport const SCROLL_SELECTORS = {\n  HOME: \".sc--home.sc\",\n  INTRO: \".sc--intro.sc\",\n  POV: \".sc--pov.sc\",\n  OUTRO: \".sc--outro.sc\",\n} as const;\n\n","// Import scroll selectors from animation constants for consistency\nimport { SCROLL_SELECTORS } from \"../animation/constants\";\n\nconst SELECTORS = {\n  mazeContainer: \".el--home-maze.el\",\n  canvas: \"canvas\",\n\n  homeSection: SCROLL_SELECTORS.HOME,\n  introSection: SCROLL_SELECTORS.INTRO,\n  povSection: SCROLL_SELECTORS.POV,\n  finalSection: SCROLL_SELECTORS.OUTRO,\n  finalContainer: \".cr--outro.cr\",\n\n  scrollComponent: \".cmp--scroll.cmp\",\n  parentElements: \".cmp--pov.cmp\",\n\n  pov: \".pov\",\n  cam: \".cam\",\n};\n\nexport const DOM_ELEMENTS = {\n  mazeContainer: document.querySelector(SELECTORS.mazeContainer) as HTMLElement,\n  canvas: document.querySelector(SELECTORS.canvas) as HTMLCanvasElement,\n\n  homeSection: document.querySelector(SELECTORS.homeSection) as HTMLElement,\n  introSection: document.querySelector(SELECTORS.introSection) as HTMLElement,\n  povSection: document.querySelector(SELECTORS.povSection) as HTMLElement,\n  finalSection: document.querySelector(SELECTORS.finalSection) as HTMLElement,\n  finalContainer: document.querySelector(\n    SELECTORS.finalContainer\n  ) as HTMLElement,\n\n  parentElements: document.querySelectorAll(\n    SELECTORS.parentElements\n  ) as NodeListOf<Element>,\n};\n","const __WEBPACK_NAMESPACE_OBJECT__ = gsap;","const __WEBPACK_NAMESPACE_OBJECT__ = ScrollTrigger;","export type XCoordKey =\n  | \"0\"\n  | \"0.5\"\n  | \"1\"\n  | \"1.5\"\n  | \"2\"\n  | \"2.5\"\n  | \"3\"\n  | \"3.5\"\n  | \"4\"\n  | \"4.5\"\n  | \"5\"\n  | \"5.5\"\n  | \"6\"\n  | \"6.5\"\n  | \"7\"\n  | \"7.5\"\n  | \"8\"\n  | \"8.5\"\n  | \"9\"\n  | \"9.5\"\n  | \"10\"\n  | \"10.5\"\n  | \"11\"\n  | \"11.5\"\n  | \"12\"\n  | \"12.5\"\n  | \"13\"\n  | \"13.5\"\n  | \"14\"\n  | \"14.5\"\n  | \"15\"\n  | \"15.5\"\n  | \"16\"\n  | \"16.5\"\n  | \"17\"\n  | \"17.5\"\n  | \"18\"\n  | \"18.5\"\n  | \"19\"\n  | \"19.5\"\n  | \"20\"\n\nexport type ZCoordKey =\n  | \"0\"\n  | \"0.5\"\n  | \"1\"\n  | \"1.5\"\n  | \"2\"\n  | \"2.5\"\n  | \"3\"\n  | \"3.5\"\n  | \"4\"\n  | \"4.5\"\n  | \"5\"\n  | \"5.5\"\n  | \"6\"\n  | \"6.5\"\n  | \"7\"\n  | \"7.5\"\n  | \"8\"\n  | \"8.5\"\n  | \"9\"\n  | \"9.5\"\n  | \"10\"\n  | \"10.5\"\n  | \"11\"\n  | \"11.5\"\n  | \"12\"\n  | \"12.5\"\n  | \"13\"\n  | \"13.5\"\n  | \"14\"\n  | \"14.5\"\n  | \"15\"\n  | \"15.5\"\n  | \"16\"\n\nexport const Y = 0.55;\n\nexport const X: Record<XCoordKey, number> = {\n  \"0\": -0.54875,\n  \"0.5\": -0.4985,\n  \"1\": -0.44825,\n  \"1.5\": -0.398,\n  \"2\": -0.34775,\n  \"2.5\": -0.2975,\n  \"3\": -0.24725,\n  \"3.5\": -0.197,\n  \"4\": -0.14675,\n  \"4.5\": -0.0965,\n  \"5\": -0.04625,\n  \"5.5\": 0.004,\n  \"6\": 0.05425,\n  \"6.5\": 0.1045,\n  \"7\": 0.15475,\n  \"7.5\": 0.205,\n  \"8\": 0.25525,\n  \"8.5\": 0.3055,\n  \"9\": 0.35575,\n  \"9.5\": 0.406,\n  \"10\": 0.45625,\n  \"10.5\": 0.5065,\n  \"11\": 0.55675,\n  \"11.5\": 0.607,\n  \"12\": 0.65725,\n  \"12.5\": 0.7075,\n  \"13\": 0.75775,\n  \"13.5\": 0.808,\n  \"14\": 0.85825,\n  \"14.5\": 0.9085,\n  \"15\": 0.95875,\n  \"15.5\": 1.009,\n  \"16\": 1.05925,\n  \"16.5\": 1.1095,\n  \"17\": 1.15975,\n  \"17.5\": 1.21,\n  \"18\": 1.26025,\n  \"18.5\": 1.3105,\n  \"19\": 1.36075,\n  \"19.5\": 1.411,\n  \"20\": 1.46125,\n};\n\nexport const Z: Record<ZCoordKey, number> = {\n  \"0\": -0.302,\n  \"0.5\": -0.25175,\n  \"1\": -0.2015,\n  \"1.5\": -0.15125,\n  \"2\": -0.101,\n  \"2.5\": -0.05075,\n  \"3\": -0.0005,\n  \"3.5\": 0.04975,\n  \"4\": 0.1,\n  \"4.5\": 0.15025,\n  \"5\": 0.2005,\n  \"5.5\": 0.25075,\n  \"6\": 0.301,\n  \"6.5\": 0.35125,\n  \"7\": 0.4015,\n  \"7.5\": 0.45175,\n  \"8\": 0.502,\n  \"8.5\": 0.55225,\n  \"9\": 0.6025,\n  \"9.5\": 0.65275,\n  \"10\": 0.703,\n  \"10.5\": 0.75325,\n  \"11\": 0.8035,\n  \"11.5\": 0.85375,\n  \"12\": 0.904,\n  \"12.5\": 0.95425,\n  \"13\": 1.0045,\n  \"13.5\": 1.05475,\n  \"14\": 1.105,\n  \"14.5\": 1.15525,\n  \"15\": 1.2055,\n  \"15.5\": 1.25575,\n  \"16\": 1.306,\n}\n\nexport const getCoord = (x: XCoordKey, z: ZCoordKey) => {\n  return new THREE.Vector3(X[x], Y, Z[z])\n};","import * as THREE from \"three\";\nimport { MazePathPoint, PathPoint, CameraPathPoint } from \"../types/types\";\nimport { isMobile } from \"../config/config\";\nimport { getCoord, X, Y, Z } from \"./coordinates\";\n\n// TODO - add curveCheckPoints to all curves where needed\n\nexport const objectHomeScrollEndPathPoint = new THREE.Vector3(\n  0.55675,\n  0.35,\n  0.45175\n);\n\nconst cameraPathPointsConfig = {\n  startMobile: new THREE.Vector3(0.5, 2.5, 2.5),\n  startDesktop: new THREE.Vector3(-2, 2.5, 2),\n  secondMobile: new THREE.Vector3(0.5, 2.5, 2),\n  secondDesktop: new THREE.Vector3(-1.5, 3, 0.75),\n  mobileLookAt: new THREE.Vector3(0.5, 0.5, -1.5),\n  desktopLookAt: new THREE.Vector3(-1.25, 0.5, 0.25),\n  cameraLookAtSecondDesktop: new THREE.Vector3(-0.75, 0.5, -0.75),\n  cameraLookAtSecondMobile: new THREE.Vector3(-0.75, 0.5, -0.75), // TODO\n\n  cameraHomeScrollEndLookAt: new THREE.Vector3(0.55675, -5, 0.35),\n  thirdPosition: new THREE.Vector3(0.55675, 3, 0.45175),\n\n  cameraHomeScrollEndPathPoint: new THREE.Vector3(0.55675, 0.5, 0.45175),\n};\n\n// determine positions and look at - changed if is mobile\nconst startPosition = isMobile\n  ? cameraPathPointsConfig.startMobile\n  : cameraPathPointsConfig.startDesktop;\nconst secondPosition = isMobile\n  ? cameraPathPointsConfig.secondMobile\n  : cameraPathPointsConfig.secondDesktop;\nconst lookAtPosition = isMobile\n  ? cameraPathPointsConfig.mobileLookAt\n  : cameraPathPointsConfig.desktopLookAt;\nconst cameraLookAtSecondPosition = isMobile\n  ? cameraPathPointsConfig.cameraLookAtSecondMobile\n  : cameraPathPointsConfig.cameraLookAtSecondDesktop;\n\nconst thirdPosition = cameraPathPointsConfig.thirdPosition;\nconst cameraHomeScrollEndLookAt =\n  cameraPathPointsConfig.cameraHomeScrollEndLookAt;\nconst cameraHomeScrollEndPathPoint =\n  cameraPathPointsConfig.cameraHomeScrollEndPathPoint;\n\nconst pacmanHomePathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"8\", \"9\"), type: \"straight\" },\n  {\n    pos: getCoord(\"8\", \"6\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"9\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"10\", \"4\"), type: \"straight\" },\n  {\n    pos: getCoord(\"10\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"9\", \"1\"), type: \"straight\" },\n  {\n    pos: getCoord(\"7\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"6\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"5\", \"3\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"4\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"3\", \"1\"),\n    type: \"straight\",\n    curveCheckPoints: [\n      getCoord(\"2\", \"1\"),\n      getCoord(\"1\", \"2\"),\n      getCoord(\"1\", \"2.5\"),\n      getCoord(\"1.5\", \"3\"),\n      getCoord(\"2\", \"3.5\"),\n    ],\n  },\n  {\n    pos: getCoord(\"2\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"3\", \"5\"), type: \"straight\" },\n  {\n    pos: getCoord(\"5\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"6\", \"6\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"5\", \"7\"), type: \"straight\" },\n  {\n    pos: getCoord(\"4\", \"7\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"3\", \"8\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"4\", \"9\"), type: \"straight\" },\n  {\n    pos: getCoord(\"5\", \"9\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"6\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"5\", \"11\"),\n    type: \"straight\",\n    curveCheckPoints: [\n      getCoord(\"3\", \"11\"),\n      getCoord(\"2\", \"12\"),\n      getCoord(\"1.5\", \"13\"),\n      getCoord(\"1\", \"14\"),\n      getCoord(\"2\", \"15\"),\n      getCoord(\"3\", \"15\"),\n      getCoord(\"4\", \"14\"),\n      getCoord(\"5\", \"13\"),\n    ],\n  },\n  {\n    pos: getCoord(\"6\", \"13\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"7\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"6\", \"15\"), type: \"straight\" },\n  {\n    pos: getCoord(\"5\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"4\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"5\", \"13\"),\n    type: \"straight\",\n    curveCheckPoints: [\n      getCoord(\"12\", \"13\"),\n      getCoord(\"13\", \"12\"),\n      getCoord(\"12.5\", \"11\"),\n      getCoord(\"12\", \"10.5\"),\n      getCoord(\"11\", \"10\"),\n      getCoord(\"10\", \"10.5\"),\n      getCoord(\"9\", \"11\"),\n      getCoord(\"8\", \"10\"),\n      getCoord(\"8\", \"9.5\"),\n    ],\n  },\n  {\n    pos: getCoord(\"8\", \"9\"),\n    type: \"straight\",\n  },\n];\n\nconst ghost1HomePathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"1\", \"10\"), type: \"straight\" },\n  {\n    pos: getCoord(\"1\", \"6\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"2\", \"5\"), type: \"straight\" },\n  {\n    pos: getCoord(\"3\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"4\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"5\", \"3\"), type: \"straight\" },\n  {\n    pos: getCoord(\"9\", \"3\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"10\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"9\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"8\", \"6\"),\n    type: \"straight\",\n    curveCheckPoints: [\n      getCoord(\"8\", \"10\"),\n      getCoord(\"9\", \"11\"),\n      getCoord(\"10\", \"10.5\"),\n      getCoord(\"11\", \"10\"),\n      getCoord(\"12\", \"10.5\"),\n      getCoord(\"13\", \"11\"),\n      getCoord(\"15\", \"11\"),\n      getCoord(\"16\", \"10.5\"),\n      getCoord(\"17\", \"10\"),\n      getCoord(\"18\", \"10.5\"),\n      getCoord(\"19\", \"11\"),\n      getCoord(\"20\", \"10\"),\n    ],\n  },\n  {\n    pos: getCoord(\"20\", \"6\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"19\", \"5\"), type: \"straight\" },\n  {\n    pos: getCoord(\"9\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"8\", \"6\"),\n    type: \"straight\",\n    curveCheckPoints: [\n      getCoord(\"8\", \"8\"),\n      getCoord(\"7\", \"9\"),\n      getCoord(\"6\", \"10\"),\n      getCoord(\"5.5\", \"11\"),\n      getCoord(\"5\", \"12\"),\n      getCoord(\"6\", \"13\"),\n      getCoord(\"7\", \"14\"),\n      getCoord(\"6\", \"15\"),\n      getCoord(\"5\", \"15\"),\n      getCoord(\"4\", \"14\"),\n      getCoord(\"4.5\", \"13\"),\n      getCoord(\"5\", \"12\"),\n      getCoord(\"4\", \"11\"),\n    ],\n  },\n  { pos: getCoord(\"1\", \"10\"), type: \"straight\" },\n];\n\nconst ghost2HomePathPoints: MazePathPoint[] = [\n  {\n    pos: getCoord(\"5\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n    curveCheckPoints: [getCoord(\"5.5\", \"11\")],\n  },\n  {\n    pos: getCoord(\"6\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"5\", \"9\"), type: \"straight\" },\n  {\n    pos: getCoord(\"4\", \"9\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"3\", \"8\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"4\", \"7\"), type: \"straight\" },\n  {\n    pos: getCoord(\"7\", \"7\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"8\", \"8\"), type: \"straight\" },\n  {\n    pos: getCoord(\"8\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n    curveCheckPoints: [getCoord(\"8.5\", \"11\"), getCoord(\"9\", \"12\")],\n  },\n  { pos: getCoord(\"10\", \"13\"), type: \"straight\" },\n  {\n    pos: getCoord(\"12\", \"13\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"13\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"14\", \"15\"), type: \"straight\" },\n  {\n    pos: getCoord(\"19\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"20\", \"14\"), type: \"straight\" },\n  {\n    pos: getCoord(\"20\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"19\", \"3\"), type: \"straight\" },\n  {\n    pos: getCoord(\"17\", \"3\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"16\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"15\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"14\", \"4\"), type: \"straight\" },\n  {\n    pos: getCoord(\"14\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"13\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n    curveCheckPoints: [getCoord(\"12\", \"1.5\")],\n  },\n  {\n    pos: getCoord(\"11\", \"2\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"10\", \"3\"), type: \"straight\" },\n  {\n    pos: getCoord(\"10\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"9\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"8\", \"6\"), type: \"straight\" },\n  {\n    pos: getCoord(\"8\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n    curveCheckPoints: [getCoord(\"8.5\", \"11\")],\n  },\n  {\n    pos: getCoord(\"9\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"8\", \"13\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"7\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"6\", \"15\"), type: \"straight\" },\n  {\n    pos: getCoord(\"5\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"4\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n    curveCheckPoints: [getCoord(\"4.5\", \"13\"), getCoord(\"5\", \"12\")],\n  },\n];\n\nconst ghost3HomePathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"14\", \"10.5\"), type: \"straight\" },\n  {\n    pos: getCoord(\"14\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"13\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n    curveCheckPoints: [\n      getCoord(\"12\", \"1.5\"),\n      getCoord(\"11\", \"2\"),\n      getCoord(\"10\", \"1.5\"),\n    ],\n  },\n  { pos: getCoord(\"9\", \"1\"), type: \"straight\" },\n  {\n    pos: getCoord(\"7\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"6\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"7\", \"3\"), type: \"straight\" },\n  {\n    pos: getCoord(\"9\", \"3\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"10\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"11\", \"5\"), type: \"straight\" },\n  {\n    pos: getCoord(\"19\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"20\", \"6\"), type: \"straight\" },\n  {\n    pos: getCoord(\"20\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"19\", \"11\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n    curveCheckPoints: [\n      getCoord(\"18\", \"10.5\"),\n      getCoord(\"17\", \"10\"),\n      getCoord(\"16\", \"10.5\"),\n      getCoord(\"15.5\", \"11\"),\n    ],\n  },\n  { pos: getCoord(\"15\", \"12\"), type: \"straight\" },\n  {\n    pos: getCoord(\"15\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"14\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"13\", \"14\"), type: \"straight\" },\n  {\n    pos: getCoord(\"13\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n    curveCheckPoints: [\n      getCoord(\"12.5\", \"11\"),\n      getCoord(\"12\", \"10.5\"),\n      getCoord(\"10\", \"10.5\"),\n    ],\n  },\n  {\n    pos: getCoord(\"9\", \"11\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"8\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"7\", \"9\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"6\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n    curveCheckPoints: [getCoord(\"5.5\", \"11\")],\n  },\n  {\n    pos: getCoord(\"5\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"6\", \"13\"), type: \"straight\" },\n  {\n    pos: getCoord(\"12\", \"13\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"13\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"13.5\", \"11\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"14\", \"10.5\"), type: \"straight\" },\n];\n\nconst ghost4HomePathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"16\", \"7\"), type: \"straight\" },\n  {\n    pos: getCoord(\"16\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"15\", \"11\"), type: \"straight\" },\n  {\n    pos: getCoord(\"14\", \"11\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"13\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"12\", \"13\"), type: \"straight\" },\n  {\n    pos: getCoord(\"8\", \"13\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"7\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"6\", \"15\"), type: \"straight\" },\n  {\n    pos: getCoord(\"2\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"1\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n    curveCheckPoints: [\n      getCoord(\"1.5\", \"13\"),\n      getCoord(\"2\", \"12\"),\n      getCoord(\"1.5\", \"11\"),\n    ],\n  },\n  { pos: getCoord(\"1\", \"10\"), type: \"straight\" },\n  {\n    pos: getCoord(\"1\", \"6\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"2\", \"5\"), type: \"straight\" },\n  {\n    pos: getCoord(\"5\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"6\", \"6\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"7\", \"7\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"8\", \"6\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"9\", \"5\"), type: \"straight\" },\n  {\n    pos: getCoord(\"13\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"14\", \"4\"), type: \"straight\" },\n  {\n    pos: getCoord(\"14\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"15\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"16\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"17\", \"3\"), type: \"straight\" },\n  {\n    pos: getCoord(\"19\", \"3\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"20\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"19\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"18\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"19\", \"3\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"20\", \"4\"), type: \"straight\" },\n  {\n    pos: getCoord(\"20\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"19\", \"11\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n    curveCheckPoints: [getCoord(\"18\", \"10.5\")],\n  },\n  {\n    pos: getCoord(\"17\", \"10\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"16\", \"9\"), type: \"straight\" },\n  { pos: getCoord(\"16\", \"7\"), type: \"straight\" },\n];\n\nconst ghost5HomePathPoints: MazePathPoint[] = [\n  {\n    pos: getCoord(\"10\", \"3.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"9\", \"3\"), type: \"straight\" },\n  {\n    pos: getCoord(\"5\", \"3\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"4\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"3\", \"1\"), type: \"straight\" },\n  {\n    pos: getCoord(\"2\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"1\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"1.5\", \"3\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"2\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"3\", \"5\"), type: \"straight\" },\n  {\n    pos: getCoord(\"5\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"6\", \"6\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"5\", \"7\"), type: \"straight\" },\n  {\n    pos: getCoord(\"4\", \"7\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"3\", \"8\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"4\", \"9\"), type: \"straight\" },\n  {\n    pos: getCoord(\"7\", \"9\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"8\", \"10\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"8.5\", \"11\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"9\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"10\", \"13\"), type: \"straight\" },\n  {\n    pos: getCoord(\"12\", \"13\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"13\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"14\", \"11\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"15\", \"12\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"15\", \"14\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"16\", \"15\"), type: \"straight\" },\n  {\n    pos: getCoord(\"19\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"20\", \"14\"), type: \"straight\" },\n  {\n    pos: getCoord(\"20\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"19\", \"1\"), type: \"straight\" },\n  {\n    pos: getCoord(\"17\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"16\", \"2\"), type: \"straight\" },\n  {\n    pos: getCoord(\"16\", \"4\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"15\", \"5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"14\", \"4\"), type: \"straight\" },\n  {\n    pos: getCoord(\"14\", \"2\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"13\", \"1\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"12\", \"1.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"11\", \"2\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"10\", \"3.5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n];\n\nconst cameraHomeScrollPathPoints: CameraPathPoint[] = [\n  { pos: startPosition, lookAt: lookAtPosition },\n  // { pos: thirdPosition, lookAt: cameraHomeScrollEndLookAt },\n  { pos: secondPosition, lookAt: cameraLookAtSecondPosition },\n  { pos: thirdPosition, lookAt: cameraHomeScrollEndLookAt },\n  { pos: cameraHomeScrollEndPathPoint, lookAt: cameraHomeScrollEndLookAt },\n];\n\nconst cameraPOVPathPoints: MazePathPoint[] = [\n  {\n    pos: new THREE.Vector3(X[\"11\"], 0.40625, Z[\"7.5\"]),\n    type: \"straight\",\n    lookAtSequence: [\n      new THREE.Vector3(X[\"11\"], 0.2, Z[\"8\"]), // Look forward first\n      new THREE.Vector3(X[\"11\"], 1.2, Z[\"16\"]), // Look up\n      new THREE.Vector3(X[\"11\"], 0.55, Z[\"16\"]), // Look forward again\n    ],\n  },\n  {\n    pos: getCoord(\"11\", \"7.5\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"11\", \"9\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n    curveCheckPoints: [\n      new THREE.Vector3(X[\"11\"], Y, 0.6525),\n      getCoord(\"11.5\", \"10\"),\n      getCoord(\"12\", \"10.5\"),\n      getCoord(\"12.5\", \"11\"),\n    ],\n  },\n  {\n    pos: getCoord(\"13\", \"11\"),\n    type: \"straight\",\n  },\n  {\n    pos: getCoord(\"14.5\", \"11\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"15\", \"11.5\"),\n    type: \"straight\",\n  },\n  {\n    pos: getCoord(\"15\", \"14.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"14.5\", \"15\"),\n    type: \"straight\",\n  },\n  {\n    pos: getCoord(\"13.5\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"13\", \"14.5\"),\n    type: \"straight\",\n  },\n  {\n    pos: getCoord(\"13\", \"13.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"12.5\", \"13\"),\n    type: \"straight\",\n  },\n  {\n    pos: getCoord(\"7.5\", \"13\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"7\", \"13.5\"),\n    type: \"straight\",\n  },\n  {\n    pos: getCoord(\"7\", \"14.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  {\n    pos: getCoord(\"7.5\", \"15\"),\n    type: \"straight\",\n  },\n  {\n    pos: getCoord(\"10.5\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  {\n    pos: getCoord(\"11\", \"16\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n];\n\nconst ghost1POVPathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"16\", \"10\"), type: \"straight\" },\n  {\n    pos: getCoord(\"16\", \"10.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"15.5\", \"11\"), type: \"straight\" },\n  { pos: getCoord(\"14.5\", \"11\"), type: \"straight\" },\n];\n\nconst ghost2POVPathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"16\", \"15\"), type: \"straight\" },\n  {\n    pos: getCoord(\"15.5\", \"15\"),\n    type: \"curve\",\n    arc: \"lowerArc\",\n  },\n  { pos: getCoord(\"15\", \"14.5\"), type: \"straight\" },\n  { pos: getCoord(\"15\", \"13.5\"), type: \"straight\" },\n];\n\nconst ghost3POVPathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"9\", \"12\"), type: \"straight\" },\n  {\n    pos: getCoord(\"9\", \"12.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"9.5\", \"13\"), type: \"straight\" },\n  { pos: getCoord(\"10.5\", \"13\"), type: \"straight\" },\n];\n\nconst ghost4POVPathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"7\", \"14\"), type: \"straight\" },\n  {\n    pos: getCoord(\"7\", \"13.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"7.5\", \"13\"), type: \"straight\" },\n  { pos: getCoord(\"8.5\", \"13\"), type: \"straight\" },\n];\n\nconst ghost5POVPathPoints: MazePathPoint[] = [\n  { pos: getCoord(\"11\", \"16\"), type: \"straight\" },\n  {\n    pos: getCoord(\"11\", \"15.5\"),\n    type: \"curve\",\n    arc: \"upperArc\",\n  },\n  { pos: getCoord(\"10.5\", \"15\"), type: \"straight\" },\n  { pos: getCoord(\"9.5\", \"15\"), type: \"straight\" },\n];\n\n// start position, end position, ghost fade: 10, 20, cam fade: 50, 60, text start fade out: 90\n\n// @philipp - check ghost 3 - 5\n\nexport const povTriggerPositions = {\n  ghost1: {\n    triggerPos: new THREE.Vector3(0.65725, 0.55, 0.75325), // start ghost path\n    ghostStartFadeIn: new THREE.Vector3(0.7075, 0.55, 0.8035), // start ghost text fade in\n    ghostEndFadeIn: new THREE.Vector3(0.725, 0.55, 0.8035), // end ghost text fade in\n    ghostStartFadeOut: new THREE.Vector3(0.75, 0.55, 0.8035), // start ghost text fade out\n    camStartFadeIn: new THREE.Vector3(0.75775, 0.55, 0.8035), // start cam fade in\n    camEndFadeIn: new THREE.Vector3(0.775, 0.55, 0.8035), // end cam fade in\n    camStartFadeOut: new THREE.Vector3(0.84, 0.55, 0.8035), // start cam fade out\n    endPosition: new THREE.Vector3(0.85825, 0.55, 0.8035), // end of path\n    forceEndProgress: {\n      start: 0.1, // start of force end\n      end: 0.16, // end of force end\n    },\n  },\n  ghost2: {\n    triggerPos: new THREE.Vector3(0.9085, 0.55, 0.8035),\n    ghostStartFadeIn: new THREE.Vector3(0.95875, 0.55, 0.85375),\n    ghostEndFadeIn: new THREE.Vector3(0.95875, 0.55, 0.875),\n    ghostStartFadeOut: new THREE.Vector3(0.95875, 0.55, 0.89),\n    camStartFadeIn: new THREE.Vector3(0.95875, 0.55, 0.904),\n    camEndFadeIn: new THREE.Vector3(0.95875, 0.55, 0.93),\n    camStartFadeOut: new THREE.Vector3(0.95875, 0.55, 0.9975),\n    endPosition: new THREE.Vector3(0.95875, 0.55, 1.0045),\n    forceEndProgress: {\n      start: 0.17,\n      end: 0.22,\n    },\n  },\n  ghost3: {\n    triggerPos: new THREE.Vector3(0.75775, 0.55, 1.05475),\n    ghostStartFadeIn: new THREE.Vector3(0.7075, 0.55, 1.0045),\n    ghostEndFadeIn: new THREE.Vector3(0.7075, 0.55, 1.0045),\n    ghostStartFadeOut: new THREE.Vector3(0.6825, 0.55, 1.0045),\n    camStartFadeIn: new THREE.Vector3(0.65725, 0.55, 1.0045),\n    camEndFadeIn: new THREE.Vector3(0.65725, 0.55, 1.0045),\n    camStartFadeOut: new THREE.Vector3(0.6065, 0.55, 1.0045),\n    endPosition: new THREE.Vector3(0.55675, 0.55, 1.0045),\n    forceEndProgress: {\n      start: 0.23,\n      end: 0.33,\n    },\n  },\n  ghost4: {\n    triggerPos: new THREE.Vector3(0.65725, 0.55, 1.0045),\n    ghostStartFadeIn: new THREE.Vector3(0.5565, 0.55, 1.0045),\n    ghostEndFadeIn: new THREE.Vector3(0.5065, 0.55, 1.0045),\n    ghostStartFadeOut: new THREE.Vector3(0.4815, 0.55, 1.0045),\n    camStartFadeIn: new THREE.Vector3(0.45625, 0.55, 1.0045),\n    camEndFadeIn: new THREE.Vector3(0.45625, 0.55, 1.0045),\n    camStartFadeOut: new THREE.Vector3(0.4065, 0.55, 1.0045),\n    endPosition: new THREE.Vector3(0.35575, 0.55, 1.0045),\n    forceEndProgress: {\n      start: 0.38,\n      end: 0.47,\n    },\n  },\n  ghost5: {\n    triggerPos: new THREE.Vector3(0.15475, 0.55, 1.15525),\n    ghostStartFadeIn: new THREE.Vector3(0.1795, 0.55, 1.18),\n    ghostEndFadeIn: new THREE.Vector3(0.205, 0.55, 1.2055),\n    ghostStartFadeOut: new THREE.Vector3(0.23025, 0.55, 1.2055),\n    camStartFadeIn: new THREE.Vector3(0.25525, 0.55, 1.2055),\n    camEndFadeIn: new THREE.Vector3(0.25525, 0.55, 1.2055),\n    camStartFadeOut: new THREE.Vector3(0.3055, 0.55, 1.2055),\n    endPosition: new THREE.Vector3(0.35575, 0.55, 1.2055),\n    forceEndProgress: {\n      start: 0.52,\n      end: 0.59,\n    },\n  },\n};\n\nexport function getStartPosition() {\n  return startPosition;\n}\n\nexport function getSecondPosition() {\n  return secondPosition;\n}\n\nexport function getLookAtPosition() {\n  return lookAtPosition;\n}\n\nexport const homePaths = {\n  pacman: pacmanHomePathPoints,\n  ghost1: ghost1HomePathPoints,\n  ghost2: ghost2HomePathPoints,\n  ghost3: ghost3HomePathPoints,\n  ghost4: ghost4HomePathPoints,\n  ghost5: ghost5HomePathPoints,\n} as const;\n\nexport const povPaths = {\n  camera: cameraPOVPathPoints,\n  ghost1: ghost1POVPathPoints,\n  ghost2: ghost2POVPathPoints,\n  ghost3: ghost3POVPathPoints,\n  ghost4: ghost4POVPathPoints,\n  ghost5: ghost5POVPathPoints,\n} as const;\n\nexport function createHomeScrollPathPoints(\n  pausedPositions: Record<string, THREE.Vector3>\n): Record<string, PathPoint[]> {\n  const scrollPaths: Record<string, PathPoint[]> = {};\n\n  Object.entries(pausedPositions).forEach(([key, pausedPos]) => {\n    const arcPoint = new THREE.Vector3(\n      pausedPos.x * (1 / 4) + objectHomeScrollEndPathPoint.x * (3 / 4),\n      1.5,\n      pausedPos.z * (1 / 4) + objectHomeScrollEndPathPoint.z * (3 / 4)\n    );\n\n    scrollPaths[key] = [\n      { pos: pausedPos.clone() },\n      { pos: arcPoint },\n      { pos: objectHomeScrollEndPathPoint },\n    ];\n  });\n\n  return scrollPaths;\n}\n\nexport function getCameraHomeScrollPathPoints(): CameraPathPoint[] {\n  return cameraHomeScrollPathPoints;\n}\n","import * as THREE from \"three\";\nimport gsap from \"gsap\";\nimport ScrollTrigger from \"gsap/ScrollTrigger\";\nimport { getLookAtPosition, getStartPosition } from \"../paths/pathpoints\";\n\ngsap.registerPlugin(ScrollTrigger);\n\nconst CAMERA_CONFIG = {\n  originalFOV: 50,\n  wideFOV: 80,\n  near: 0.001,\n  far: 100,\n};\n\nexport const camera = new THREE.PerspectiveCamera(\n  50,\n  window.innerWidth / window.innerHeight,\n  CAMERA_CONFIG.near,\n  CAMERA_CONFIG.far\n);\n\nexport function setupCamera(): void {\n  const startPosition = getStartPosition();\n  const lookAtPosition = getLookAtPosition();\n  camera.position.set(startPosition.x, startPosition.y, startPosition.z);\n  camera.lookAt(lookAtPosition.x, lookAtPosition.y, lookAtPosition.z);\n}\n","import * as THREE from \"three\";\nimport { isMobile } from \"../config/config\";\nimport { DOM_ELEMENTS } from \"../config/dom-elements\";\nimport { camera } from \"./camera\";\n\nexport const scene = new THREE.Scene();\n\nconst renderer = new THREE.WebGLRenderer({\n  antialias: true,\n  alpha: true,\n  powerPreference: \"high-performance\",\n  precision: \"highp\",\n});\n\nconst clock = new THREE.Clock();\nconst frameCallbacks: (() => void)[] = [];\n\nexport function initRenderer(): void {\n  enhanceAntiAliasing();\n\n  if (DOM_ELEMENTS.mazeContainer) {\n    renderer.setSize(\n      DOM_ELEMENTS.mazeContainer.clientWidth,\n      DOM_ELEMENTS.mazeContainer.clientHeight\n    );\n    DOM_ELEMENTS.mazeContainer.appendChild(renderer.domElement);\n  } else {\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(renderer.domElement);\n  }\n\n  setPixelRatio();\n  window.addEventListener(\"resize\", setPixelRatio);\n\n  renderer.render(scene, camera);\n}\n\nfunction enhanceAntiAliasing(): void {\n  if (isMobile) {\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n  } else {\n    renderer.setPixelRatio(window.devicePixelRatio);\n  }\n  renderer.shadowMap.enabled = true;\n  renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n}\n\nfunction setPixelRatio(): void {\n  const pixelRatio = Math.min(window.devicePixelRatio, isMobile ? 2 : 3);\n  renderer.setPixelRatio(pixelRatio);\n\n  if (DOM_ELEMENTS.mazeContainer) {\n    renderer.setSize(\n      DOM_ELEMENTS.mazeContainer.clientWidth,\n      DOM_ELEMENTS.mazeContainer.clientHeight\n    );\n    camera.aspect =\n      DOM_ELEMENTS.mazeContainer.clientWidth /\n      DOM_ELEMENTS.mazeContainer.clientHeight;\n  } else {\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    camera.aspect = window.innerWidth / window.innerHeight;\n  }\n\n  camera.updateProjectionMatrix();\n}\n\nexport function setupLighting(): void {\n  const ambientLight = new THREE.AmbientLight(0xffffff);\n  scene.add(ambientLight);\n\n  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n  scene.add(directionalLight);\n  directionalLight.position.set(-5, 15, 10);\n  directionalLight.shadow.mapSize.width = 4096;\n  directionalLight.shadow.mapSize.height = 4096;\n  directionalLight.shadow.camera.left = -20;\n  directionalLight.shadow.camera.right = 20;\n  directionalLight.shadow.camera.top = 20;\n  directionalLight.shadow.camera.bottom = -20;\n  directionalLight.shadow.camera.near = 0.1;\n  directionalLight.shadow.camera.far = 50;\n  directionalLight.shadow.bias = -0.001;\n  directionalLight.shadow.radius = 3;\n  directionalLight.castShadow = true;\n}\n\nexport function createDebugLines(): void {\n  // Red line at z: 0.5, lying along x-axis at y: 0.55 (same height as ghosts)\n  const redLineGeometry = new THREE.BufferGeometry().setFromPoints([\n    new THREE.Vector3(-5, -0.55, 0),\n    new THREE.Vector3(5, -0.55, 0),\n  ]);\n  const redLineMaterial = new THREE.LineBasicMaterial({\n    color: 0xff0000,\n    linewidth: 3,\n  });\n  const redLine = new THREE.Line(redLineGeometry, redLineMaterial);\n  redLine.renderOrder = 999; // Render on top\n  scene.add(redLine);\n\n  // Green line at z: 1.5, lying along x-axis at y: 0.55 (same height as ghosts)\n  const greenLineGeometry = new THREE.BufferGeometry().setFromPoints([\n    new THREE.Vector3(-5, -0.55, 0.75),\n    new THREE.Vector3(5, -0.55, 0.75),\n  ]);\n  const greenLineMaterial = new THREE.LineBasicMaterial({\n    color: 0x00ff00,\n    linewidth: 3,\n  });\n  const greenLine = new THREE.Line(greenLineGeometry, greenLineMaterial);\n  greenLine.renderOrder = 999; // Render on top\n  scene.add(greenLine);\n}\n\nexport function startRenderLoop(): void {\n  const render = () => {\n    frameCallbacks.forEach((callback) => callback());\n\n    renderer.render(scene, camera);\n\n    requestAnimationFrame(render);\n  };\n  render();\n}\n\nexport function onFrame(callback: () => void): void {\n  frameCallbacks.push(callback);\n}\n\nexport { renderer, clock };\n","import * as THREE from \"three\";\nimport { ASSETS } from \"../config/config\";\n\nconst textureLoader = new THREE.TextureLoader();\n\nconst mazeTexture = textureLoader.load(ASSETS.mazeTexture);\n\nexport const mazeMaterial = new THREE.MeshMatcapMaterial({\n  matcap: mazeTexture,\n});\n\nexport const topMaterial = new THREE.MeshStandardMaterial({\n  color: 0xf2f9f9,\n  metalness: 0.4,\n  roughness: 0,\n  envMapIntensity: 10,\n});\n\nexport const ghostMaterial = new THREE.MeshPhysicalMaterial({\n  color: 0xffffff,\n  opacity: 0.9999, // Use 0.9999 instead of 1.0 to ensure consistent rendering with transmission\n  // This prevents Three.js from treating the material differently at opacity 1.0\n  transparent: true,\n  depthWrite: false,\n  depthTest: true,\n  blending: THREE.NormalBlending,\n  side: THREE.DoubleSide,\n  roughness: 0.75,\n  metalness: 0.2,\n  transmission: 0.5,\n  // Ensure transmission is always active regardless of opacity\n  // This helps maintain the glow effect consistently\n});\n\nexport const floorMaterial = new THREE.MeshStandardMaterial({\n  color: 0xffffff,\n  opacity: 0.8,\n  transparent: true,\n  roughness: 0.5,\n  metalness: 0.1,\n});\n\nconst pacmanMaterials = {\n  blue: new THREE.MeshBasicMaterial({\n    color: 0x1469d3,\n    transparent: true,\n    opacity: 1,\n  }),\n  white: new THREE.MeshBasicMaterial({\n    color: 0xffffff,\n    transparent: true,\n    opacity: 1,\n  }),\n  default: new THREE.MeshBasicMaterial({\n    color: 0x1469d3,\n    transparent: true,\n    opacity: 1,\n  }),\n};\n\n// @philipp - comment out the comments to change colors\n\nexport const materialMap = {\n  CAM_Pacman_Backframe: pacmanMaterials.blue,\n  \"CAM-Pacman_Bitcoin_1\": pacmanMaterials.white,\n  \"CAM-Pacman_Bitcoin_2\": pacmanMaterials.white,\n  \"CAM-Pacman_Bottom\": pacmanMaterials.blue,\n  \"CAM-Pacman_Top\": pacmanMaterials.blue,\n  \"CAM-Pacman_Eye\": pacmanMaterials.white,\n  // CAM_Pacman_Logo_1: pacmanMaterials.blue, // logo in the back, left side\n  // CAM_Pacman_Logo_2: pacmanMaterials.blue, // logo in the back, right side\n  CAM_Pacman_Logo_1: pacmanMaterials.white,\n  CAM_Pacman_Logo_2: pacmanMaterials.white,\n  \"CAM-Pacman_Shell_Boolean\": pacmanMaterials.blue,\n  \"CAM-Pacman_Shell\": pacmanMaterials.blue,\n  // \"CAM-Pacman_Bottom_electronic\": pacmanMaterials.blue,\n  // \"CAM-Pacman_Top_electronic\": pacmanMaterials.blue,\n  \"CAM-Pacman_Bottom_electronic\": pacmanMaterials.white, // bitcoin in the middle, left side\n  \"CAM-Pacman_Top_electronic\": pacmanMaterials.white, // bitcoin in the middle, right side\n  \"CAM-Pacman_Bottom_Text\": pacmanMaterials.white,\n  \"CAM-Pacman_Top_Text\": pacmanMaterials.white,\n  // \"CAM-Pacman_Bottom_Text\": pacmanMaterials.blue, // text on the bottom of pacman\n  // \"CAM-Pacman_Top_Text\": pacmanMaterials.blue, // text on the top of pacman\n  default: pacmanMaterials.blue,\n};\n","import * as THREE from \"three\";\nimport { ASSETS } from \"../config/config\";\nimport { GhostContainer } from \"../types/types\";\nimport { clock } from \"./scene\";\nimport {\n  mazeMaterial,\n  topMaterial,\n  ghostMaterial,\n  floorMaterial,\n  materialMap,\n} from \"./materials\";\n\nexport { clock };\n\nconst loader = new THREE.GLTFLoader();\n\nexport let pacmanMixer: THREE.AnimationMixer;\n\nexport const pacman = new THREE.Group();\n\nexport const ghosts: GhostContainer = {\n  pacman: pacman,\n  ghost1: new THREE.Mesh(new THREE.BufferGeometry(), ghostMaterial),\n  ghost2: new THREE.Mesh(new THREE.BufferGeometry(), ghostMaterial),\n  ghost3: new THREE.Mesh(new THREE.BufferGeometry(), ghostMaterial),\n  ghost4: new THREE.Mesh(new THREE.BufferGeometry(), ghostMaterial),\n  ghost5: new THREE.Mesh(new THREE.BufferGeometry(), ghostMaterial),\n};\n\nconst ghostContainers = {\n  Ghost_EUR: ghosts.ghost1,\n  Ghost_CHF: ghosts.ghost2,\n  Ghost_YEN: ghosts.ghost3,\n  Ghost_USD: ghosts.ghost4,\n  Ghost_GBP: ghosts.ghost5,\n};\n\n// CAM-Pacman_Shell -> should not be visible\n// CAM-Pacman_Shell_Boolean -> should not be visible\n// CAM-Pacman_Backframe -> should be visible (below the logo)\n// CAM-Pacman_Bottom -> should be visible (bottom)\n// CAM-Pacman_Bitcoin_1 -> should be visible (bitcoin in logo - left)\n// CAM-Pacman_Bitcoin_2 -> should be visible (bitcoin in logo - right)\n// CAM_Pacman_Logo_1 -> should be visible (octagon background of logo - left)\n// CAM_Pacman_Logo_2 -> should be visible (octagon background of logo - right)\n// CAM-Pacman_Eye -> should be visible (eyes)\n// CAM-Pacman_Bottom_electronic -> should be visible (bottom of bitcoin on pacman)\n// CAM-Pacman_Top_electronic -> should be visible (top of bitcoin on pacman)\n// CAM-Pacman_Bottom_Text -> should be visible (text on bottom of pacman)\n// CAM-Pacman_Top_Text -> should be visible (text on top of pacman)\n// CAM-Pacman_Top -> should be visible (top)\n\nconst greenMaterial = new THREE.MeshBasicMaterial({\n  color: 0x00ff00,\n  opacity: 1,\n  transparent: false,\n  depthWrite: true,\n  depthTest: true,\n});\n\nexport async function loadModel(scene: THREE.Scene): Promise<void> {\n  Object.values(ghosts).forEach((ghost) => scene.add(ghost));\n  scene.add(pacman);\n  return new Promise((resolve, reject) => {\n    loader.load(\n      ASSETS.mazeModel,\n      function (gltf) {\n        const model = gltf.scene;\n\n        // Print all elements in the 3D model\n        model.traverse((obj: THREE.Object3D) => {});\n\n        model.traverse((child: THREE.Object3D) => {\n          if (child.name === \"CAM-Pacman\") {\n            const children: THREE.Object3D[] = [];\n            child.traverse((subChild: THREE.Object3D) => {\n              if (\n                (subChild as any).isMesh &&\n                subChild.name !== \"CAM-Pacman_Shell\" &&\n                subChild.name !== \"CAM-Pacman_Shell_Boolean\" &&\n                subChild.name !== \"CAM-Pacman_Bitcoin_1\" &&\n                subChild.name !== \"CAM-Pacman_Bitcoin_2\"\n              ) {\n                const material =\n                  materialMap[subChild.name as keyof typeof materialMap] ||\n                  materialMap.default;\n                (subChild as THREE.Mesh).material = material;\n                children.push(subChild);\n              } else if (\n                subChild.name === \"CAM-Pacman_Shell\" ||\n                subChild.name === \"CAM-Pacman_Shell_Boolean\" ||\n                subChild.name === \"CAM-Pacman_Bitcoin_1\" ||\n                subChild.name === \"CAM-Pacman_Bitcoin_2\"\n              ) {\n                subChild.visible = false;\n              }\n            });\n\n            children.forEach((item) => ghosts.pacman.add(item));\n            ghosts.pacman.scale.set(0.05, 0.05, 0.05);\n            ghosts.pacman.rotation.set(Math.PI / 2, Math.PI / 2, Math.PI / 4);\n\n            pacmanMixer = new THREE.AnimationMixer(ghosts.pacman);\n            const pacmanActions: { [key: string]: THREE.AnimationAction } = {};\n\n            gltf.animations.forEach((clip: THREE.AnimationClip) => {\n              const action = pacmanMixer.clipAction(clip);\n\n              action.getMixer().addEventListener(\"loop\", function (e) {\n                e.action.getRoot().traverse(function (obj) {\n                  if (obj.userData && obj.userData.skipAnimation) {\n                    (obj as any).updateMorphTargets = function () {};\n                  }\n                });\n              });\n\n              pacmanActions[clip.name] = action;\n              action.setEffectiveWeight(0);\n              action.play();\n            });\n            Object.values(pacmanActions).forEach((action) => {\n              action.setEffectiveWeight(1);\n            });\n          } else if (\n            child.name &&\n            ghostContainers[child.name as keyof typeof ghostContainers]\n          ) {\n            const ghostContainer =\n              ghostContainers[child.name as keyof typeof ghostContainers];\n            const ghostGroup = new THREE.Group();\n\n            child.rotation.z = Math.PI;\n            child.rotation.x = Math.PI / 2;\n            child.scale.set(0.75, 0.75, 0.75);\n\n            const children: THREE.Object3D[] = [];\n            child.traverse((subChild: THREE.Object3D) => {\n              if ((subChild as any).isMesh) {\n                if (subChild.name && subChild.name.startsWith(\"Ghost_Mesh\")) {\n                  (subChild as THREE.Mesh).material = ghostMaterial;\n                } else if (\n                  subChild.name &&\n                  [\"EUR\", \"CHF\", \"YEN\", \"USD\", \"GBP\"].includes(subChild.name)\n                ) {\n                  subChild.visible = false;\n                }\n                children.push(subChild);\n              }\n            });\n\n            children.forEach((item) => {\n              if (\n                item.name &&\n                (item.name.includes(\"EUR\") ||\n                  item.name.startsWith(\"Ghost_Mesh\"))\n              ) {\n                item.rotation.z = Math.PI;\n                item.rotation.x = Math.PI / 2;\n              } else {\n                item.rotation.set(0, 0, 0);\n              }\n              ghostGroup.add(item);\n            });\n\n            if (ghostContainer) {\n              ghostContainer.add(ghostGroup);\n            } else {\n              console.warn(`ghostContainer for ${child.name} is undefined!`);\n            }\n          }\n\n          if ((child as any).isMesh) {\n            if (child.name === \"CAM-Arena_LowRes_Top\") {\n              (child as THREE.Mesh).material = topMaterial;\n              child.castShadow = true;\n            } else if (child.name === \"CAM-Arena_LowRes_Bottom\") {\n              (child as THREE.Mesh).material = mazeMaterial;\n              child.castShadow = true;\n            } else if (child.name === \"CAM-Floor\") {\n              const clonedChild = child.clone();\n              child.position.y = -0.1;\n              child.position.x = 0;\n              child.position.z = 0;\n              (child as THREE.Mesh).material = new THREE.MeshBasicMaterial({\n                color: 0xffffff,\n                opacity: 1,\n                transparent: false,\n                depthWrite: true,\n                depthTest: true,\n                side: THREE.FrontSide,\n              });\n              child.receiveShadow = false;\n              child.castShadow = true;\n              child.scale.set(0.5, 0.5, 0.5);\n\n              (clonedChild as THREE.Mesh).material = floorMaterial;\n              clonedChild.position.y = -0.5;\n              clonedChild.receiveShadow = true;\n              scene.add(clonedChild);\n            } else {\n              (child as THREE.Mesh).visible = false;\n            }\n          }\n        });\n\n        model.traverse(function (node: THREE.Object3D) {\n          if ((node as any).isMesh) {\n            node.castShadow = true;\n            node.receiveShadow = true;\n          }\n        });\n\n        scene.add(model);\n        model.position.set(0.5, 0.5, 0.5);\n\n        resolve();\n      },\n      function (progress: any) {},\n      function (error: any) {\n        reject(error);\n      }\n    );\n  });\n}\n","import * as THREE from \"three\";\nimport { MazePathPoint, PathPoint, CameraPathPoint } from \"../types/types\";\nimport {\n  homePaths,\n  povPaths,\n  createHomeScrollPathPoints,\n  getCameraHomeScrollPathPoints,\n} from \"./pathpoints\";\n\n// Cache for created paths\nconst pathCache = new Map<string, THREE.CurvePath<THREE.Vector3>>();\n\n// Optional utility for smoothing tangent directions when following paths\nexport class TangentSmoother {\n  private currentTangent: THREE.Vector3;\n  private smoothing: number;\n\n  constructor(initialTangent: THREE.Vector3, smoothing: number = 0.06) {\n    this.currentTangent = initialTangent.clone();\n    this.smoothing = smoothing;\n  }\n\n  update(targetTangent: THREE.Vector3): THREE.Vector3 {\n    this.currentTangent.lerp(targetTangent, this.smoothing);\n    return this.currentTangent.normalize();\n  }\n\n  reset(newTangent: THREE.Vector3): void {\n    this.currentTangent.copy(newTangent);\n  }\n\n  getCurrentTangent(): THREE.Vector3 {\n    return this.currentTangent.clone();\n  }\n\n  setSmoothingFactor(smoothing: number): void {\n    this.smoothing = Math.max(0.001, Math.min(1, smoothing));\n  }\n}\n\nfunction createMazePath(\n  pathPoints: MazePathPoint[],\n  pathName?: string\n): THREE.CurvePath<THREE.Vector3> {\n  const cacheKey = pathPoints\n    .map((p) => `${p.pos.x},${p.pos.y},${p.pos.z},${p.type},${p.arc || \"\"}`)\n    .join(\"|\");\n\n  if (pathCache.has(cacheKey)) {\n    return pathCache.get(cacheKey)!;\n  }\n\n  const path = new THREE.CurvePath<THREE.Vector3>();\n\n  let i = 0;\n  while (i < pathPoints.length - 1) {\n    const current = pathPoints[i];\n    const next = pathPoints[i + 1];\n\n    // Check if current point has curveCheckPoints\n    if (current.curveCheckPoints && current.curveCheckPoints.length > 0) {\n      // Create CatmullRomCurve3 with start point, checkpoints, and end point\n      const catmullPoints = [\n        current.pos,\n        ...current.curveCheckPoints,\n        next.pos,\n      ];\n      path.add(\n        new THREE.CatmullRomCurve3(catmullPoints, false, \"centripetal\", 0)\n      );\n    } else if (current.type === \"straight\") {\n      path.add(new THREE.LineCurve3(current.pos, next.pos));\n    } else {\n      // Create curve using existing logic\n      const midPoint = createNormalCurveMidPoint(current, next);\n      path.add(\n        new THREE.QuadraticBezierCurve3(current.pos, midPoint, next.pos)\n      );\n    }\n\n    i++;\n  }\n\n  pathCache.set(cacheKey, path);\n  return path;\n}\n\nfunction createNormalCurveMidPoint(\n  current: MazePathPoint,\n  next: MazePathPoint\n): THREE.Vector3 {\n  if (current.arc) {\n    const curveType = current.arc;\n\n    if (curveType === \"upperArc\") {\n      return new THREE.Vector3(current.pos.x, current.pos.y, next.pos.z);\n    } else if (curveType === \"lowerArc\") {\n      return new THREE.Vector3(next.pos.x, current.pos.y, current.pos.z);\n    } else if (curveType === \"forwardDownArc\") {\n      return new THREE.Vector3(current.pos.x, next.pos.y, current.pos.z);\n    }\n  }\n\n  return new THREE.Vector3(current.pos.x, current.pos.y, next.pos.z);\n}\n\nfunction createHomeScrollPath(\n  pathPoints: PathPoint[]\n): THREE.CurvePath<THREE.Vector3> {\n  const path = new THREE.CurvePath<THREE.Vector3>();\n\n  if (pathPoints.length === 3) {\n    const curve = new THREE.QuadraticBezierCurve3(\n      pathPoints[0].pos,\n      pathPoints[1].pos,\n      pathPoints[2].pos\n    );\n    path.add(curve);\n  }\n\n  return path;\n}\n\nfunction createCameraHomeScrollPath(\n  pathPoints: CameraPathPoint[]\n): THREE.CurvePath<THREE.Vector3> {\n  const path = new THREE.CurvePath<THREE.Vector3>();\n\n  if (pathPoints.length === 4) {\n    const curve = new THREE.CubicBezierCurve3(\n      pathPoints[0].pos,\n      pathPoints[1].pos,\n      pathPoints[2].pos,\n      pathPoints[3].pos\n    );\n    path.add(curve);\n  }\n\n  return path;\n}\n\nfunction createCameraPath(\n  pathPoints: CameraPathPoint[]\n): THREE.CurvePath<THREE.Vector3> {\n  const path = new THREE.CurvePath<THREE.Vector3>();\n\n  for (let i = 0; i < pathPoints.length - 1; i++) {\n    const current = pathPoints[i];\n    const next = pathPoints[i + 1];\n\n    // Check if it's a MazePathPoint-like structure\n    if (\"type\" in current && current.type === \"straight\") {\n      path.add(new THREE.LineCurve3(current.pos, next.pos));\n    } else if (\n      \"type\" in current &&\n      current.type === \"curve\" &&\n      \"arc\" in current\n    ) {\n      // Create curve using existing logic\n      const midPoint = createCameraCurveMidPoint(current, next);\n      path.add(\n        new THREE.QuadraticBezierCurve3(current.pos, midPoint, next.pos)\n      );\n    } else {\n      // Default to straight line for other types\n      path.add(new THREE.LineCurve3(current.pos, next.pos));\n    }\n  }\n\n  return path;\n}\n\nfunction createCameraCurveMidPoint(\n  current: CameraPathPoint,\n  next: CameraPathPoint\n): THREE.Vector3 {\n  if (\"arc\" in current && current.arc) {\n    const curveType = current.arc;\n\n    if (curveType === \"upperArc\") {\n      return new THREE.Vector3(current.pos.x, current.pos.y, next.pos.z);\n    } else if (curveType === \"lowerArc\") {\n      return new THREE.Vector3(next.pos.x, current.pos.y, current.pos.z);\n    } else if (curveType === \"forwardDownArc\") {\n      return new THREE.Vector3(current.pos.x, next.pos.y, current.pos.z);\n    }\n  }\n\n  return new THREE.Vector3(current.pos.x, current.pos.y, next.pos.z);\n}\n\nexport function getHomePaths(): Record<string, THREE.CurvePath<THREE.Vector3>> {\n  const paths: Record<string, THREE.CurvePath<THREE.Vector3>> = {};\n\n  Object.entries(homePaths).forEach(([key, pathPoints]) => {\n    paths[key] = createMazePath(pathPoints, key);\n  });\n\n  return paths;\n}\n\n// when scrolling, this is where the ghosts are going into the void\nexport function getHomeScrollPaths(\n  pausedPositions: Record<string, THREE.Vector3>\n): Record<string, THREE.CurvePath<THREE.Vector3>> {\n  const scrollPathPoints = createHomeScrollPathPoints(pausedPositions);\n  const cameraPathPoints = getCameraHomeScrollPathPoints();\n\n  const paths: Record<string, THREE.CurvePath<THREE.Vector3>> = {\n    camera: createCameraHomeScrollPath(cameraPathPoints),\n  };\n\n  Object.entries(scrollPathPoints).forEach(([key, pathPoints]) => {\n    paths[key] = createHomeScrollPath(pathPoints);\n  });\n\n  return paths;\n}\n\nexport function getPovPaths(): Record<string, THREE.CurvePath<THREE.Vector3>> {\n  const paths: Record<string, THREE.CurvePath<THREE.Vector3>> = {};\n\n  Object.entries(povPaths).forEach(([key, pathPoints]) => {\n    if (key === \"camera\") {\n      // Camera path uses CameraPathPoint[] and needs special handling\n      paths[key] = createMazePath(pathPoints as MazePathPoint[], key);\n    } else {\n      // Ghost paths use MazePathPoint[]\n      paths[key] = createMazePath(pathPoints as MazePathPoint[], key);\n    }\n  });\n\n  return paths;\n}\n","import * as THREE from \"three\";\n\n// Shared constants\nexport const OBJECT_KEYS = [\n  \"pacman\",\n  \"ghost1\",\n  \"ghost2\",\n  \"ghost3\",\n  \"ghost4\",\n  \"ghost5\",\n] as const;\nexport const GHOST_COLORS: Record<string, number> = {\n  ghost1: 0xff0000,\n  ghost2: 0x00ff00,\n  ghost3: 0x0000ff,\n  ghost4: 0xffff00,\n  ghost5: 0xff00ff,\n};\n\nconst CURRENCY_SYMBOLS = [\"EUR\", \"CHF\", \"YEN\", \"USD\", \"GBP\"] as const;\n\nexport function isCurrencySymbol(name: string): boolean {\n  return CURRENCY_SYMBOLS.some(\n    (symbol) => name === symbol || name.includes(symbol)\n  );\n}\n\nexport function isPacmanPart(name: string): boolean {\n  return (\n    name.includes(\"Shell\") ||\n    name.includes(\"Bitcoin_1\") ||\n    name.includes(\"Bitcoin_2\")\n  );\n}\n\nexport function calculateObjectOrientation(\n  object: THREE.Object3D,\n  tangent: THREE.Vector3,\n  objectType: \"pacman\" | \"ghost\" | \"camera\" = \"ghost\"\n): void {\n  if (!tangent || tangent.length() === 0) return;\n\n  const targetRotation = Math.atan2(tangent.x, tangent.z);\n\n  if (objectType === \"pacman\") {\n    object.rotation.set(\n      -(Math.PI / 2),\n      Math.PI,\n      -(targetRotation + Math.PI / 2)\n    );\n  } else if (objectType === \"ghost\") {\n    object.rotation.set(0, targetRotation, 0);\n  } else if (objectType === \"camera\") {\n    const lookAtPoint = object.position.clone().add(tangent);\n    object.lookAt(lookAtPoint);\n  }\n}\n\n// LAY_DOWN_QUAT_1: Laydown rotation rotated by 180 around Y-axis to fix orientation\n// Base rotation is Math.PI/2 around X-axis, then rotated 180 around Y-axis\nconst baseLayDownQuat = new THREE.Quaternion().setFromEuler(\n  new THREE.Euler(Math.PI / 2, 0, 0)\n);\nconst yAxis180 = new THREE.Quaternion().setFromAxisAngle(\n  new THREE.Vector3(0, 1, 0),\n  Math.PI\n);\n// Multiply: Y rotation first, then X rotation (reversed order to fix 180 orientation issue)\nexport const LAY_DOWN_QUAT_1 = yAxis180.clone().multiply(baseLayDownQuat);\n\nexport const LAY_DOWN_QUAT_2 = new THREE.Quaternion().setFromEuler(\n  new THREE.Euler(-Math.PI / 2, 0, 0)\n);\n\nexport function slerpToLayDown(\n  object: THREE.Object3D,\n  startQuat: THREE.Quaternion,\n  progress: number\n) {\n  const d1 = startQuat.angleTo(LAY_DOWN_QUAT_1);\n  const d2 = startQuat.angleTo(LAY_DOWN_QUAT_2);\n  const targetQuat = d1 < d2 ? LAY_DOWN_QUAT_1 : LAY_DOWN_QUAT_2;\n\n  object.quaternion.copy(startQuat.clone().slerp(targetQuat, progress));\n}\n","import * as THREE from \"three\";\nimport { isCurrencySymbol } from \"../animation/util\";\n\n/**\n * MATERIAL UTILITIES\n * \n * Centralized functions for managing material properties consistently across the codebase.\n * This prevents bugs where material properties (especially opacity/transparent) are set\n * inconsistently in different places.\n * \n * CRITICAL RULES:\n * - Ghost materials (MeshPhysicalMaterial with transmission) MUST always have transparent=true\n *   to preserve the glow effect, even at opacity 1.0\n * - Always use these utility functions instead of directly setting material properties\n */\n\n/**\n * Set opacity on all materials of an object\n * CRITICAL: For ghost materials with transmission, transparent is always kept true\n */\nexport function setObjectOpacity(\n  object: THREE.Object3D,\n  opacity: number,\n  options?: {\n    preserveTransmission?: boolean; // If true, keeps transparent=true for ghost materials (default: true)\n    skipCurrencySymbols?: boolean; // If true, skips currency symbol meshes (default: true)\n  }\n): void {\n  const preserveTransmission = options?.preserveTransmission !== false; // Default: true\n  const skipCurrencySymbols = options?.skipCurrencySymbols !== false; // Default: true\n\n  object.traverse((child) => {\n    if ((child as any).isMesh && (child as any).material) {\n      const mesh = child as THREE.Mesh;\n      const childName = child.name || \"\";\n\n      // Skip currency symbols if requested\n      if (skipCurrencySymbols && isCurrencySymbol(childName)) {\n        return;\n      }\n\n      if (Array.isArray(mesh.material)) {\n        mesh.material.forEach((mat: any) => {\n          setMaterialOpacity(mat, opacity, preserveTransmission);\n        });\n      } else {\n        setMaterialOpacity(mesh.material as any, opacity, preserveTransmission);\n      }\n    }\n  });\n}\n\n/**\n * Set opacity on a single material\n * CRITICAL: For MeshPhysicalMaterial with transmission, transparent is always kept true\n */\nexport function setMaterialOpacity(\n  material: THREE.Material,\n  opacity: number,\n  preserveTransmission: boolean = true\n): void {\n  const mat = material as any;\n  mat.opacity = opacity;\n\n  // CRITICAL: For MeshPhysicalMaterial with transmission, always keep transparent=true\n  // This preserves the glow effect even at opacity 1.0\n  // Three.js treats opacity 1.0 as non-transparent even with transparent=true,\n  // but we need transparent=true to maintain the transmission glow effect\n  if (preserveTransmission && mat.transmission !== undefined && mat.transmission > 0) {\n    mat.transparent = true;\n  } else {\n    // For other materials, set transparent based on opacity\n    mat.transparent = opacity < 1.0;\n  }\n\n  // Force material update\n  if (mat.needsUpdate !== undefined) {\n    mat.needsUpdate = true;\n  }\n}\n\n/**\n * Set transparent property on a single material\n * CRITICAL: For MeshPhysicalMaterial with transmission, transparent is always kept true\n * NOTE: This is used internally by setMaterialOpacity, but can be used directly if needed\n */\nexport function setMaterialTransparent(\n  material: THREE.Material,\n  transparent: boolean,\n  preserveTransmission: boolean = true\n): void {\n  const mat = material as any;\n\n  // CRITICAL: For MeshPhysicalMaterial with transmission, always keep transparent=true\n  // This preserves the glow effect\n  if (preserveTransmission && mat.transmission !== undefined && mat.transmission > 0) {\n    mat.transparent = true;\n  } else {\n    mat.transparent = transparent;\n  }\n\n  // Force material update\n  if (mat.needsUpdate !== undefined) {\n    mat.needsUpdate = true;\n  }\n}\n\n/**\n * Get opacity from the first material found in an object\n */\nexport function getObjectOpacity(object: THREE.Object3D): number {\n  let opacity = 1.0;\n\n  object.traverse((child) => {\n    if ((child as any).isMesh && (child as any).material) {\n      const mesh = child as THREE.Mesh;\n      if (Array.isArray(mesh.material)) {\n        if (mesh.material.length > 0) {\n          opacity = (mesh.material[0] as any).opacity ?? 1.0;\n        }\n      } else {\n        opacity = (mesh.material as any).opacity ?? 1.0;\n      }\n      return; // Only need first material\n    }\n  });\n\n  return opacity;\n}\n\n/**\n * Check if a material is a ghost material (has transmission)\n * NOTE: Currently not used, but kept for potential future use\n */\nexport function isGhostMaterial(material: THREE.Material): boolean {\n  const mat = material as any;\n  return mat.transmission !== undefined && mat.transmission > 0;\n}\n\n/**\n * Set all ghost materials to full opacity and ensure transparent=true\n * Use this when resetting objects to their default state\n */\nexport function resetGhostMaterialsToFullOpacity(object: THREE.Object3D): void {\n  setObjectOpacity(object, 1.0, {\n    preserveTransmission: true, // Keep transparent=true for glow effect\n    skipCurrencySymbols: true,\n  });\n}\n\n/**\n * Set ghost color on all materials of an object\n * Used to colorize ghosts (e.g., red for ghost1, green for ghost2, etc.)\n */\nexport function setGhostColor(\n  object: THREE.Object3D,\n  color: number,\n  options?: {\n    skipCurrencySymbols?: boolean; // If true, skips currency symbol meshes (default: true)\n  }\n): void {\n  const skipCurrencySymbols = options?.skipCurrencySymbols !== false; // Default: true\n\n  object.traverse((child) => {\n    if ((child as any).isMesh && (child as any).material) {\n      const mesh = child as THREE.Mesh;\n      const childName = child.name || \"\";\n\n      // Skip currency symbols if requested\n      if (skipCurrencySymbols && isCurrencySymbol(childName)) {\n        return;\n      }\n\n      if (Array.isArray(mesh.material)) {\n        mesh.material.forEach((mat: any) => {\n          if (mat.color && mat.color.getHex() !== color) {\n            mat.color.setHex(color);\n          }\n        });\n      } else {\n        const mat = mesh.material as any;\n        if (mat.color && mat.color.getHex() !== color) {\n          mat.color.setHex(color);\n        }\n      }\n    }\n  });\n}\n\n","import gsap from \"gsap\";\nimport * as THREE from \"three\";\nimport { scene } from \"../core/scene\";\nimport { SCALE, COLOR, OPACITY } from \"./constants\";\n\n/**\n * SCENE UTILITIES\n * \n * Centralized utility functions for common scene operations.\n * This prevents code duplication and ensures consistency.\n */\n\n/**\n * Set floor plane visibility, opacity, and transparency\n * Used across all scene presets to manage the floor plane consistently\n */\nexport function setFloorPlane(\n  visible: boolean,\n  opacity: number = OPACITY.FULL,\n  transparent: boolean = false\n): void {\n  scene.traverse((child) => {\n    if (child.name === \"CAM-Floor\") {\n      child.visible = visible;\n      if (child instanceof THREE.Mesh && child.material) {\n        const material = child.material as THREE.MeshBasicMaterial;\n        material.color.setHex(COLOR.WHITE);\n        material.opacity = opacity;\n        material.transparent = transparent;\n      }\n    }\n  });\n}\n\n/**\n * Set object scale based on object key and scene type\n * Ensures consistent scaling across all scenes\n */\nexport function setObjectScale(\n  object: THREE.Object3D,\n  key: string,\n  sceneType: \"home\" | \"intro\" | \"pov\" | \"outro\"\n): void {\n  let scale: number;\n\n  if (key === \"pacman\") {\n    scale = sceneType === \"intro\" ? SCALE.PACMAN_INTRO : SCALE.PACMAN_HOME;\n  } else {\n    scale = sceneType === \"pov\" ? SCALE.GHOST_POV : SCALE.GHOST_NORMAL;\n  }\n\n  // Set scale directly\n  object.scale.set(scale, scale, scale);\n  object.updateMatrixWorld(true);\n\n  // Also set via GSAP for consistency\n  gsap.set(object.scale, { x: scale, y: scale, z: scale });\n}\n\n/**\n * Kill all GSAP animations for an object and its materials\n * Useful when transitioning between scenes to prevent animation conflicts\n */\nexport function killObjectAnimations(object: THREE.Object3D): void {\n\n  // Kill object animations\n  gsap.killTweensOf(object);\n  gsap.killTweensOf(object.scale);\n  gsap.killTweensOf(object.position);\n  gsap.killTweensOf(object.rotation);\n  gsap.killTweensOf(object.quaternion);\n\n  // Kill material animations\n  object.traverse((child) => {\n    if ((child as any).isMesh && (child as any).material) {\n      const mesh = child as THREE.Mesh;\n      if (Array.isArray(mesh.material)) {\n        mesh.material.forEach((mat: any) => {\n          gsap.killTweensOf(mat);\n          gsap.killTweensOf(mat.opacity);\n        });\n      } else {\n        gsap.killTweensOf(mesh.material);\n        gsap.killTweensOf((mesh.material as any).opacity);\n      }\n    }\n  });\n}\n\n","import gsap from \"gsap\";\nimport * as THREE from \"three\";\nimport { camera } from \"../core/camera\";\nimport { ghosts } from \"../core/objects\";\nimport { slerpToLayDown, OBJECT_KEYS, GHOST_COLORS, isCurrencySymbol, isPacmanPart } from \"./util\";\nimport {\n  setMaterialOpacity,\n  setMaterialTransparent,\n  resetGhostMaterialsToFullOpacity,\n  setGhostColor,\n} from \"../core/material-utils\";\nimport {\n  updateObjectRotation,\n  syncStateFromObjects,\n} from \"./object-state\";\nimport { setFloorPlane, setObjectScale, killObjectAnimations } from \"./scene-utils\";\nimport { SCALE, COLOR, OPACITY } from \"./constants\";\n\n/**\n * SCENE PRESETS\n *\n * This file contains preset functions for each scene that set all object properties\n * when entering a scene. Modify these functions to adjust how objects appear in each scene.\n *\n * Each preset function receives:\n * - isEntering: true when entering the scene, false when leaving\n * - scrollDirection: \"up\" | \"down\" - helps determine behavior when scenes overlap\n *\n * ============================================================================\n * WHERE TO CHANGE SETTINGS:\n * ============================================================================\n *\n * 1. INTRO SCROLL PRESET (applyIntroScrollPreset):\n *    - Position offsets: INTRO_POSITION_OFFSET (lines 142-145)\n *    - Ghost colors: ghostColors object (lines 268-274)\n *    - Scale: pacman 0.1, ghosts 1.0 (lines 286-290)\n *    - Rotation: pacman uses laying down, ghosts use laying down + 180 X (lines 190-231)\n *    - Floor plane: opacity 0 (hidden) (lines 343-353)\n *\n * 2. HOME SCROLL PRESET (applyHomeScrollPreset):\n *    - Uses paused positions/rotations from home-loop\n *    - Floor plane: visible with opacity 1 (lines 79-89)\n *\n * 3. HOME LOOP PRESET (applyHomeLoopPreset):\n *    - Scale: all objects 1.0 (lines 24-29)\n *    - Floor plane: visible with opacity 1 (lines 50-60)\n *\n * 4. POV SCROLL PRESET (applyPovScrollPreset):\n *    - Pacman: hidden (lines 300-302)\n *    - Ghost scale: 0.5 (lines 307-309)\n *    - Ghost visibility: initially false (controlled by pov-scroll.ts triggers)\n *    - Floor plane: visible with opacity 1 (lines 321-331)\n *\n * 5. OUTRO SCROLL PRESET (applyOutroScrollPreset):\n *    - Currently minimal setup (add your outro-specific settings here)\n *    - Floor plane: visible with opacity 1 (lines 378-388)\n */\n\n// ============================================================================\n// HOME LOOP PRESET\n// ============================================================================\nexport function applyHomeLoopPreset(\n  isEntering: boolean,\n  scrollDirection?: \"up\" | \"down\"\n) {\n  if (!isEntering) return;\n\n  // Home loop uses paths, so positions/rotations are handled by home-loop.ts\n  // Here we just ensure visibility and scale settings\n  Object.entries(ghosts).forEach(([key, object]) => {\n    gsap.set(object, { visible: true });\n    setObjectScale(object, key, \"home\");\n\n    // Ensure all meshes are visible (except currencies)\n    object.traverse((child) => {\n      if ((child as any).isMesh && (child as any).material) {\n        const mesh = child as THREE.Mesh;\n        const childName = child.name || \"\";\n\n        // Keep currency symbols hidden in all scenes\n        if (isCurrencySymbol(childName)) {\n          mesh.visible = false;\n          return;\n        }\n\n        mesh.visible = true;\n      }\n    });\n\n    // Use centralized material utility to set opacity consistently\n    // This ensures ghost materials with transmission always have transparent=true\n    resetGhostMaterialsToFullOpacity(object);\n  });\n\n  // Floor plane visible\n  setFloorPlane(true, OPACITY.FULL, false);\n}\n\n// ============================================================================\n// HOME SCROLL PRESET\n// ============================================================================\nexport function applyHomeScrollPreset(\n  isEntering: boolean,\n  scrollDirection?: \"up\" | \"down\",\n  pausedPositions?: Record<string, THREE.Vector3>,\n  pausedRotations?: Record<string, THREE.Quaternion>\n) {\n  if (!isEntering) return;\n\n  // Use paused positions/rotations if provided (from home-loop)\n  if (pausedPositions && pausedRotations) {\n    Object.entries(ghosts).forEach(([key, object]) => {\n      if (pausedPositions[key]) {\n        // CRITICAL: Set position directly for visual update\n        // Do NOT update state position here - only home-loop should update positions\n        object.position.set(\n          pausedPositions[key].x,\n          pausedPositions[key].y,\n          pausedPositions[key].z\n        );\n        \n        // Also use gsap.set for any GSAP tracking\n        gsap.set(object.position, {\n          x: pausedPositions[key].x,\n          y: pausedPositions[key].y,\n          z: pausedPositions[key].z,\n        });\n      }\n\n      if (pausedRotations[key]) {\n        // CRITICAL: Do NOT set rotation here - it will be set by updateScrollAnimation\n        // Setting it here would interfere with the scroll-based rotation animation\n        // The rotation will be animated during scroll based on progress\n        // We just ensure the object is visible and positioned correctly\n      }\n\n      gsap.set(object, { visible: true });\n\n      // CRITICAL: Set correct scales using centralized utility\n      setObjectScale(object, key, \"home\");\n\n      // Set visibility but DON'T change opacity here - opacity is managed individually per object in home-scroll.ts\n      object.traverse((child) => {\n        if ((child as any).isMesh && (child as any).material) {\n          const mesh = child as THREE.Mesh;\n          const childName = child.name || \"\";\n\n          // Keep currency symbols hidden in all scenes\n          if (isCurrencySymbol(childName)) {\n            mesh.visible = false;\n            return;\n          }\n\n          mesh.visible = true;\n\n          // Don't set opacity here - let home-scroll.ts handle it per object\n          // Just ensure materials are transparent-capable using centralized utility\n          if (Array.isArray(mesh.material)) {\n            mesh.material.forEach((mat: any) => {\n              setMaterialTransparent(mat, true, true);\n            });\n          } else {\n            setMaterialTransparent(mesh.material as any, true, true);\n          }\n        }\n      });\n    });\n  }\n\n  // Floor plane visible\n  setFloorPlane(true, OPACITY.FULL, false);\n}\n\n// ============================================================================\n// INTRO SCROLL PRESET\n// ============================================================================\n\n// Position offsets (hardcoded from previous adjuster values)\n// Export for use in intro-scroll updates\nexport const INTRO_POSITION_OFFSET = {\n  x: 4.3,\n  y: -2.0,\n  z: 0.0,\n};\n\n// Store target quaternions for intro (calculated once)\nlet pacmanTargetQuaternion: THREE.Quaternion | null = null;\nlet ghostTargetQuaternion: THREE.Quaternion | null = null;\nlet introInitialRotations: Record<string, THREE.Quaternion> = {};\n\n// Export getters for quaternions (used by intro-scroll animation updates)\nexport function getPacmanTargetQuaternion(): THREE.Quaternion | null {\n  return pacmanTargetQuaternion;\n}\n\nexport function getGhostTargetQuaternion(): THREE.Quaternion | null {\n  return ghostTargetQuaternion;\n}\n\nexport function applyIntroScrollPreset(\n  isEntering: boolean,\n  scrollDirection?: \"up\" | \"down\"\n) {\n  if (!isEntering) return;\n\n  // Calculate target quaternions ONCE (they don't change during scroll)\n  // Rotate objects 180 degrees to match camera rotation\n  if (!pacmanTargetQuaternion || !ghostTargetQuaternion) {\n    // Create rotation quaternions once\n    const xRotation180 = new THREE.Quaternion().setFromEuler(\n      new THREE.Euler(Math.PI, 0, 0)\n    );\n\n    const pacmanObj = ghosts.pacman;\n    if (pacmanObj) {\n      if (!introInitialRotations[\"pacman\"]) {\n        introInitialRotations[\"pacman\"] = pacmanObj.quaternion.clone();\n      }\n\n      pacmanTargetQuaternion = introInitialRotations[\"pacman\"].clone();\n      slerpToLayDown(pacmanObj, introInitialRotations[\"pacman\"], 1.0);\n      // Add +90 degrees rotation on X-axis\n      const pacmanRotation90 = new THREE.Quaternion().setFromEuler(\n        new THREE.Euler(Math.PI / 2, 0, 0)\n      );\n      pacmanObj.quaternion.multiply(pacmanRotation90);\n      // Rotate 180 degrees on Y-axis to match camera rotation\n      const pacmanRotationY180 = new THREE.Quaternion().setFromEuler(\n        new THREE.Euler(0, Math.PI, 0)\n      );\n      pacmanObj.quaternion.multiply(pacmanRotationY180);\n      // Rotate another 180 degrees on Y-axis (total 360 = 0, but adds to match camera)\n      pacmanObj.quaternion.multiply(pacmanRotationY180);\n      // Rotate 180 degrees on X-axis to fix upside-down orientation\n      pacmanObj.quaternion.multiply(xRotation180);\n      pacmanTargetQuaternion = pacmanObj.quaternion.clone();\n      pacmanObj.quaternion.copy(introInitialRotations[\"pacman\"]);\n    }\n\n    const ghostObj = ghosts.ghost1;\n    if (ghostObj) {\n      if (!introInitialRotations[\"ghost1\"]) {\n        introInitialRotations[\"ghost1\"] = ghostObj.quaternion.clone();\n      }\n\n      ghostTargetQuaternion = introInitialRotations[\"ghost1\"].clone();\n      slerpToLayDown(ghostObj, introInitialRotations[\"ghost1\"], 1.0);\n      // Apply 180 degrees on X-axis (current rotation that makes heads face down)\n      ghostObj.quaternion.multiply(xRotation180);\n      // Add another 180 degrees on X-axis to flip them up\n      ghostObj.quaternion.multiply(xRotation180);\n      // Rotate 180 degrees on Y-axis to match camera rotation\n      const ghostRotationY180 = new THREE.Quaternion().setFromEuler(\n        new THREE.Euler(0, Math.PI, 0)\n      );\n      ghostObj.quaternion.multiply(ghostRotationY180);\n      // Rotate another 180 degrees on Y-axis (total 360 = 0, but adds to match camera)\n      ghostObj.quaternion.multiply(ghostRotationY180);\n      // Rotate another 180 degrees on X-axis to fix upside-down orientation\n      ghostObj.quaternion.multiply(xRotation180);\n      ghostTargetQuaternion = ghostObj.quaternion.clone();\n      ghostObj.quaternion.copy(introInitialRotations[\"ghost1\"]);\n    }\n\n    // Store initial rotations for all objects\n    OBJECT_KEYS.forEach((key) => {\n      const obj = ghosts[key];\n      if (obj && !introInitialRotations[key]) {\n        introInitialRotations[key] = obj.quaternion.clone();\n      }\n    });\n  }\n\n  // Calculate start position (far left)\n  const baseX = camera.position.x - 5.0;\n  const startPosition = new THREE.Vector3(\n    baseX + INTRO_POSITION_OFFSET.x,\n    camera.position.y + INTRO_POSITION_OFFSET.y,\n    camera.position.z + INTRO_POSITION_OFFSET.z\n  );\n\n  const objectsToAnimate = OBJECT_KEYS;\n\n  // Use gsap.set to immediately set all properties\n  objectsToAnimate.forEach((key, index) => {\n    const object = ghosts[key];\n    if (!object) return;\n\n    // CRITICAL: Kill all GSAP animations first to prevent interference\n    killObjectAnimations(object);\n\n    // Calculate position with stagger\n    const behindOffset = index === 0 ? 0 : -0.5 * index;\n    const pos = new THREE.Vector3(\n      startPosition.x + behindOffset,\n      startPosition.y,\n      startPosition.z\n    );\n\n    // Set position, rotation, scale, visibility using gsap.set\n    gsap.set(object.position, {\n      x: pos.x,\n      y: pos.y,\n      z: pos.z,\n    });\n\n    // Set rotation quaternion directly\n    if (key === \"pacman\" && pacmanTargetQuaternion) {\n      object.quaternion.copy(pacmanTargetQuaternion);\n    } else if (ghostTargetQuaternion) {\n      object.quaternion.copy(ghostTargetQuaternion);\n    }\n\n    // CRITICAL: Set scale using centralized utility\n    setObjectScale(object, key, \"intro\");\n\n    gsap.set(object, { visible: true });\n\n    // CRITICAL: Set opacity and visibility for all meshes IMMEDIATELY and EXPLICITLY\n    object.traverse((child) => {\n      if ((child as any).isMesh && (child as any).material) {\n        const mesh = child as THREE.Mesh;\n        const childName = child.name || \"\";\n\n        // Keep currency symbols and pacman parts hidden\n        if (isCurrencySymbol(childName) || (key === \"pacman\" && isPacmanPart(childName))) {\n          mesh.visible = false;\n          return;\n        }\n\n        // CRITICAL: Force visibility and opacity IMMEDIATELY\n        mesh.visible = true;\n\n        // Set opacity using centralized utility (not via GSAP to ensure immediate effect)\n        if (Array.isArray(mesh.material)) {\n          mesh.material.forEach((mat: any) => {\n            setMaterialOpacity(mat, 1, true);\n          });\n        } else {\n          setMaterialOpacity(mesh.material as any, 1, true);\n        }\n\n        // Set ghost colors using centralized utility\n        if (GHOST_COLORS[key] && key !== \"pacman\") {\n          setGhostColor(object, GHOST_COLORS[key]);\n        }\n      }\n    });\n\n    object.updateMatrixWorld(true);\n  });\n\n  // Hide floor plane (white with opacity 0)\n  setFloorPlane(true, OPACITY.HIDDEN, true);\n}\n\n// ============================================================================\n// POV SCROLL PRESET\n// ============================================================================\nexport function applyPovScrollPreset(\n  isEntering: boolean,\n  scrollDirection?: \"up\" | \"down\"\n) {\n  if (!isEntering) return;\n\n  // Hide pacman during POV section\n  if (ghosts.pacman) {\n    gsap.set(ghosts.pacman, { visible: false });\n  }\n\n  // Ghosts are positioned by pov-scroll.ts, but set initial visibility\n  Object.entries(ghosts).forEach(([key, object]) => {\n    if (key !== \"pacman\") {\n      // Initially invisible, will be shown by pov-scroll.ts when triggered\n      gsap.set(object, { visible: false });\n      gsap.set(object.scale, { x: 0.5, y: 0.5, z: 0.5 });\n\n      // Reset opacity\n      object.traverse((child) => {\n        if ((child as any).isMesh && (child as any).material) {\n          const mesh = child as THREE.Mesh;\n          if (Array.isArray(mesh.material)) {\n            mesh.material.forEach((mat: any) => {\n              setMaterialOpacity(mat, 1, true);\n            });\n          } else {\n            setMaterialOpacity(mesh.material as any, 1, true);\n          }\n        }\n      });\n    }\n  });\n\n  // Floor plane visible\n  setFloorPlane(true, OPACITY.FULL, false);\n}\n\n// ============================================================================\n// OUTRO SCROLL PRESET\n// ============================================================================\nexport function applyOutroScrollPreset(\n  isEntering: boolean,\n  scrollDirection?: \"up\" | \"down\"\n) {\n  if (!isEntering) return;\n\n  // Outro scroll doesn't manipulate 3D objects directly\n  // This is where you can add any outro-specific object settings\n\n  // Floor plane visible\n  setFloorPlane(true, OPACITY.FULL, false);\n}\n\n// ============================================================================\n// UTILITY: Get scroll direction\n// ============================================================================\nlet lastScrollY = window.scrollY;\nexport function getScrollDirection(): \"up\" | \"down\" {\n  const currentScrollY = window.scrollY;\n  const direction = currentScrollY > lastScrollY ? \"down\" : \"up\";\n  lastScrollY = currentScrollY;\n  return direction;\n}\n\n// ============================================================================\n// UTILITY: Reset all preset caches (call when needed)\n// ============================================================================\nexport function resetPresetCaches() {\n  pacmanTargetQuaternion = null;\n  ghostTargetQuaternion = null;\n  introInitialRotations = {};\n}\n","import * as THREE from \"three\";\nimport { ghosts } from \"../core/objects\";\nimport { setObjectOpacity } from \"../core/material-utils\";\n\n/**\n * UNIFIED OBJECT STATE MANAGER\n * \n * Single source of truth for all object positions, rotations, and states.\n * This ensures consistency across all scenes (home-loop, home-scroll, intro-scroll, pov-scroll).\n */\n\nexport interface ObjectState {\n  position: THREE.Vector3;\n  rotation: THREE.Quaternion;\n  scale: THREE.Vector3;\n  visible: boolean;\n  opacity: number; // Material opacity (0-1)\n}\n\n// Home-loop specific state - stores the t-value used for path calculations\n// This ensures home-scroll uses the exact same positions as home-loop\nexport interface HomeLoopState {\n  t: number; // Current t-value (0-1) for home-loop paths\n  pausedT: number; // Last paused t-value when home-loop stopped\n  animationTime: number; // Current animation time\n}\n\nexport const homeLoopState: HomeLoopState = {\n  t: 0,\n  pausedT: 0,\n  animationTime: 0,\n};\n\n// Current state - always reflects actual object positions\nexport const currentObjectStates: Record<string, ObjectState> = {};\n\n// Flag to track if home-loop is active (only home-loop should update positions)\nlet isHomeLoopActive = false;\n\nexport function setHomeLoopActive(active: boolean) {\n  isHomeLoopActive = active;\n}\n\nexport function getIsHomeLoopActive(): boolean {\n  return isHomeLoopActive;\n}\n\n// Update home-loop t-value (called by home-loop every frame)\nexport function updateHomeLoopT(t: number, animationTime: number) {\n  homeLoopState.t = t;\n  homeLoopState.animationTime = animationTime;\n}\n\n// Update paused t-value (called when home-loop stops)\nexport function updateHomeLoopPausedT(pausedT: number) {\n  homeLoopState.pausedT = pausedT;\n}\n\n// Get current home-loop t-value (for active loop)\nexport function getHomeLoopT(): number {\n  return homeLoopState.t;\n}\n\n// Get paused t-value (for when loop is stopped)\nexport function getHomeLoopPausedT(): number {\n  return homeLoopState.pausedT;\n}\n\n// Get current home-loop animation time\nexport function getHomeLoopAnimationTime(): number {\n  return homeLoopState.animationTime;\n}\n\n// Initialize state for all objects\nexport function initializeObjectStates() {\n  Object.entries(ghosts).forEach(([key, object]) => {\n    // Get initial opacity from first material found\n    let initialOpacity = 1.0;\n    object.traverse((child) => {\n      if ((child as any).isMesh && (child as any).material) {\n        const mesh = child as THREE.Mesh;\n        if (Array.isArray(mesh.material)) {\n          if (mesh.material.length > 0) {\n            initialOpacity = (mesh.material[0] as any).opacity ?? 1.0;\n          }\n        } else {\n          initialOpacity = ((mesh.material as any).opacity ?? 1.0);\n        }\n        return; // Only need first material\n      }\n    });\n\n    currentObjectStates[key] = {\n      position: object.position.clone(),\n      rotation: object.quaternion.clone(),\n      scale: object.scale.clone(),\n      visible: object.visible,\n      opacity: initialOpacity,\n    };\n  });\n}\n\n// Update state from actual object positions\n// CRITICAL: This should ONLY be called by home-loop when it's active\n// Other parts should only READ positions, not write them\nexport function syncStateFromObjects() {\n  // Only allow syncing if home-loop is active\n  // This ensures positions are only updated by home-loop\n  if (!isHomeLoopActive) {\n    return;\n  }\n\n  Object.entries(ghosts).forEach(([key, object]) => {\n    if (currentObjectStates[key]) {\n      // Fast path: just update position/rotation/scale/visible\n      currentObjectStates[key].position.copy(object.position);\n      currentObjectStates[key].rotation.copy(object.quaternion);\n      currentObjectStates[key].scale.copy(object.scale);\n      currentObjectStates[key].visible = object.visible;\n      // Opacity is managed directly by animations - don't sync it here\n      // This avoids expensive traverse() calls on every position update\n    } else {\n      // Initial state creation: get opacity from first material\n      let initialOpacity = 1.0;\n      object.traverse((child) => {\n        if ((child as any).isMesh && (child as any).material) {\n          const mesh = child as THREE.Mesh;\n          if (Array.isArray(mesh.material)) {\n            if (mesh.material.length > 0) {\n              initialOpacity = (mesh.material[0] as any).opacity ?? 1.0;\n            }\n          } else {\n            initialOpacity = ((mesh.material as any).opacity ?? 1.0);\n          }\n          return; // Only need first material\n        }\n      });\n\n      currentObjectStates[key] = {\n        position: object.position.clone(),\n        rotation: object.quaternion.clone(),\n        scale: object.scale.clone(),\n        visible: object.visible,\n        opacity: initialOpacity,\n      };\n    }\n  });\n}\n\n// Apply state to objects\nexport function applyStateToObjects() {\n  Object.entries(currentObjectStates).forEach(([key, state]) => {\n    const object = ghosts[key];\n    if (object) {\n      object.position.copy(state.position);\n      object.quaternion.copy(state.rotation);\n      object.scale.copy(state.scale);\n      object.visible = state.visible;\n      \n      // Apply opacity using centralized material utility\n      // This ensures ghost materials with transmission always have transparent=true\n      setObjectOpacity(object, state.opacity, {\n        preserveTransmission: true, // Keep transparent=true for glow effect\n        skipCurrencySymbols: true,\n      });\n    }\n  });\n}\n\n// Get current positions (for home-scroll)\nexport function getCurrentPositions(): Record<string, THREE.Vector3> {\n  const positions: Record<string, THREE.Vector3> = {};\n  Object.entries(currentObjectStates).forEach(([key, state]) => {\n    positions[key] = state.position.clone();\n  });\n  return positions;\n}\n\n// Get current rotations (for home-scroll)\nexport function getCurrentRotations(): Record<string, THREE.Quaternion> {\n  const rotations: Record<string, THREE.Quaternion> = {};\n  Object.entries(currentObjectStates).forEach(([key, state]) => {\n    rotations[key] = state.rotation.clone();\n  });\n  return rotations;\n}\n\n// Update position for a specific object\n// CRITICAL: This should ONLY be called by home-loop\n// Other parts should NOT update positions - they should only read them\nexport function updateObjectPosition(key: string, position: THREE.Vector3) {\n  // Only allow position updates if home-loop is active\n  if (!isHomeLoopActive) {\n    return;\n  }\n\n  if (currentObjectStates[key]) {\n    currentObjectStates[key].position.copy(position);\n  }\n}\n\n// Update rotation for a specific object\nexport function updateObjectRotation(key: string, rotation: THREE.Quaternion) {\n  if (currentObjectStates[key]) {\n    currentObjectStates[key].rotation.copy(rotation);\n  }\n}\n\n// Update scale for a specific object\nexport function updateObjectScale(key: string, scale: THREE.Vector3) {\n  if (currentObjectStates[key]) {\n    currentObjectStates[key].scale.copy(scale);\n  }\n}\n\n// Update visibility for a specific object\nexport function updateObjectVisibility(key: string, visible: boolean) {\n  if (currentObjectStates[key]) {\n    currentObjectStates[key].visible = visible;\n  }\n}\n\n\n\n","import gsap from \"gsap\";\nimport * as THREE from \"three\";\nimport { camera } from \"../core/camera\";\nimport { ghosts } from \"../core/objects\";\nimport { getCameraHomeScrollPathPoints } from \"../paths/pathpoints\";\nimport { getHomeScrollPaths } from \"../paths/paths\";\nimport { homeLoopHandler } from \"./home-loop\";\nimport { LAY_DOWN_QUAT_1 } from \"./util\";\nimport { applyHomeScrollPreset, getScrollDirection } from \"./scene-presets\";\nimport { updateObjectRotation, getCurrentRotations } from \"./object-state\";\nimport { setObjectOpacity, getObjectOpacity } from \"../core/material-utils\";\nimport { SCROLL_SELECTORS } from \"./constants\";\n\nlet homeScrollTimeline: gsap.core.Timeline | null = null;\nconst originalFOV = 50;\n\nlet startPositions: Record<string, THREE.Vector3> = {};\n\nexport function initHomeScrollAnimation() {\n  if (homeScrollTimeline) {\n    homeScrollTimeline.kill();\n    homeScrollTimeline = null;\n  }\n\n  // Camera path points (unchanged - camera still uses bezier curve)\n  const cameraPathPoints = getCameraHomeScrollPathPoints();\n\n  // Create camera path\n  const cameraPath = new THREE.CurvePath<THREE.Vector3>();\n  if (cameraPathPoints.length === 4) {\n    const cameraCurve = new THREE.CubicBezierCurve3(\n      cameraPathPoints[0].pos,\n      cameraPathPoints[1].pos,\n      cameraPathPoints[2].pos,\n      cameraPathPoints[3].pos\n    );\n    cameraPath.add(cameraCurve);\n  }\n\n  // Shared function for onEnter and onEnterBack to avoid code duplication\n  const handleScrollEnter = () => {\n    requestAnimationFrame(() => {\n      const freshRotations = getCurrentRotations();\n      const scrollDir = getScrollDirection();\n\n      // CRITICAL: Store ACTUAL current positions (not t-values)\n      // These are the positions where objects are RIGHT NOW when entering home-scroll\n      const freshPositions: Record<string, THREE.Vector3> = {};\n      Object.entries(ghosts).forEach(([key, object]) => {\n        freshPositions[key] = object.position.clone();\n      });\n\n      // Store for use in animations\n      startPositions = freshPositions;\n\n      // Apply preset FIRST to set positions and opacity correctly\n      applyHomeScrollPreset(true, scrollDir, freshPositions, freshRotations);\n\n      // Update startPositions with the positions set by applyHomeScrollPreset\n      Object.entries(ghosts).forEach(([key, object]) => {\n        startPositions[key] = object.position.clone();\n      });\n\n      // Recreate animations with fresh FROM values (including camera)\n      // Create object animations FIRST (this clears the timeline)\n      createObjectAnimations();\n      // Then create camera animation (after timeline is cleared, so it's not removed)\n      createCameraAnimation();\n    });\n  };\n\n  homeScrollTimeline = gsap.timeline({\n    scrollTrigger: {\n      id: \"homeScroll\",\n      trigger: SCROLL_SELECTORS.HOME,\n      start: \"top top\",\n      end: \"bottom top\",\n      scrub: 0.5,\n      onEnter: handleScrollEnter,\n      onEnterBack: handleScrollEnter,\n      onScrubComplete: () => {\n        requestAnimationFrame(() => {\n          homeLoopHandler();\n        });\n      },\n    },\n  });\n\n  // Initialize startPositions with current values\n  // Note: ghosts already contains pacman, so we don't need to add it separately\n  const allObjects = Object.entries(ghosts);\n  allObjects.forEach(([key, object]) => {\n    startPositions[key] = object.position.clone();\n  });\n\n  // Function to create/update animations with current FROM values\n  const createObjectAnimations = () => {\n    // Clear timeline to remove all existing animations\n    // Note: This will also clear camera animation, so it must be re-added after\n    if (homeScrollTimeline) {\n      homeScrollTimeline.clear();\n    }\n\n    // Kill existing animations\n    allObjects.forEach(([key, object]) => {\n      gsap.killTweensOf(object);\n      gsap.killTweensOf(object.position);\n      gsap.killTweensOf(object.rotation);\n    });\n\n    // Create paths for each object based on their start positions\n    const homeScrollPaths = getHomeScrollPaths(startPositions);\n\n    // Collect all animation data in arrays for stagger\n    const animPropsArray: any[] = [];\n    const animationData: Array<{\n      key: string;\n      object: THREE.Object3D;\n      path: THREE.CurvePath<THREE.Vector3>;\n      startEuler: THREE.Euler;\n      endEuler: THREE.Euler;\n    }> = [];\n\n    allObjects.forEach(([key, object]) => {\n      // Get current opacity using centralized utility\n      const currentMaterialOpacity = getObjectOpacity(object);\n\n      // Get materials and CLONE them to avoid shared material issues\n      // Materials are shared between objects (e.g., ghostMaterial), so we need to clone them\n      // This ensures each object has its own material instance and opacity can be animated independently\n      object.traverse((child) => {\n        if ((child as any).isMesh && (child as any).material) {\n          const mesh = child as THREE.Mesh;\n          if (Array.isArray(mesh.material)) {\n            // Clone each material in the array\n            const clonedMaterials = mesh.material.map((originalMat: any) => {\n              const clonedMat = originalMat.clone();\n              // Preserve current opacity on cloned material\n              clonedMat.opacity = currentMaterialOpacity;\n              clonedMat.transparent = true; // Always allow transparency\n              return clonedMat;\n            });\n            mesh.material = clonedMaterials;\n          } else {\n            // Clone single material\n            const clonedMat = (mesh.material as any).clone();\n            // Preserve current opacity on cloned material\n            clonedMat.opacity = currentMaterialOpacity;\n            clonedMat.transparent = true; // Always allow transparency\n            mesh.material = clonedMat;\n          }\n        }\n      });\n\n      // Get FROM values: current rotation\n      const startRot = getCurrentRotations()[key] || object.quaternion.clone();\n      const startEuler = new THREE.Euler().setFromQuaternion(startRot);\n\n      // Get TO values: laydown rotation\n      // CRITICAL: Use the SAME end rotation for ALL objects to ensure consistent orientation\n      // Use LAY_DOWN_QUAT_1 (which has been adjusted by 180 in util.ts)\n      const endEuler = new THREE.Euler().setFromQuaternion(LAY_DOWN_QUAT_1);\n\n      // Get path for this object\n      const path = homeScrollPaths[key];\n      if (!path) {\n        console.warn(`No path found for object: ${key}`);\n        return;\n      }\n\n      // Create animation props object - use progress for path animation\n      const animProps = {\n        progress: 0, // Progress along path (0 to 1)\n        rotX: startEuler.x,\n        rotY: startEuler.y,\n        rotZ: startEuler.z,\n        opacity: currentMaterialOpacity, // Start from current opacity\n      };\n\n      animPropsArray.push(animProps);\n      animationData.push({\n        key,\n        object,\n        path,\n        startEuler,\n        endEuler,\n      });\n    });\n\n    // Create individual animations for each object with manual stagger positioning\n    // This ensures each object's opacity animates correctly\n    const totalObjects = animationData.length;\n    const staggerAmount = 0.15; // Stagger amount as fraction of timeline (15%)\n\n    animationData.forEach((data, index) => {\n      const animProps = animPropsArray[index];\n      const staggerPosition = index * (staggerAmount / totalObjects);\n\n      // Create individual fromTo animation for each object\n      homeScrollTimeline!.fromTo(\n        animProps,\n        {\n          // FROM: progress 0 (start of path), current rotation, current opacity\n          progress: 0,\n          rotX: data.startEuler.x,\n          rotY: data.startEuler.y,\n          rotZ: data.startEuler.z,\n          opacity: animProps.opacity, // Start from current opacity\n        },\n        {\n          // TO: progress 1 (end of path), laydown rotation, opacity 0\n          progress: 1,\n          rotX: data.endEuler.x,\n          rotY: data.endEuler.y,\n          rotZ: data.endEuler.z,\n          opacity: 0.0,\n          ease: \"power1.out\",\n          onUpdate: function () {\n            // Calculate position along path based on progress\n            const pathPoint = data.path.getPointAt(animProps.progress);\n            data.object.position.copy(pathPoint);\n\n            // Apply rotation (Euler to quaternion)\n            data.object.rotation.set(\n              animProps.rotX,\n              animProps.rotY,\n              animProps.rotZ\n            );\n            data.object.quaternion.setFromEuler(data.object.rotation);\n            updateObjectRotation(data.key, data.object.quaternion);\n\n            // Apply opacity using centralized material utility\n            // This ensures ghost materials with transmission always have transparent=true\n            setObjectOpacity(data.object, animProps.opacity, {\n              preserveTransmission: true, // Keep transparent=true for glow effect\n              skipCurrencySymbols: true,\n            });\n          },\n        },\n        staggerPosition // Start position on timeline (staggered)\n      );\n    });\n  };\n\n  // Store camera progress wrapper for killing\n  let cameraProgressWrapper: { value: number } | null = null;\n\n  // Function to create camera animation\n  const createCameraAnimation = () => {\n    // Kill existing camera animation\n    if (cameraProgressWrapper) {\n      gsap.killTweensOf(cameraProgressWrapper);\n    }\n\n    cameraProgressWrapper = { value: 0 };\n\n    // Add camera animation at position 0 (start of timeline) so it runs for the full duration\n    // This ensures camera animates alongside the object animations\n    // Make sure cameraPath exists before creating animation\n    if (!cameraPath || cameraPath.curves.length === 0) {\n      console.warn(\"Camera path not created, skipping camera animation\");\n      return;\n    }\n\n    // Add camera animation - it should run for the full timeline duration\n    // Position 0 means it starts at the beginning, parallel to object animations\n    homeScrollTimeline!.fromTo(\n      cameraProgressWrapper,\n      { value: 0 },\n      {\n        value: 1,\n        immediateRender: false,\n        onUpdate: function () {\n          const progress = this.targets()[0].value;\n          if (cameraPath && cameraPath.curves.length > 0) {\n            const cameraPoint = cameraPath.getPointAt(progress);\n            camera.position.copy(cameraPoint);\n\n            const lookAtPoints: THREE.Vector3[] = [];\n            cameraPathPoints.forEach((point) => {\n              if (\"lookAt\" in point && point.lookAt) {\n                lookAtPoints.push(point.lookAt);\n              }\n            });\n\n            if (lookAtPoints.length >= 4) {\n              const lookAtCurve = new THREE.CubicBezierCurve3(\n                lookAtPoints[0],\n                lookAtPoints[1],\n                lookAtPoints[2],\n                lookAtPoints[3]\n              );\n              const lookAtPoint = lookAtCurve.getPoint(progress);\n              camera.lookAt(lookAtPoint);\n            }\n            camera.fov = originalFOV;\n            camera.updateProjectionMatrix();\n          }\n        },\n      },\n      0 // Start at position 0, parallel to object animations\n    );\n  };\n\n  // Create animations initially\n  // Create object animations FIRST (this clears the timeline)\n  createObjectAnimations();\n  // Then create camera animation (after timeline is cleared, so it's not removed)\n  createCameraAnimation();\n}\n","import * as THREE from \"three\";\nimport { ghosts, pacmanMixer } from \"../core/objects\";\nimport { clock, onFrame } from \"../core/scene\";\nimport { getHomePaths, TangentSmoother } from \"../paths/paths\";\nimport { initHomeScrollAnimation } from \"./home-scroll\";\nimport { calculateObjectOrientation } from \"./util\";\nimport { applyHomeLoopPreset } from \"./scene-presets\";\nimport { SCALE } from \"./constants\";\nimport { setObjectScale } from \"./scene-utils\";\nimport {\n  syncStateFromObjects,\n  getCurrentPositions,\n  getCurrentRotations,\n  updateObjectPosition,\n  updateObjectRotation,\n  setHomeLoopActive,\n  updateHomeLoopT,\n  updateHomeLoopPausedT,\n} from \"./object-state\";\nimport { isCurrencySymbol } from \"./util\";\n\nconst LOOP_DURATION = 50;\nconst ROTATION_TRANSITION_DURATION = 1.5; // Seconds to transition from laying down to upright\nlet isHomeLoopActive = true;\nlet animationTime = 0;\nlet pausedT = 0;\nlet homeLoopFrameRegistered = false;\nlet rotationTransitionTime = 0;\nlet startRotations: Record<string, THREE.Quaternion> = {};\nlet hasBeenPausedBefore = false; // Track if we've ever stopped the loop (i.e., scrolled)\n\n// Tangent smoothers for home loop (separate from scroll smoothers)\nconst homeLoopTangentSmoothers: Record<string, TangentSmoother> = {};\n\n// Initialize home loop tangent smoothers\nfunction initializeHomeLoopTangentSmoothers() {\n  homeLoopTangentSmoothers.pacman = new TangentSmoother(\n    new THREE.Vector3(1, 0, 0),\n    0.06\n  );\n  homeLoopTangentSmoothers.ghost1 = new TangentSmoother(\n    new THREE.Vector3(1, 0, 0),\n    0.06\n  );\n  homeLoopTangentSmoothers.ghost2 = new TangentSmoother(\n    new THREE.Vector3(1, 0, 0),\n    0.06\n  );\n  homeLoopTangentSmoothers.ghost3 = new TangentSmoother(\n    new THREE.Vector3(1, 0, 0),\n    0.06\n  );\n  homeLoopTangentSmoothers.ghost4 = new TangentSmoother(\n    new THREE.Vector3(1, 0, 0),\n    0.06\n  );\n  homeLoopTangentSmoothers.ghost5 = new TangentSmoother(\n    new THREE.Vector3(1, 0, 0),\n    0.06\n  );\n}\n\nfunction stopHomeLoop() {\n  if (!isHomeLoopActive) return;\n  isHomeLoopActive = false;\n  setHomeLoopActive(false); // Notify state manager that home-loop is inactive\n  hasBeenPausedBefore = true;\n  pausedT = (animationTime % LOOP_DURATION) / LOOP_DURATION;\n\n  // CRITICAL: Store pausedT in state so home-scroll can use the exact same value\n  updateHomeLoopPausedT(pausedT);\n\n  // CRITICAL: State is already updated every frame in updateHomeLoop()\n  // Just ensure we have the absolute latest by syncing one more time\n  // This catches any edge cases where updateHomeLoop() hasn't run yet this frame\n  // Temporarily set active to allow this final sync\n  setHomeLoopActive(true);\n  syncStateFromObjects();\n  setHomeLoopActive(false);\n\n  // CRITICAL: Rotations are already in state (updated every frame in updateHomeLoop)\n  // We just need to ensure they're up-to-date before starting scroll\n  const homePaths = getHomePaths();\n  Object.entries(ghosts).forEach(([key, ghost]) => {\n    const path = homePaths[key];\n    if (path && homeLoopTangentSmoothers[key]) {\n      const rawTangent = path.getTangentAt(pausedT);\n      if (rawTangent && rawTangent.length() > 0) {\n        const smoothTangent = homeLoopTangentSmoothers[key].getCurrentTangent();\n        const objectType = key === \"pacman\" ? \"pacman\" : \"ghost\";\n\n        const tempObject = new THREE.Object3D();\n        calculateObjectOrientation(tempObject, smoothTangent, objectType);\n        const rotation = tempObject.quaternion.clone();\n        updateObjectRotation(key, rotation);\n      } else {\n        updateObjectRotation(key, ghost.quaternion);\n      }\n    } else {\n      updateObjectRotation(key, ghost.quaternion);\n    }\n  });\n\n  // CRITICAL: initHomeScrollAnimation now reads everything from state\n  // No need to pass parameters - state is the single source of truth\n  initHomeScrollAnimation();\n}\n\nfunction startHomeLoop() {\n  isHomeLoopActive = true;\n  setHomeLoopActive(true); // Notify state manager that home-loop is active\n\n  // CRITICAL: When returning from scroll, recalculate pausedT from state positions\n  // We use state positions because they are the ONLY source of truth (set by home-loop)\n  if (hasBeenPausedBefore) {\n    const homePaths = getHomePaths();\n    const currentPositions = getCurrentPositions(); // Read from state (last updated by home-loop)\n\n    // Find closest t value for each object and use average\n    let totalT = 0;\n    let count = 0;\n    Object.entries(currentPositions).forEach(([key, pos]) => {\n      const path = homePaths[key];\n      if (path) {\n        // Simple approximation: find closest point on path\n        let closestT = 0;\n        let closestDist = Infinity;\n        for (let i = 0; i <= 100; i++) {\n          const t = i / 100;\n          const pathPoint = path.getPointAt(t);\n          if (pathPoint) {\n            const dist = pathPoint.distanceTo(pos);\n            if (dist < closestDist) {\n              closestDist = dist;\n              closestT = t;\n            }\n          }\n        }\n        totalT += closestT;\n        count++;\n      }\n    });\n    if (count > 0) {\n      pausedT = totalT / count;\n    }\n    animationTime = pausedT * LOOP_DURATION;\n  }\n\n  rotationTransitionTime = 0;\n  startRotations = {};\n\n  // Apply home loop preset\n  applyHomeLoopPreset(true);\n\n  // Initialize smooth tangent smoothers for home loop\n  initializeHomeLoopTangentSmoothers();\n\n  const homePaths = getHomePaths();\n\n  // CRITICAL: Read positions from state (which were last updated by home-loop)\n  // Do NOT sync here - we will set objects to these positions and THEN sync\n  const currentPositions = getCurrentPositions();\n\n  Object.entries(ghosts).forEach(([key, ghost]) => {\n    const path = homePaths[key];\n    if (path) {\n      // Use current position from state if available, otherwise use path position\n      const savedPosition = currentPositions[key];\n      if (savedPosition && hasBeenPausedBefore) {\n        ghost.position.copy(savedPosition);\n        // CRITICAL: Update state with the position we just set\n        updateObjectPosition(key, savedPosition);\n      } else {\n        const position = path.getPointAt(pausedT);\n        if (position) {\n          ghost.position.copy(position);\n          updateObjectPosition(key, position);\n        }\n      }\n\n      // CRITICAL: Also update rotation in state\n      updateObjectRotation(key, ghost.quaternion);\n\n      // Only store current rotation for transition if we're returning from scroll\n      if (hasBeenPausedBefore) {\n        startRotations[key] = ghost.quaternion.clone();\n      }\n\n      if (key !== \"pacman\") {\n        ghost.visible = true;\n      }\n      setObjectScale(ghost, key, \"home\");\n\n      // Reset the smoother with initial tangent\n      if (homeLoopTangentSmoothers[key]) {\n        const initialTangent = path.getTangentAt(pausedT);\n        if (initialTangent) {\n          homeLoopTangentSmoothers[key].reset(initialTangent);\n        }\n      }\n    }\n  });\n\n  // CRITICAL: Now sync state AFTER we've set all object positions\n  // This ensures state matches the actual object positions\n  syncStateFromObjects();\n\n  if (!homeLoopFrameRegistered) {\n    onFrame(() => updateHomeLoop(clock.getDelta()));\n    homeLoopFrameRegistered = true;\n  }\n}\n\nfunction updateHomeLoop(delta: number) {\n  if (!isHomeLoopActive) return;\n  animationTime += delta;\n  rotationTransitionTime += delta;\n\n  const t = (animationTime % LOOP_DURATION) / LOOP_DURATION;\n\n  // CRITICAL: Update t-value in state so home-scroll can use the exact same value\n  updateHomeLoopT(t, animationTime);\n\n  const homePaths = getHomePaths();\n  if (pacmanMixer) {\n    pacmanMixer.update(delta);\n  }\n\n  // Calculate rotation transition progress (0 to 1 over ROTATION_TRANSITION_DURATION)\n  // Only transition if we've been paused before (returning from scroll)\n  const transitionProgress = Math.min(\n    rotationTransitionTime / ROTATION_TRANSITION_DURATION,\n    1\n  );\n  const isTransitioning = hasBeenPausedBefore && transitionProgress < 1;\n\n  Object.entries(ghosts).forEach(([key, ghost]) => {\n    const path = homePaths[key];\n    if (path) {\n      const position = path.getPointAt(t);\n      if (position) {\n        ghost.position.copy(position);\n        // CRITICAL: Update state every frame to keep it in sync\n        updateObjectPosition(key, position);\n      }\n\n      // CRITICAL: Maintain correct scale every frame using centralized utility\n      setObjectScale(ghost, key, \"home\");\n\n      // Calculate target rotation from path tangent\n      const targetQuat = new THREE.Quaternion();\n      if (homeLoopTangentSmoothers[key] && t > 0) {\n        const rawTangent = path.getTangentAt(t);\n        if (rawTangent && rawTangent.length() > 0) {\n          const smoothTangent =\n            homeLoopTangentSmoothers[key].update(rawTangent);\n          const objectType = key === \"pacman\" ? \"pacman\" : \"ghost\";\n\n          // Create a temporary object to get target quaternion\n          const tempObject = new THREE.Object3D();\n          calculateObjectOrientation(tempObject, smoothTangent, objectType);\n          targetQuat.copy(tempObject.quaternion);\n        }\n      }\n\n      // Smoothly transition from laying down rotation to upright rotation (only when returning from scroll)\n      if (isTransitioning && startRotations[key]) {\n        // Smooth easing for rotation transition\n        const easedProgress =\n          transitionProgress *\n          transitionProgress *\n          (3 - 2 * transitionProgress); // smoothstep\n        ghost.quaternion.copy(\n          startRotations[key].clone().slerp(targetQuat, easedProgress)\n        );\n      } else {\n        // After transition or on first load, use normal rotation\n        ghost.quaternion.copy(targetQuat);\n      }\n\n      // CRITICAL: Update state every frame to keep it in sync\n      updateObjectRotation(key, ghost.quaternion);\n      \n      // Opacity is managed by animations (home-scroll animates to 0, when returning to home-loop it's already at 1)\n    }\n  });\n}\n\n// when scroll is 0 - home loop is running.\n// Home= pacman and ghosts moving on their paths - scroll doesn't mattermatter\nexport function homeLoopHandler() {\n  if (window.scrollY === 0) {\n    startHomeLoop();\n  }\n}\n\nexport function setupHomeLoopScrollHandler() {\n  window.addEventListener(\"scroll\", () => {\n    if (window.scrollY !== 0) {\n      stopHomeLoop();\n    }\n  });\n}\n","import gsap from \"gsap\";\nimport ScrollTrigger from \"gsap/ScrollTrigger\";\nimport * as THREE from \"three\";\nimport { camera } from \"../core/camera\";\nimport { ghosts } from \"../core/objects\";\nimport { getPovPaths, TangentSmoother } from \"../paths/paths\";\nimport {\n  povTriggerPositions,\n  povPaths as pathPointsData,\n} from \"../paths/pathpoints\";\nimport { DOM_ELEMENTS } from \"../config/dom-elements\";\nimport { calculateObjectOrientation } from \"./util\";\nimport { applyPovScrollPreset, getScrollDirection } from \"./scene-presets\";\nimport { SCALE } from \"./constants\";\nimport { setObjectScale } from \"./scene-utils\";\n\n// Cache for DOM elements to avoid repeated queries\nconst domElementCache: Record<\n  number,\n  {\n    parent: HTMLElement | null;\n    povElements: NodeListOf<Element>;\n    camElements: NodeListOf<Element>;\n  }\n> = {};\n\ngsap.registerPlugin(ScrollTrigger);\n\nlet povScrollTimeline: gsap.core.Timeline | null = null;\n\n// Animation state\nlet previousCameraPosition: THREE.Vector3 | null = null;\nlet rotationStarted = false;\nlet startedInitEndScreen = false;\n\n// Camera rotation constants\nconst startRotationPoint = new THREE.Vector3(0.55675, 0.55, 1.306);\nconst endRotationPoint = new THREE.Vector3(-0.14675, 1, 1.8085);\n\n// Animation timing constants\nconst wideFOV = 80;\n\n// Cached values\nlet cachedStartYAngle: number | null = null;\n\n// Ghost trigger state\nconst ghostStates: Record<string, any> = {};\n\n// Tangent smoothers for POV scroll (separate from home loop smoothers)\nconst povTangentSmoothers: Record<string, TangentSmoother> = {};\n\n// Helper function to get custom lookAt for a specific progress\nfunction getCustomLookAtForProgress(\n  progress: number,\n  povPaths: Record<string, THREE.CurvePath<THREE.Vector3>>\n): THREE.Vector3 | null {\n  const cameraPathPoints = pathPointsData.camera;\n\n  // Define the sequence phase (first 5%) and transition phase (next 2%)\n  const sequencePhaseEnd = 0.05;\n  const transitionPhaseEnd = 0.07;\n\n  // For the very first point (progress close to 0), check for lookAtSequence\n  if (progress <= sequencePhaseEnd) {\n    // Check first 5% of path\n    const firstPoint = cameraPathPoints[0];\n\n    // Handle lookAtSequence - cycle through multiple lookAt targets\n    if (\n      \"lookAtSequence\" in firstPoint &&\n      firstPoint.lookAtSequence &&\n      firstPoint.lookAtSequence.length > 0\n    ) {\n      const sequenceProgress = progress / sequencePhaseEnd; // Normalize to 0-1 within first 5%\n      const sequenceLength = firstPoint.lookAtSequence.length;\n\n      // Calculate which lookAt target to use and interpolation\n      const segmentSize = 1 / sequenceLength;\n      const currentSegment = Math.floor(sequenceProgress / segmentSize);\n      const segmentProgress = (sequenceProgress % segmentSize) / segmentSize;\n\n      // Clamp to valid range\n      const fromIndex = Math.min(currentSegment, sequenceLength - 1);\n      const toIndex = Math.min(currentSegment + 1, sequenceLength - 1);\n\n      if (fromIndex === toIndex) {\n        // At the end, use last target\n        return firstPoint.lookAtSequence[fromIndex];\n      } else {\n        // Interpolate between current and next target for smooth transitions\n        const fromTarget = firstPoint.lookAtSequence[fromIndex];\n        const toTarget = firstPoint.lookAtSequence[toIndex];\n        return fromTarget.clone().lerp(toTarget, segmentProgress);\n      }\n    }\n  }\n\n  // Transition phase: smoothly blend from final sequence lookAt to default tangent lookAt\n  else if (progress <= transitionPhaseEnd) {\n    const firstPoint = cameraPathPoints[0];\n\n    if (\n      \"lookAtSequence\" in firstPoint &&\n      firstPoint.lookAtSequence &&\n      firstPoint.lookAtSequence.length > 0\n    ) {\n      // Get the final lookAt from the sequence\n      const finalSequenceLookAt =\n        firstPoint.lookAtSequence[firstPoint.lookAtSequence.length - 1];\n\n      // Get the default tangent-based lookAt, but constrain Y to avoid looking up\n      const position = povPaths.camera.getPointAt(progress);\n      const tangent = povPaths.camera.getTangentAt(progress).normalize();\n\n      // Constrain Y component of tangent to prevent looking up/down during transition\n      const constrainedTangent = new THREE.Vector3(\n        tangent.x,\n        0,\n        tangent.z\n      ).normalize();\n      const defaultLookAt = position.clone().add(constrainedTangent);\n\n      // Calculate transition progress (0 to 1 over the 2% transition phase)\n      const transitionProgress =\n        (progress - sequencePhaseEnd) / (transitionPhaseEnd - sequencePhaseEnd);\n\n      // Smooth interpolation from sequence lookAt to constrained default lookAt\n      return finalSequenceLookAt\n        .clone()\n        .lerp(defaultLookAt, transitionProgress);\n    }\n  }\n\n  return null;\n}\n\n// Initialize POV tangent smoothers\nfunction initializePovTangentSmoothers() {\n  povTangentSmoothers.camera = new TangentSmoother(\n    new THREE.Vector3(0, 0, -1),\n    0.08\n  );\n\n  // Initialize ghost smoothers with loop\n  for (let i = 1; i <= 5; i++) {\n    povTangentSmoothers[`ghost${i}`] = new TangentSmoother(\n      new THREE.Vector3(1, 0, 0),\n      0.08\n    );\n  }\n}\n\nexport function initPovScrollAnimation() {\n  if (povScrollTimeline) {\n    povScrollTimeline.kill();\n    povScrollTimeline = null;\n  }\n\n  // Initialize tangent smoothers for POV scroll\n  initializePovTangentSmoothers();\n\n  // Initialize ghost states\n  Object.keys(povTriggerPositions).forEach((key) => {\n    ghostStates[key] = {\n      hasBeenTriggered: false,\n      triggerCameraProgress: null,\n      ghostStartFadeInProgress: null,\n      ghostEndFadeInProgress: null,\n      ghostStartFadeOutProgress: null,\n      camStartFadeInProgress: null,\n      camEndFadeInProgress: null,\n      camStartFadeOutProgress: null,\n      endCameraProgress: null,\n      currentPathT: 0,\n    };\n  });\n\n  povScrollTimeline = gsap\n    .timeline({\n      scrollTrigger: {\n        id: \"povScroll\",\n        trigger: DOM_ELEMENTS.povSection,\n        start: \"top bottom\",\n        end: \"bottom top\",\n        markers: true,\n        scrub: 0.5,\n        toggleActions: \"play none none reverse\",\n        onEnter: () => {\n          const scrollDir = getScrollDirection();\n          applyPovScrollPreset(true, scrollDir);\n        },\n        onEnterBack: () => {\n          const scrollDir = getScrollDirection();\n          applyPovScrollPreset(true, scrollDir);\n        },\n      },\n    })\n    .to(\n      { progress: 0 },\n      {\n        progress: 1,\n        immediateRender: false,\n        onStart: handleAnimationStart,\n        onUpdate: function (this: gsap.core.Tween) {\n          handleAnimationUpdate.call(this);\n        },\n        onReverseComplete: () => {\n          handleLeavePOV();\n          resetState();\n        },\n        onComplete: () => {\n          handleLeavePOV();\n          resetState();\n        },\n      }\n    );\n}\n\nfunction handleAnimationStart() {\n  const povPaths = getPovPaths();\n\n  // Reset camera tangent smoother with initial camera tangent\n  if (povTangentSmoothers.camera && povPaths.camera) {\n    const initialCameraTangent = povPaths.camera.getTangentAt(0);\n    if (initialCameraTangent) {\n      povTangentSmoothers.camera.reset(initialCameraTangent);\n    }\n  }\n\n  // Position all ghosts at start of their paths\n  Object.entries(ghosts).forEach(([key, ghost]) => {\n    if (povPaths[key] && key !== \"pacman\") {\n      const position = povPaths[key].getPointAt(0);\n      ghost.position.copy(position);\n      const tangent = povPaths[key].getTangentAt(0).normalize();\n      ghost.lookAt(position.clone().add(tangent));\n      ghost.visible = false;\n      setObjectScale(ghost, key, \"pov\");\n    }\n  });\n\n  // Hide pacman during POV section\n  if (ghosts.pacman) {\n    ghosts.pacman.visible = false;\n  }\n}\n\nfunction handleAnimationUpdate(this: gsap.core.Tween) {\n  const overallProgress = (this.targets()[0] as any).progress;\n\n  const povPaths = getPovPaths();\n\n  if (!povPaths.camera) return;\n\n  const cameraPosition = povPaths.camera.getPointAt(overallProgress);\n\n  if (previousCameraPosition) {\n    updateCamera(overallProgress, povPaths, cameraPosition);\n    updateGhosts(cameraPosition, overallProgress, povPaths);\n    previousCameraPosition.copy(cameraPosition);\n  } else {\n    previousCameraPosition = cameraPosition.clone();\n  }\n}\n\nfunction updateCamera(\n  progress: number,\n  povPaths: Record<string, THREE.CurvePath<THREE.Vector3>>,\n  position: THREE.Vector3\n) {\n  // CRITICAL: Don't update camera if intro-scroll is active\n  // This prevents camera rotation issues when scrolling back up from POV to intro\n  const introScrollTrigger = ScrollTrigger.getById(\"introScroll\");\n  const isIntroScrollActive = introScrollTrigger && introScrollTrigger.isActive;\n\n  if (isIntroScrollActive) {\n    return;\n  }\n\n  camera.position.copy(position);\n  camera.fov = wideFOV;\n\n  // Check for custom lookAt at current path point\n  const customLookAt = getCustomLookAtForProgress(progress, povPaths);\n  if (customLookAt) {\n    camera.lookAt(customLookAt);\n    camera.updateProjectionMatrix();\n    return;\n  }\n\n  // Get smooth tangent for camera orientation\n  const rawTangent = povPaths.camera.getTangentAt(progress).normalize();\n  let smoothTangent = rawTangent;\n\n  if (povTangentSmoothers.camera && progress > 0) {\n    smoothTangent = povTangentSmoothers.camera.update(rawTangent);\n  }\n\n  // Constrain Y component to prevent looking up/down during early path following\n  if (progress <= 0.15) {\n    // Extend constraint for first 15% of path\n    smoothTangent = new THREE.Vector3(\n      smoothTangent.x,\n      0,\n      smoothTangent.z\n    ).normalize();\n  }\n\n  const defaultLookAt = position.clone().add(smoothTangent);\n  handleDefaultOrientation(progress, defaultLookAt);\n\n  camera.updateProjectionMatrix();\n}\n\nfunction handleDefaultOrientation(\n  progress: number,\n  defaultLookAt: THREE.Vector3\n) {\n  const povPaths = getPovPaths();\n  const startRotationProgress = findClosestProgressOnPath(\n    povPaths.camera,\n    startRotationPoint\n  );\n  const endRotationProgress = findClosestProgressOnPath(\n    povPaths.camera,\n    endRotationPoint\n  );\n\n  if (\n    (progress < startRotationProgress || progress > endRotationProgress) &&\n    !startedInitEndScreen\n  ) {\n    cachedStartYAngle = null;\n    rotationStarted = false;\n    startedInitEndScreen = false;\n  }\n\n  if (!rotationStarted && !startedInitEndScreen) {\n    camera.lookAt(defaultLookAt);\n  }\n}\n\nfunction updateGhosts(\n  cameraPosition: THREE.Vector3,\n  overallProgress: number,\n  povPaths: Record<string, THREE.CurvePath<THREE.Vector3>>\n) {\n  Object.entries(povTriggerPositions).forEach(([key, triggerData]) => {\n    const ghost = ghosts[key];\n    const path = povPaths[key];\n\n    if (!ghost || !path || key === \"pacman\") return;\n    const forceEndProgress =\n      overallProgress > triggerData.forceEndProgress.start &&\n      overallProgress < triggerData.forceEndProgress.end;\n\n    updateGhost(\n      key,\n      ghost,\n      path,\n      cameraPosition,\n      triggerData,\n      forceEndProgress\n    );\n  });\n}\n\nfunction updateGhost(\n  key: string,\n  ghost: THREE.Object3D,\n  path: THREE.CurvePath<THREE.Vector3>,\n  cameraPosition: THREE.Vector3,\n  triggerData: any,\n  forceEndProgress: boolean\n) {\n  const {\n    triggerPos,\n    ghostStartFadeIn,\n    ghostEndFadeIn,\n    ghostStartFadeOut,\n    camStartFadeIn,\n    camEndFadeIn,\n    camStartFadeOut,\n    endPosition,\n  } = triggerData;\n  const state = ghostStates[key];\n\n  // Get DOM elements with caching\n  const ghostIndex = parseInt(key.replace(\"ghost\", \"\")) - 1;\n  let cached = domElementCache[ghostIndex];\n\n  if (!cached) {\n    const parentElements = document.querySelectorAll(\".cmp--pov.cmp\");\n    const parent = parentElements[ghostIndex] as HTMLElement;\n    cached = {\n      parent: parent || null,\n      povElements: parent ? parent.querySelectorAll(\".pov\") : ([] as any),\n      camElements: parent ? parent.querySelectorAll(\".cam\") : ([] as any),\n    };\n    domElementCache[ghostIndex] = cached;\n  }\n\n  const { parent, povElements, camElements } = cached;\n  if (!parent || !povElements.length || !camElements.length) return;\n\n  // Initialize state if needed\n  const povPaths = getPovPaths();\n  if (state.triggerCameraProgress === null) {\n    state.triggerCameraProgress = findClosestProgressOnPath(\n      povPaths.camera,\n      triggerPos,\n      800\n    );\n    state.ghostStartFadeInProgress = findClosestProgressOnPath(\n      povPaths.camera,\n      ghostStartFadeIn,\n      800\n    );\n    state.ghostEndFadeInProgress = findClosestProgressOnPath(\n      povPaths.camera,\n      ghostEndFadeIn,\n      800\n    );\n    state.ghostStartFadeOutProgress = findClosestProgressOnPath(\n      povPaths.camera,\n      ghostStartFadeOut,\n      800\n    );\n    state.camStartFadeInProgress = findClosestProgressOnPath(\n      povPaths.camera,\n      camStartFadeIn,\n      800\n    );\n    state.camEndFadeInProgress = findClosestProgressOnPath(\n      povPaths.camera,\n      camEndFadeIn,\n      800\n    );\n    state.camStartFadeOutProgress = findClosestProgressOnPath(\n      povPaths.camera,\n      camStartFadeOut,\n      800\n    );\n    state.endCameraProgress = findClosestProgressOnPath(\n      povPaths.camera,\n      endPosition,\n      800\n    );\n  }\n\n  const currentCameraProgress = findClosestProgressOnPath(\n    povPaths.camera,\n    cameraPosition,\n    800\n  );\n\n  // Update ghost visibility and position\n  if (\n    currentCameraProgress >= state.triggerCameraProgress &&\n    currentCameraProgress <= state.endCameraProgress\n  ) {\n    if (!ghost.visible) {\n      ghost.visible = true;\n      state.hasBeenTriggered = true;\n\n      // Reset tangent smoother with initial tangent when ghost becomes visible\n      if (povTangentSmoothers[key]) {\n        const initialTangent = path.getTangentAt(0);\n        if (initialTangent) {\n          povTangentSmoothers[key].reset(initialTangent);\n        }\n      }\n    }\n\n    // Update ghost position\n    const normalizedProgress =\n      (currentCameraProgress - state.triggerCameraProgress) /\n      (state.endCameraProgress - state.triggerCameraProgress);\n    let ghostProgress = Math.max(0, Math.min(1, normalizedProgress));\n\n    // Smooth the parameter\n    if (state.currentPathT === undefined) {\n      state.currentPathT = ghostProgress;\n    } else {\n      const parameterSmoothingFactor = 0.1;\n      state.currentPathT +=\n        (ghostProgress - state.currentPathT) * parameterSmoothingFactor;\n    }\n\n    ghostProgress = state.currentPathT;\n\n    // Update ghost position and rotation\n    const pathPoint = path.getPointAt(ghostProgress);\n    ghost.position.copy(pathPoint);\n\n    // Apply smooth tangent-based orientation\n    if (povTangentSmoothers[key] && ghostProgress > 0) {\n      const rawTangent = path.getTangentAt(ghostProgress);\n      if (rawTangent && rawTangent.length() > 0) {\n        const smoothTangent = povTangentSmoothers[key].update(rawTangent);\n        calculateObjectOrientation(ghost, smoothTangent, \"ghost\");\n      }\n    }\n\n    // Handle fade out at the end\n    if (ghostProgress > 0.9) {\n      const mesh = ghost as THREE.Mesh;\n      if (mesh.material && \"opacity\" in mesh.material) {\n        (mesh.material as THREE.Material & { opacity: number }).opacity =\n          1 - (ghostProgress - 0.9) / 0.1;\n      }\n    } else {\n      const mesh = ghost as THREE.Mesh;\n      if (mesh.material && \"opacity\" in mesh.material) {\n        (mesh.material as THREE.Material & { opacity: number }).opacity = 1;\n      }\n    }\n  } else {\n    ghost.visible = false;\n    state.hasBeenTriggered = false;\n  }\n\n  // Update text visibility\n  updateTextVisibility(\n    key,\n    currentCameraProgress,\n    state,\n    parent,\n    povElements,\n    camElements,\n    forceEndProgress\n  );\n}\n\nfunction updateTextVisibility(\n  key: string,\n  currentCameraProgress: number,\n  state: any,\n  parent: HTMLElement,\n  povElements: NodeListOf<Element>,\n  camElements: NodeListOf<Element>,\n  forceEndProgress: boolean = false\n) {\n  // If forceEndProgress is true, immediately hide all text elements\n  if (forceEndProgress) {\n    parent.style.opacity = \"0\";\n    parent.classList.add(\"no-visibility\");\n    hideTextElements(povElements);\n    hideTextElements(camElements);\n    return;\n  }\n\n  // Calculate target opacities using precise fade timing positions\n  let targetGhostOpacity = 0;\n  let targetCamOpacity = 0;\n\n  // Ghost text fade in (ghostStartFadeIn -> ghostEndFadeIn)\n  if (\n    currentCameraProgress >= state.ghostStartFadeInProgress &&\n    currentCameraProgress <= state.ghostEndFadeInProgress\n  ) {\n    const fadeProgress =\n      (currentCameraProgress - state.ghostStartFadeInProgress) /\n      (state.ghostEndFadeInProgress - state.ghostStartFadeInProgress);\n    targetGhostOpacity = Math.min(1, fadeProgress);\n    parent.style.opacity = targetGhostOpacity.toString();\n  }\n  // Ghost text stays fully visible (ghostEndFadeIn -> ghostStartFadeOut)\n  else if (\n    currentCameraProgress > state.ghostEndFadeInProgress &&\n    currentCameraProgress < state.ghostStartFadeOutProgress\n  ) {\n    targetGhostOpacity = 1;\n  }\n  // Ghost text fade out (ghostStartFadeOut -> camStartFadeIn) - finishes exactly when cam starts fading in\n  else if (\n    currentCameraProgress >= state.ghostStartFadeOutProgress &&\n    currentCameraProgress <= state.camStartFadeInProgress\n  ) {\n    const fadeOutProgress =\n      (currentCameraProgress - state.ghostStartFadeOutProgress) /\n      (state.camStartFadeInProgress - state.ghostStartFadeOutProgress);\n    targetGhostOpacity = Math.max(0, 1 - fadeOutProgress);\n  }\n\n  // CAM text fade in (camStartFadeIn -> camEndFadeIn)\n  if (\n    currentCameraProgress >= state.camStartFadeInProgress &&\n    currentCameraProgress <= state.camEndFadeInProgress\n  ) {\n    const fadeProgress =\n      (currentCameraProgress - state.camStartFadeInProgress) /\n      (state.camEndFadeInProgress - state.camStartFadeInProgress);\n    targetCamOpacity = Math.min(1, fadeProgress);\n  }\n  // CAM text stays visible (camEndFadeIn -> camStartFadeOut)\n  else if (\n    currentCameraProgress > state.camEndFadeInProgress &&\n    currentCameraProgress < state.camStartFadeOutProgress\n  ) {\n    targetCamOpacity = 1;\n  }\n  // CAM text fade out (camStartFadeOut -> endPosition)\n  else if (\n    currentCameraProgress >= state.camStartFadeOutProgress &&\n    currentCameraProgress <= state.endCameraProgress\n  ) {\n    const fadeOutProgress =\n      (currentCameraProgress - state.camStartFadeOutProgress) /\n      (state.endCameraProgress - state.camStartFadeOutProgress);\n    targetCamOpacity = Math.max(0, 1 - fadeOutProgress);\n    parent.style.opacity = targetCamOpacity.toString();\n  }\n\n  const isPassed = targetCamOpacity > 0.01 && targetGhostOpacity > 0.01;\n  const hasNoVisibility = parent.classList.contains(\"no-visibility\");\n\n  if (isPassed && !hasNoVisibility) {\n    parent.classList.add(\"no-visibility\");\n  } else if (!isPassed && hasNoVisibility) {\n    parent.classList.remove(\"no-visibility\");\n  }\n\n  // Update all POV elements (ghost text)\n  povElements.forEach((povElement) => {\n    const element = povElement as HTMLElement;\n    if (targetGhostOpacity > 0.01) {\n      element.classList.remove(\"no-visibility\");\n      element.style.opacity = targetGhostOpacity.toString();\n    } else if (\n      targetGhostOpacity <= 0.01 &&\n      !element.classList.contains(\"no-visibility\")\n    ) {\n      element.classList.add(\"no-visibility\");\n      element.style.opacity = \"0\";\n    }\n  });\n\n  // Update all CAM elements\n  camElements.forEach((camElement) => {\n    const element = camElement as HTMLElement;\n    if (targetCamOpacity > 0.01) {\n      element.classList.remove(\"no-visibility\");\n      element.style.opacity = targetCamOpacity.toString();\n    } else if (\n      targetCamOpacity <= 0.01 &&\n      !element.classList.contains(\"no-visibility\")\n    ) {\n      element.classList.add(\"no-visibility\");\n      element.style.opacity = \"0\";\n    }\n  });\n}\n\n// Helper function to reset tangent smoothers\nfunction resetTangentSmoothers() {\n  Object.keys(povTangentSmoothers).forEach((key) => {\n    if (povTangentSmoothers[key]) {\n      const resetVector =\n        key === \"camera\"\n          ? new THREE.Vector3(0, 0, -1)\n          : new THREE.Vector3(1, 0, 0);\n      povTangentSmoothers[key].reset(resetVector);\n    }\n  });\n}\n\nfunction hideTextElements(elements: NodeListOf<Element>) {\n  elements.forEach((element) => {\n    const el = element as HTMLElement;\n    el.classList.add(\"no-visibility\");\n    el.style.opacity = \"0\";\n  });\n}\n\nfunction handleLeavePOV() {\n  // Reset all ghost states\n  Object.entries(ghosts).forEach(([key, ghost]) => {\n    if (key !== \"pacman\") {\n      ghost.visible = false;\n\n      const ghostIndex = parseInt(key.replace(\"ghost\", \"\")) - 1;\n      const cached = domElementCache[ghostIndex];\n\n      if (cached?.parent) {\n        hideTextElements(cached.povElements);\n        hideTextElements(cached.camElements);\n        cached.parent.classList.add(\"no-visibility\");\n      }\n\n      // Reset ghost material opacity\n      const mesh = ghost as THREE.Mesh;\n      if (mesh.material && \"opacity\" in mesh.material) {\n        (mesh.material as THREE.Material & { opacity: number }).opacity = 1;\n      }\n    }\n  });\n\n  // Show pacman again\n  if (ghosts.pacman) {\n    ghosts.pacman.visible = true;\n  }\n\n  resetTangentSmoothers();\n}\n\nfunction resetState() {\n  // Reset camera state\n  if (ghosts.pacman) {\n    ghosts.pacman.visible = true;\n  }\n\n  rotationStarted = false;\n  cachedStartYAngle = null;\n  startedInitEndScreen = false;\n\n  // Reset all ghost states\n  Object.keys(ghostStates).forEach((key) => {\n    ghostStates[key] = {\n      hasBeenTriggered: false,\n      triggerCameraProgress: null,\n      ghostStartFadeInProgress: null,\n      ghostEndFadeInProgress: null,\n      ghostStartFadeOutProgress: null,\n      camStartFadeInProgress: null,\n      camEndFadeInProgress: null,\n      camStartFadeOutProgress: null,\n      endCameraProgress: null,\n      currentPathT: 0,\n    };\n  });\n\n  resetTangentSmoothers();\n}\n\n// Utility functions\nfunction findClosestProgressOnPath(\n  path: THREE.CurvePath<THREE.Vector3>,\n  targetPoint: THREE.Vector3,\n  samples: number = 2000\n): number {\n  if (!path || !targetPoint) return 0;\n\n  let closestProgress = 0;\n  let closestDistance = Infinity;\n\n  for (let i = 0; i < samples; i++) {\n    try {\n      const t = i / (samples - 1);\n      const pointOnPath = path.getPointAt(t);\n      if (!pointOnPath) continue;\n\n      const distance = pointOnPath.distanceTo(targetPoint);\n      if (distance < closestDistance) {\n        closestDistance = distance;\n        closestProgress = t;\n      }\n    } catch (error) {\n      // Continue on error\n    }\n  }\n\n  return closestProgress;\n}\n","import gsap from \"gsap\";\nimport ScrollTrigger from \"gsap/ScrollTrigger\";\nimport * as THREE from \"three\";\nimport { camera } from \"../core/camera\";\nimport { ghosts } from \"../core/objects\";\nimport { scene } from \"../core/scene\";\nimport {\n  applyIntroScrollPreset,\n  getScrollDirection,\n  getPacmanTargetQuaternion,\n  getGhostTargetQuaternion,\n  INTRO_POSITION_OFFSET,\n} from \"./scene-presets\";\nimport { setMaterialOpacity, setGhostColor } from \"../core/material-utils\";\nimport {\n  OBJECT_KEYS,\n  GHOST_COLORS,\n  isCurrencySymbol,\n  isPacmanPart,\n} from \"./util\";\nimport { SCROLL_SELECTORS, SCALE, COLOR, OPACITY } from \"./constants\";\nimport { setFloorPlane, setObjectScale, killObjectAnimations } from \"./scene-utils\";\n\nlet introScrollTimeline: gsap.core.Timeline | null = null;\nlet isIntroScrollActive = false;\nlet lastIntroProgress = 0;\nlet isUpdating = false; // Prevent concurrent updates\n\n// Helper function to pause other scroll triggers\nfunction pauseOtherScrollTriggers() {\n  const homeScrollTrigger = gsap.getById(\"homeScroll\");\n  if (homeScrollTrigger) {\n    const homeTimeline = (homeScrollTrigger as any).timeline;\n    if (homeTimeline?.pause) {\n      homeTimeline.pause();\n    }\n  }\n\n  const povScrollTrigger = ScrollTrigger.getById(\"povScroll\");\n  if (povScrollTrigger) {\n    const povTimeline = (povScrollTrigger as any).timeline;\n    if (povTimeline?.pause) {\n      povTimeline.pause();\n    }\n  }\n}\n\n// Helper function to set object visibility and opacity\nfunction setObjectVisibilityAndOpacity(key: string, obj: THREE.Object3D) {\n  gsap.killTweensOf(obj);\n  gsap.killTweensOf(obj.scale);\n  gsap.killTweensOf(obj.position);\n  gsap.killTweensOf(obj.quaternion);\n\n  obj.visible = true;\n  obj.traverse((child) => {\n    if ((child as any).isMesh && (child as any).material) {\n      const mesh = child as THREE.Mesh;\n      const childName = child.name || \"\";\n\n      // Skip currency symbols and pacman parts\n      if (\n        isCurrencySymbol(childName) ||\n        (key === \"pacman\" && isPacmanPart(childName))\n      ) {\n        return;\n      }\n\n      mesh.visible = true;\n      if (Array.isArray(mesh.material)) {\n        mesh.material.forEach((mat: any) => {\n          setMaterialOpacity(mat, 1, true);\n        });\n      } else {\n        setMaterialOpacity(mesh.material as any, 1, true);\n      }\n    }\n  });\n  obj.updateMatrixWorld(true);\n}\n\n// Helper function to initialize intro scroll state\nfunction initializeIntroScrollState() {\n  pauseOtherScrollTriggers();\n\n  const setVisibilityForAll = () => {\n    OBJECT_KEYS.forEach((key) => {\n      const obj = ghosts[key];\n      if (obj) setObjectVisibilityAndOpacity(key, obj);\n    });\n  };\n\n  setVisibilityForAll();\n  applyIntroScrollPreset(true, getScrollDirection());\n  setVisibilityForAll(); // Force visibility again after preset\n\n  isUpdating = false;\n\n  // Update objects immediately\n  const scrollTrigger = ScrollTrigger.getById(\"introScroll\");\n  const progress =\n    scrollTrigger && typeof scrollTrigger.progress === \"number\"\n      ? scrollTrigger.progress\n      : 0;\n  lastIntroProgress = progress;\n  updateObjectsWalkBy(progress);\n\n  // Also update in next frame\n  requestAnimationFrame(() => {\n    const scrollTrigger = ScrollTrigger.getById(\"introScroll\");\n    const progress =\n      scrollTrigger && typeof scrollTrigger.progress === \"number\"\n        ? scrollTrigger.progress\n        : 0;\n    lastIntroProgress = progress;\n    updateObjectsWalkBy(progress);\n  });\n}\n\n// Helper function to restore floor\nfunction restoreFloor() {\n  setFloorPlane(true, OPACITY.FULL, false);\n}\n\nexport function initIntroScrollAnimation() {\n  // Kill any existing timeline\n  if (introScrollTimeline) {\n    introScrollTimeline.kill();\n    introScrollTimeline = null;\n  }\n\n  introScrollTimeline = gsap\n    .timeline({\n      scrollTrigger: {\n        trigger: SCROLL_SELECTORS.INTRO,\n        start: \"top top\",\n        end: \"bottom bottom\",\n        scrub: 0.5,\n        refreshPriority: 1,\n        onEnter: () => {\n          isIntroScrollActive = true;\n          initializeIntroScrollState();\n        },\n        onEnterBack: () => {\n          isIntroScrollActive = true;\n          initializeIntroScrollState();\n        },\n        onLeave: () => {\n          isIntroScrollActive = false;\n          restoreFloor();\n        },\n        onLeaveBack: () => {\n          isIntroScrollActive = false;\n          restoreFloor();\n        },\n        onUpdate: (self) => {\n          // CRITICAL: Update on every scroll event - this is the primary update source\n          // Update bidirectionally based on scroll progress (works for both scroll up and down)\n          if (\n            isIntroScrollActive &&\n            typeof self.progress === \"number\" &&\n            !isUpdating\n          ) {\n            lastIntroProgress = self.progress;\n            updateObjectsWalkBy(self.progress);\n          }\n        },\n        id: \"introScroll\",\n      },\n    })\n    .fromTo(\n      \".sc_h--intro\",\n      { scale: 0.5, opacity: 0 },\n      {\n        keyframes: [\n          { scale: 0.5, opacity: 0, duration: 0 },\n          { scale: 0.8, opacity: 1, duration: 0.3 },\n          { scale: 1.2, opacity: 1, duration: 0.4 },\n          { scale: 1.5, opacity: 0, duration: 0.3 },\n        ],\n      }\n    )\n    .fromTo(\n      \".sc_b--intro\",\n      { scale: 0.5, opacity: 0 },\n      {\n        keyframes: [\n          { scale: 0.5, opacity: 0, duration: 0 },\n          { scale: 0.8, opacity: 1, duration: 0.3 },\n          { scale: 1.2, opacity: 1, duration: 0.4 },\n          { scale: 1.5, opacity: 0, duration: 0.3 },\n        ],\n      }\n    )\n    .to(\n      { progress: 0 },\n      {\n        progress: 1,\n        duration: 1,\n        immediateRender: false,\n        onComplete: () => {\n          if (isIntroScrollActive) {\n            updateObjectsWalkBy(lastIntroProgress);\n          }\n        },\n        onReverseComplete: () => {\n          if (isIntroScrollActive) {\n            updateObjectsWalkBy(lastIntroProgress);\n          }\n        },\n      },\n      0 // Start at the same time as the other animations\n    );\n}\n\nfunction updateObjectsWalkBy(progress: number) {\n  // CRITICAL: Only update if intro-scroll is active\n  if (!isIntroScrollActive || isUpdating) return;\n\n  isUpdating = true;\n\n  try {\n    // Ensure floor plane stays invisible (white with opacity 0) during animation\n    setFloorPlane(true, OPACITY.HIDDEN, true);\n\n    // Calculate base center point for walk path\n    const baseCenter = new THREE.Vector3(\n      camera.position.x,\n      camera.position.y,\n      camera.position.z\n    );\n\n    // Walk path symmetric around center\n    // Start 10 units left of center, end 10 units right of center\n    const walkDistance = 10.0;\n    const walkStart = baseCenter.x - walkDistance; // Start from left\n    const walkEnd = baseCenter.x + walkDistance; // End at right\n\n    // Objects to animate - ghosts walk 0.5 units behind pacman\n    const objectsToAnimate = [\n      { key: \"pacman\", behindOffset: 0 },\n      { key: \"ghost1\", behindOffset: -0.5 },\n      { key: \"ghost2\", behindOffset: -1.0 },\n      { key: \"ghost3\", behindOffset: -1.5 },\n      { key: \"ghost4\", behindOffset: -2.0 },\n      { key: \"ghost5\", behindOffset: -2.5 },\n    ];\n\n    // Calculate pacman's position using smooth interpolation\n    const normalizedProgress = Math.max(0, Math.min(1, progress));\n    const baseX = walkStart + (walkEnd - walkStart) * normalizedProgress;\n    const pacmanX = baseX + INTRO_POSITION_OFFSET.x;\n    const pacmanY = baseCenter.y + INTRO_POSITION_OFFSET.y;\n    const pacmanZ = baseCenter.z + INTRO_POSITION_OFFSET.z;\n\n    // Smooth fade-in for ghosts based on progress\n    const fadeInDuration = 0.2; // Fade in over 20% of progress\n    const ghostOpacity =\n      normalizedProgress < fadeInDuration\n        ? normalizedProgress / fadeInDuration\n        : 1.0;\n\n    objectsToAnimate.forEach(({ key, behindOffset }) => {\n      const object = ghosts[key];\n      if (!object) return;\n\n      // CRITICAL: Kill all GSAP animations that might interfere\n      killObjectAnimations(object);\n\n      // Calculate position\n      const finalX = pacmanX + behindOffset;\n      const finalY = pacmanY;\n      const finalZ = pacmanZ;\n\n      // Update position directly (no GSAP interpolation for smoother updates)\n      object.position.set(finalX, finalY, finalZ);\n\n      // Set rotation quaternion directly (no recalculation - use pre-calculated quaternions)\n      const pacmanQuat = getPacmanTargetQuaternion();\n      const ghostQuat = getGhostTargetQuaternion();\n      if (key === \"pacman\" && pacmanQuat) {\n        object.quaternion.copy(pacmanQuat);\n      } else if (ghostQuat) {\n        object.quaternion.copy(ghostQuat);\n      }\n\n      // Force update matrix to ensure rotation is applied\n      object.updateMatrixWorld(true);\n\n      // CRITICAL: Force visibility, scale EVERY frame to override home-scroll\n      object.visible = true;\n      setObjectScale(object, key, \"intro\");\n\n      // Update opacity for meshes\n      const targetOpacity = key === \"pacman\" ? 1.0 : ghostOpacity;\n\n      object.traverse((child) => {\n        if ((child as any).isMesh && (child as any).material) {\n          const mesh = child as THREE.Mesh;\n          const childName = child.name || \"\";\n\n          // Keep currency symbols and pacman parts hidden\n          if (\n            isCurrencySymbol(childName) ||\n            (key === \"pacman\" && isPacmanPart(childName))\n          ) {\n            mesh.visible = false;\n            return;\n          }\n\n          // CRITICAL: Force visibility EVERY frame (don't check, just set it)\n          mesh.visible = true;\n\n          // CRITICAL: Force opacity EVERY frame using centralized utility\n          // This ensures opacity is always correct and ghost materials keep transparent=true\n          if (Array.isArray(mesh.material)) {\n            mesh.material.forEach((mat: any) => {\n              setMaterialOpacity(mat, targetOpacity, true);\n            });\n          } else {\n            setMaterialOpacity(mesh.material as any, targetOpacity, true);\n          }\n\n          // Set ghost colors using centralized utility (only if needed)\n          if (GHOST_COLORS[key] && key !== \"pacman\") {\n            setGhostColor(object, GHOST_COLORS[key]);\n          }\n        }\n      });\n\n      // CRITICAL: Force matrix update after all changes (only once per object)\n      object.updateMatrixWorld(true);\n    });\n  } finally {\n    isUpdating = false;\n  }\n}\n","import gsap from \"gsap\";\nimport { applyOutroScrollPreset, getScrollDirection } from \"./scene-presets\";\nimport { SCROLL_SELECTORS } from \"./constants\";\n\nlet outroScrollTimeline: gsap.core.Timeline | null = null;\n\nexport function initOutroScrollAnimation() {\n  outroScrollTimeline = gsap.timeline({\n    scrollTrigger: {\n      trigger: SCROLL_SELECTORS.OUTRO,\n      start: \"top center\",\n      end: \"bottom bottom\",\n      scrub: 0.5,\n      onEnter: () => {\n        const scrollDir = getScrollDirection();\n        applyOutroScrollPreset(true, scrollDir);\n      },\n      onEnterBack: () => {\n        const scrollDir = getScrollDirection();\n        applyOutroScrollPreset(true, scrollDir);\n      },\n    }\n  }).fromTo(\n    \".sc_b--outro\", { scale: 0.5, opacity: 0 },\n    {\n      keyframes: [\n        { scale: 0.5, opacity: 0, duration: 0 },\n        { scale: 0.8, opacity: 1, duration: 0.3 },\n        { scale: 1.2, opacity: 1, duration: 0.4 },\n        { scale: 1.5, opacity: 0, duration: 0.3 }\n      ]\n    }\n  );\n}","import {\n  startRenderLoop,\n  initRenderer,\n  setupLighting,\n  scene,\n  createDebugLines,\n} from \"./core/scene\";\nimport {\n  homeLoopHandler,\n  setupHomeLoopScrollHandler,\n} from \"./animation/home-loop\";\nimport { initPovScrollAnimation } from \"./animation/pov-scroll\";\nimport { loadModel } from \"./core/objects\";\nimport { setupCamera } from \"./core/camera\";\nimport { XCoordKey, ZCoordKey } from \"./paths/coordinates\";\nimport { initIntroScrollAnimation } from \"./animation/intro-scroll\";\nimport { initOutroScrollAnimation } from \"./animation/outro-scroll\";\nimport { initializeObjectStates } from \"./animation/object-state\";\n\n// Declare global window interface for debug commands\ndeclare global {\n  interface Window {\n    lookAt: (x: XCoordKey, y: number, z: ZCoordKey) => void;\n  }\n}\n\nfunction initSkipButton() {\n  const skipButton = document.querySelector(\".wr_p--skip.wr_p\");\n  if (skipButton) {\n    const finalSection = document.querySelector(\".sc--testimonials\");\n    if (finalSection) {\n      skipButton.addEventListener(\"click\", () => {\n        finalSection.scrollIntoView({\n          behavior: \"smooth\",\n          block: \"start\",\n          inline: \"nearest\",\n        });\n      });\n    }\n  }\n}\n\nasync function main() {\n  initRenderer();\n  setupLighting();\n  setupCamera();\n  createDebugLines();\n  await loadModel(scene);\n\n  // Initialize unified object state manager\n  initializeObjectStates();\n\n  homeLoopHandler();\n  setupHomeLoopScrollHandler();\n\n  initPovScrollAnimation();\n  initIntroScrollAnimation();\n  initOutroScrollAnimation();\n  initSkipButton();\n  startRenderLoop();\n}\n\nmain();\n"],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","THREE","isMobile","window","innerWidth","SCROLL_SELECTORS","SELECTORS","DOM_ELEMENTS","mazeContainer","document","querySelector","canvas","homeSection","introSection","povSection","finalSection","finalContainer","parentElements","querySelectorAll","gsap","ScrollTrigger","X","Z","getCoord","x","z","Vector3","objectHomeScrollEndPathPoint","cameraPathPointsConfig","startMobile","startDesktop","secondMobile","secondDesktop","mobileLookAt","desktopLookAt","cameraLookAtSecondDesktop","cameraLookAtSecondMobile","cameraHomeScrollEndLookAt","thirdPosition","cameraHomeScrollEndPathPoint","startPosition","secondPosition","lookAtPosition","cameraLookAtSecondPosition","pacmanHomePathPoints","pos","type","arc","curveCheckPoints","ghost1HomePathPoints","ghost2HomePathPoints","ghost3HomePathPoints","ghost4HomePathPoints","ghost5HomePathPoints","cameraHomeScrollPathPoints","lookAt","cameraPOVPathPoints","lookAtSequence","ghost1POVPathPoints","ghost2POVPathPoints","ghost3POVPathPoints","ghost4POVPathPoints","ghost5POVPathPoints","povTriggerPositions","ghost1","triggerPos","ghostStartFadeIn","ghostEndFadeIn","ghostStartFadeOut","camStartFadeIn","camEndFadeIn","camStartFadeOut","endPosition","forceEndProgress","start","end","ghost2","ghost3","ghost4","ghost5","getStartPosition","getLookAtPosition","homePaths","pacman","camera","getCameraHomeScrollPathPoints","innerHeight","scene","renderer","antialias","alpha","powerPreference","precision","clock","frameCallbacks","setPixelRatio","pixelRatio","Math","min","devicePixelRatio","setSize","clientWidth","clientHeight","aspect","updateProjectionMatrix","mazeTexture","load","mazeMaterial","matcap","topMaterial","color","metalness","roughness","envMapIntensity","ghostMaterial","opacity","transparent","depthWrite","depthTest","blending","side","transmission","floorMaterial","pacmanMaterials","blue","white","default","materialMap","CAM_Pacman_Backframe","CAM_Pacman_Logo_1","CAM_Pacman_Logo_2","loader","pacmanMixer","ghostContainers","Ghost_EUR","Ghost_CHF","Ghost_YEN","Ghost_USD","Ghost_GBP","pathCache","Map","TangentSmoother","constructor","initialTangent","smoothing","this","currentTangent","clone","update","targetTangent","lerp","normalize","reset","newTangent","copy","getCurrentTangent","setSmoothingFactor","max","createMazePath","pathPoints","pathName","cacheKey","map","p","y","join","has","path","i","length","current","next","catmullPoints","add","midPoint","createNormalCurveMidPoint","set","curveType","createCameraHomeScrollPath","curve","getHomePaths","paths","entries","forEach","getPovPaths","OBJECT_KEYS","GHOST_COLORS","CURRENCY_SYMBOLS","isCurrencySymbol","name","some","symbol","includes","isPacmanPart","calculateObjectOrientation","object","tangent","objectType","targetRotation","atan2","rotation","PI","lookAtPoint","position","baseLayDownQuat","setFromEuler","LAY_DOWN_QUAT_1","setFromAxisAngle","multiply","LAY_DOWN_QUAT_2","slerpToLayDown","startQuat","progress","targetQuat","angleTo","quaternion","slerp","options","preserveTransmission","skipCurrencySymbols","traverse","child","isMesh","material","mesh","childName","Array","isArray","mat","setMaterialOpacity","undefined","needsUpdate","setMaterialTransparent","setGhostColor","getHex","setHex","setFloorPlane","visible","setObjectScale","sceneType","scale","updateMatrixWorld","killObjectAnimations","pacmanTargetQuaternion","ghostTargetQuaternion","introInitialRotations","applyPovScrollPreset","isEntering","scrollDirection","applyOutroScrollPreset","lastScrollY","scrollY","getScrollDirection","currentScrollY","direction","homeLoopState","t","pausedT","animationTime","currentObjectStates","isHomeLoopActive","setHomeLoopActive","active","syncStateFromObjects","initialOpacity","getCurrentPositions","positions","state","getCurrentRotations","rotations","updateObjectPosition","updateObjectRotation","homeScrollTimeline","startPositions","initHomeScrollAnimation","kill","cameraPathPoints","cameraPath","cameraCurve","handleScrollEnter","requestAnimationFrame","freshRotations","freshPositions","pausedPositions","pausedRotations","createObjectAnimations","createCameraAnimation","scrollTrigger","id","trigger","scrub","onEnter","onEnterBack","onScrubComplete","homeLoopHandler","allObjects","clear","homeScrollPaths","scrollPathPoints","scrollPaths","pausedPos","arcPoint","createHomeScrollPathPoints","createHomeScrollPath","getHomeScrollPaths","animPropsArray","animationData","currentMaterialOpacity","getObjectOpacity","clonedMaterials","originalMat","clonedMat","startRot","startEuler","setFromQuaternion","endEuler","console","warn","animProps","rotX","rotY","rotZ","push","totalObjects","data","index","staggerPosition","fromTo","ease","onUpdate","pathPoint","getPointAt","cameraProgressWrapper","value","curves","immediateRender","targets","cameraPoint","lookAtPoints","point","getPoint","fov","LOOP_DURATION","ROTATION_TRANSITION_DURATION","homeLoopFrameRegistered","rotationTransitionTime","startRotations","hasBeenPausedBefore","homeLoopTangentSmoothers","startHomeLoop","currentPositions","totalT","count","closestT","closestDist","Infinity","dist","distanceTo","resetGhostMaterialsToFullOpacity","callback","ghost","savedPosition","getTangentAt","delta","updateHomeLoopT","transitionProgress","isTransitioning","rawTangent","smoothTangent","tempObject","easedProgress","updateHomeLoop","getDelta","domElementCache","povScrollTimeline","previousCameraPosition","rotationStarted","startedInitEndScreen","startRotationPoint","endRotationPoint","cachedStartYAngle","ghostStates","povTangentSmoothers","initPovScrollAnimation","initializePovTangentSmoothers","keys","hasBeenTriggered","triggerCameraProgress","ghostStartFadeInProgress","ghostEndFadeInProgress","ghostStartFadeOutProgress","camStartFadeInProgress","camEndFadeInProgress","camStartFadeOutProgress","endCameraProgress","currentPathT","markers","toggleActions","to","onStart","handleAnimationStart","handleAnimationUpdate","onReverseComplete","handleLeavePOV","resetState","onComplete","povPaths","initialCameraTangent","overallProgress","cameraPosition","introScrollTrigger","isActive","customLookAt","sequencePhaseEnd","firstPoint","sequenceProgress","sequenceLength","segmentSize","currentSegment","floor","segmentProgress","fromIndex","toIndex","fromTarget","toTarget","finalSequenceLookAt","constrainedTangent","defaultLookAt","getCustomLookAtForProgress","startRotationProgress","findClosestProgressOnPath","endRotationProgress","handleDefaultOrientation","updateCamera","triggerData","ghostIndex","parseInt","replace","cached","parent","povElements","camElements","currentCameraProgress","normalizedProgress","ghostProgress","parameterSmoothingFactor","style","classList","hideTextElements","targetGhostOpacity","targetCamOpacity","fadeProgress","toString","fadeOutProgress","isPassed","hasNoVisibility","contains","remove","povElement","element","camElement","updateTextVisibility","updateGhost","updateGhosts","resetTangentSmoothers","resetVector","elements","el","targetPoint","samples","closestProgress","closestDistance","pointOnPath","distance","error","introScrollTimeline","isIntroScrollActive","lastIntroProgress","isUpdating","initializeIntroScrollState","homeScrollTrigger","homeTimeline","timeline","pause","povScrollTrigger","povTimeline","pauseOtherScrollTriggers","setVisibilityForAll","setObjectVisibilityAndOpacity","xRotation180","pacmanObj","pacmanRotation90","pacmanRotationY180","ghostObj","ghostRotationY180","baseX","behindOffset","applyIntroScrollPreset","updateObjectsWalkBy","restoreFloor","baseCenter","walkDistance","walkStart","walkEnd","objectsToAnimate","pacmanX","pacmanY","pacmanZ","fadeInDuration","ghostOpacity","finalX","finalY","finalZ","pacmanQuat","ghostQuat","targetOpacity","outroScrollTimeline","async","shadowMap","enabled","appendChild","domElement","body","addEventListener","render","ambientLight","directionalLight","shadow","mapSize","width","height","left","right","top","bottom","near","far","bias","radius","castShadow","setupLighting","setupCamera","redLineGeometry","setFromPoints","redLineMaterial","linewidth","redLine","renderOrder","greenLineGeometry","greenLineMaterial","greenLine","createDebugLines","values","Promise","resolve","reject","gltf","model","children","subChild","item","pacmanActions","animations","clip","action","clipAction","getMixer","e","getRoot","userData","skipAnimation","updateMorphTargets","setEffectiveWeight","play","ghostContainer","ghostGroup","startsWith","clonedChild","receiveShadow","node","loadModel","updateHomeLoopPausedT","stopHomeLoop","refreshPriority","onLeave","onLeaveBack","self","keyframes","duration","skipButton","scrollIntoView","behavior","block","inline","initSkipButton","startRenderLoop","main"],"sourceRoot":""}