{"version":3,"file":"script.js","mappings":"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","sources":["webpack://cam-3d-animation/external var \"THREE\"","webpack://cam-3d-animation/./src/config.ts","webpack://cam-3d-animation/./src/scene.ts","webpack://cam-3d-animation/./src/camera.ts","webpack://cam-3d-animation/./src/materials.ts","webpack://cam-3d-animation/./src/objects.ts","webpack://cam-3d-animation/./src/animation.ts","webpack://cam-3d-animation/./src/main.ts"],"sourcesContent":["const __WEBPACK_NAMESPACE_OBJECT__ = THREE;","import * as THREE from \"three\";\n\nexport const isMobile = window.innerWidth < 768;\n\nexport const CAMERA_CONFIG = {\n  originalFOV: 50,\n  wideFOV: 80,\n  near: 0.001,\n  far: 1000,\n};\n\nexport const ASSETS = {\n  mazeTexture: \"https://c-am.b-cdn.net/CAM/matcap24.png\",\n  mazeModel: \"https://c-am.b-cdn.net/CAM/c-am-assets-3.glb\",\n};\n\nexport const MAZE_CENTER = new THREE.Vector3(0.45175, 0.5, 0.55675);\n\nexport const POV_POSITIONS = {\n  ghost1: new THREE.Vector3(0.65725, 0.55, 0.75325),\n  ghost2: new THREE.Vector3(0.9085, 0.55, 0.8035),\n  ghost3: new THREE.Vector3(0.75775, 0.55, 1.05475),\n  ghost4: new THREE.Vector3(0.65725, 0.55, 1.0045),\n  ghost5: new THREE.Vector3(0.15475, 0.55, 1.15525),\n};\n\nexport const CAMERA_POSITIONS = {\n  startMobile: new THREE.Vector3(0.5, 2.5, 2.5),\n  startDesktop: new THREE.Vector3(-2, 2.5, 2),\n  secondMobile: new THREE.Vector3(0.5, 2.5, 2),\n  secondDesktop: new THREE.Vector3(-1.5, 3, 2),\n  mobileLookAt: new THREE.Vector3(0.5, 0.5, -1.5),\n  desktopLookAt: new THREE.Vector3(-1.25, 0.5, 0.25),\n};\n\nexport const startPosition = isMobile\n  ? CAMERA_POSITIONS.startMobile\n  : CAMERA_POSITIONS.startDesktop;\nexport const secondPosition = isMobile\n  ? CAMERA_POSITIONS.secondMobile\n  : CAMERA_POSITIONS.secondDesktop;\nexport const lookAtPosition = isMobile\n  ? CAMERA_POSITIONS.mobileLookAt\n  : CAMERA_POSITIONS.desktopLookAt;\n\n// DOM Selectors\nexport const SELECTORS = {\n  mazeContainer: \".el--home-maze.el\",\n  homeSection: \".sc--home.sc\",\n  introSection: \".sc--intro.sc\",\n  povSection: \".sc--pov.sc\",\n  finalSection: \".sc--final.sc\",\n  scrollComponent: \".cmp--scroll.cmp\",\n  parentElements: \".cmp--pov.cmp\",\n  pov: \".pov\",\n  cam: \".cam\",\n  finalContainer: \".cr--final.cr\",\n};\n\n// DOM Elements\nexport const DOM_ELEMENTS = {\n  mazeContainer: document.querySelector(SELECTORS.mazeContainer) as HTMLElement,\n  canvas: document.querySelector(\"canvas\") as HTMLCanvasElement,\n  finalSection: document.querySelector(SELECTORS.finalSection) as HTMLElement,\n  finalContainer: document.querySelector(\n    SELECTORS.finalContainer\n  ) as HTMLElement,\n  parentElements: document.querySelectorAll(\n    SELECTORS.parentElements\n  ) as NodeListOf<Element>,\n};\n","import * as THREE from \"three\";\nimport { isMobile, DOM_ELEMENTS } from \"./config\";\n\nexport const scene = new THREE.Scene();\n\nexport const renderer = new THREE.WebGLRenderer({\n  antialias: true,\n  alpha: true,\n  powerPreference: \"high-performance\",\n  precision: \"highp\",\n});\n\nexport const clock = new THREE.Clock();\n\nfunction enhanceAntiAliasing(): void {\n  if (isMobile) {\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n  } else {\n    renderer.setPixelRatio(window.devicePixelRatio);\n  }\n  renderer.shadowMap.enabled = true;\n  renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n}\n\nfunction setPixelRatio(): void {\n  const pixelRatio = Math.min(window.devicePixelRatio, isMobile ? 2 : 3);\n  renderer.setPixelRatio(pixelRatio);\n\n  if (DOM_ELEMENTS.mazeContainer) {\n    renderer.setSize(\n      DOM_ELEMENTS.mazeContainer.clientWidth,\n      DOM_ELEMENTS.mazeContainer.clientHeight\n    );\n  } else {\n    renderer.setSize(window.innerWidth, window.innerHeight);\n  }\n}\n\nexport function initRenderer(): void {\n  enhanceAntiAliasing();\n\n  renderer.shadowMap.enabled = true;\n  renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n  if (DOM_ELEMENTS.mazeContainer) {\n    console.log(\"Found maze container, using it for renderer\");\n    renderer.setSize(\n      DOM_ELEMENTS.mazeContainer.clientWidth,\n      DOM_ELEMENTS.mazeContainer.clientHeight\n    );\n    DOM_ELEMENTS.mazeContainer.appendChild(renderer.domElement);\n  } else {\n    console.log(\"Maze container not found, using body for renderer\");\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(renderer.domElement);\n  }\n\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", setPixelRatio);\n  } else {\n    setPixelRatio();\n  }\n  window.addEventListener(\"resize\", setPixelRatio);\n}\n\nexport function setupLighting(): void {\n  const ambientLight = new THREE.AmbientLight(0xffffff);\n  scene.add(ambientLight);\n\n  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n  scene.add(directionalLight);\n  directionalLight.position.set(-5, 15, 10);\n  directionalLight.shadow.mapSize.width = 4096;\n  directionalLight.shadow.mapSize.height = 4096;\n  directionalLight.shadow.camera.left = -20;\n  directionalLight.shadow.camera.right = 20;\n  directionalLight.shadow.camera.top = 20;\n  directionalLight.shadow.camera.bottom = -20;\n  directionalLight.shadow.camera.near = 0.1;\n  directionalLight.shadow.camera.far = 50;\n  directionalLight.shadow.bias = -0.001;\n  directionalLight.shadow.radius = 3;\n  directionalLight.castShadow = true;\n}\n","import * as THREE from \"three\";\nimport {\n  CAMERA_CONFIG,\n  startPosition,\n  secondPosition,\n  lookAtPosition,\n} from \"./config\";\n\nexport const camera = new THREE.PerspectiveCamera(\n  CAMERA_CONFIG.originalFOV,\n  window.innerWidth / window.innerHeight,\n  CAMERA_CONFIG.near,\n  CAMERA_CONFIG.far\n);\n\nexport function initCamera(): void {\n  camera.position.copy(startPosition);\n  camera.lookAt(lookAtPosition);\n}\n\nexport const startQuaternion = camera.quaternion.clone();\nexport const endQuaternion = new THREE.Quaternion().setFromEuler(\n  new THREE.Euler(-1.5708, 0, 0)\n);\n\nexport function getCameraLookAtPoint(): THREE.Vector3 {\n  const direction = new THREE.Vector3(0, 0, -1);\n  direction.applyQuaternion(camera.quaternion);\n  const lookAtPoint = new THREE.Vector3();\n  lookAtPoint.copy(camera.position).add(direction.multiplyScalar(10));\n  return lookAtPoint;\n}\n\n/*(window as any).setCamera = function (lookAt: string | THREE.Vector3): void {\n  if (typeof lookAt === \"string\") {\n    const [x, y, z] = lookAt.split(\",\").map(Number);\n    lookAt = new THREE.Vector3(x, y, z);\n  }\n  camera.lookAt(lookAt);\n  camera.updateProjectionMatrix();\n  camera.updateMatrix();\n  camera.updateMatrixWorld();\n};*/\n\nexport function setupCameraResize(): void {\n  const updateCamera = () => {\n    camera.aspect = window.innerWidth / window.innerHeight;\n    camera.updateProjectionMatrix();\n  };\n\n  window.addEventListener(\"resize\", updateCamera);\n}\n","import * as THREE from \"three\";\nimport { ASSETS } from \"./config\";\n\nconst textureLoader = new THREE.TextureLoader();\n\nexport const mazeTexture = textureLoader.load(ASSETS.mazeTexture);\n\nexport const mazeMaterial = new THREE.MeshMatcapMaterial({\n  matcap: mazeTexture,\n});\n\nexport const topMaterial = new THREE.MeshStandardMaterial({\n  color: 0xf2f9f9,\n  metalness: 0.4,\n  roughness: 0,\n  envMapIntensity: 10,\n});\n\nexport const ghostMaterial = new THREE.MeshPhysicalMaterial({\n  color: 0xffffff,\n  opacity: 1,\n  transparent: true,\n  depthWrite: false,\n  depthTest: true,\n  blending: THREE.NormalBlending,\n  side: THREE.DoubleSide,\n  roughness: 0.75,\n  metalness: 0.2,\n  transmission: 0.5,\n});\n\nexport const floorMaterial = new THREE.MeshStandardMaterial({\n  color: 0xffffff,\n  opacity: 0.8,\n  transparent: true,\n  roughness: 0.5,\n  metalness: 0.1,\n});\n\nconst pacmanMaterials = {\n  blue: new THREE.MeshBasicMaterial({\n    color: 0x1469d3,\n    transparent: true,\n    opacity: 1,\n  }),\n  white: new THREE.MeshBasicMaterial({\n    color: 0xffffff,\n    transparent: true,\n    opacity: 1,\n  }),\n  default: new THREE.MeshBasicMaterial({\n    color: 0x1469d3,\n    transparent: true,\n    opacity: 1,\n  }),\n};\n\nexport const materialMap = {\n  CAM_Pacman_Backframe: pacmanMaterials.blue,\n  \"CAM-Pacman_Bitcoin_1\": pacmanMaterials.white,\n  \"CAM-Pacman_Bitcoin_2\": pacmanMaterials.white,\n  \"CAM-Pacman_Bottom\": pacmanMaterials.blue,\n  \"CAM-Pacman_Top\": pacmanMaterials.blue,\n  \"CAM-Pacman_Eye\": pacmanMaterials.white,\n  CAM_Pacman_Logo_1: pacmanMaterials.white,\n  CAM_Pacman_Logo_2: pacmanMaterials.white,\n  \"CAM-Pacman_Shell_Boolean\": pacmanMaterials.blue,\n  \"CAM-Pacman_Shell\": pacmanMaterials.blue,\n  \"CAM-Pacman_Bottom_electronic\": pacmanMaterials.white,\n  \"CAM-Pacman_Top_electronic\": pacmanMaterials.white,\n  \"CAM-Pacman_Bottom_Text\": pacmanMaterials.white,\n  \"CAM-Pacman_Top_Text\": pacmanMaterials.white,\n  default: pacmanMaterials.blue,\n};\n\nexport const ghostCoverMaterials = Array(5).fill(ghostMaterial);\n","import * as THREE from \"three\";\nimport { ASSETS } from \"./config\";\nimport { GhostContainer } from \"./types\";\nimport { scene, clock } from \"./scene\";\nimport {\n  mazeMaterial,\n  topMaterial,\n  ghostMaterial,\n  floorMaterial,\n  materialMap,\n} from \"./materials\";\n\nexport { clock };\n\nconst loader = new THREE.GLTFLoader();\n\nexport let pacmanMixer: THREE.AnimationMixer;\n\nexport const pacman = new THREE.Group();\nscene.add(pacman);\n\nexport const ghosts: GhostContainer = {\n  pacman: pacman,\n  ghost1: new THREE.Mesh(new THREE.BufferGeometry(), ghostMaterial),\n  ghost2: new THREE.Mesh(new THREE.BufferGeometry(), ghostMaterial),\n  ghost3: new THREE.Mesh(new THREE.BufferGeometry(), ghostMaterial),\n  ghost4: new THREE.Mesh(new THREE.BufferGeometry(), ghostMaterial),\n  ghost5: new THREE.Mesh(new THREE.BufferGeometry(), ghostMaterial),\n};\n\nconst ghostContainers = {\n  Ghost_EUR: ghosts.ghost1,\n  Ghost_CHF: ghosts.ghost2,\n  Ghost_YEN: ghosts.ghost3,\n  Ghost_USD: ghosts.ghost4,\n  Ghost_GBP: ghosts.ghost5,\n};\n\nObject.values(ghosts).forEach((ghost) => scene.add(ghost));\n\nexport async function loadModel(): Promise<void> {\n  return new Promise((resolve, reject) => {\n    loader.load(\n      ASSETS.mazeModel,\n      function (gltf) {\n        const model = gltf.scene;\n\n        model.traverse((child: THREE.Object3D) => {\n          if (child.name === \"CAM-Pacman\") {\n            const children: THREE.Object3D[] = [];\n            child.traverse((subChild: THREE.Object3D) => {\n              if (\n                (subChild as any).isMesh &&\n                subChild.name !== \"CAM-Pacman_Shell\" &&\n                subChild.name !== \"CAM-Pacman_Shell_Boolean\"\n              ) {\n                const material =\n                  materialMap[subChild.name as keyof typeof materialMap] ||\n                  materialMap.default;\n                (subChild as THREE.Mesh).material = material;\n                children.push(subChild);\n              } else if (\n                subChild.name === \"CAM-Pacman_Shell\" ||\n                subChild.name === \"CAM-Pacman_Shell_Boolean\"\n              ) {\n                subChild.visible = false;\n              }\n            });\n\n            children.forEach((item) => ghosts.pacman.add(item));\n            ghosts.pacman.scale.set(0.05, 0.05, 0.05);\n            ghosts.pacman.rotation.set(Math.PI / 2, Math.PI / 2, Math.PI / 4);\n\n            pacmanMixer = new THREE.AnimationMixer(ghosts.pacman);\n            const pacmanActions: { [key: string]: THREE.AnimationAction } = {};\n\n            gltf.animations.forEach((clip: THREE.AnimationClip) => {\n              const action = pacmanMixer.clipAction(clip);\n              pacmanActions[clip.name] = action;\n              action.setEffectiveWeight(1);\n              action.play();\n            });\n          } else if (\n            child.name &&\n            ghostContainers[child.name as keyof typeof ghostContainers]\n          ) {\n            const ghostContainer =\n              ghostContainers[child.name as keyof typeof ghostContainers];\n            const ghostGroup = new THREE.Group();\n\n            child.rotation.z = Math.PI;\n            child.rotation.x = Math.PI / 2;\n            child.scale.set(0.75, 0.75, 0.75);\n\n            const children: THREE.Object3D[] = [];\n            child.traverse((subChild: THREE.Object3D) => {\n              if ((subChild as any).isMesh) {\n                if (subChild.name && subChild.name.startsWith(\"Ghost_Mesh\")) {\n                  (subChild as THREE.Mesh).material = ghostMaterial;\n                } else if (\n                  subChild.name &&\n                  [\"EUR\", \"CHF\", \"YEN\", \"USD\", \"GBP\"].includes(subChild.name)\n                ) {\n                  subChild.visible = false;\n                }\n                children.push(subChild);\n              }\n            });\n\n            children.forEach((item) => {\n              if (\n                item.name &&\n                (item.name.includes(\"EUR\") ||\n                  item.name.startsWith(\"Ghost_Mesh\"))\n              ) {\n                item.rotation.z = Math.PI;\n                item.rotation.x = Math.PI / 2;\n              } else {\n                item.rotation.set(0, 0, 0);\n              }\n              ghostGroup.add(item);\n            });\n\n            ghostContainer.add(ghostGroup);\n          }\n\n          if ((child as any).isMesh) {\n            if (child.name === \"CAM-Arena_LowRes_Top\") {\n              (child as THREE.Mesh).material = topMaterial;\n              child.castShadow = true;\n            } else if (child.name === \"CAM-Arena_LowRes_Bottom\") {\n              (child as THREE.Mesh).material = mazeMaterial;\n              child.castShadow = true;\n            } else if (child.name === \"CAM-Floor\") {\n              const clonedChild = child.clone();\n              child.position.y = -0.1;\n              child.position.x = 0;\n              child.position.z = 0;\n              (child as THREE.Mesh).material = new THREE.MeshBasicMaterial({\n                color: 0xffffff,\n                opacity: 1,\n                transparent: false,\n                depthWrite: true,\n                depthTest: true,\n                side: THREE.FrontSide,\n              });\n              child.receiveShadow = false;\n              child.castShadow = true;\n              child.scale.set(0.5, 0.5, 0.5);\n\n              (clonedChild as THREE.Mesh).material = floorMaterial;\n              clonedChild.position.y = -0.5;\n              clonedChild.receiveShadow = true;\n              scene.add(clonedChild);\n            }\n          }\n        });\n\n        model.traverse(function (node: THREE.Object3D) {\n          if ((node as any).isMesh) {\n            node.castShadow = true;\n            node.receiveShadow = true;\n          }\n        });\n\n        scene.add(model);\n        model.position.set(0.5, 0.5, 0.5);\n\n        resolve();\n      },\n      function (progress: any) {},\n      function (error: any) {\n        reject(error);\n      }\n    );\n  });\n}\n","import * as THREE from \"three\";\nimport { camera, initCamera } from \"./camera\";\nimport { scene, renderer, clock } from \"./scene\";\nimport { ghosts, pacman } from \"./objects\";\nimport { paths, getPathsForSection } from \"./paths\";\nimport { MAZE_CENTER } from \"./config\";\n\n// Animation state\nexport type AnimationState = \"IDLE\" | \"HOME_ANIMATION\" | \"SCROLL_ANIMATION\";\n\nclass AnimationSystem {\n  private state: AnimationState = \"IDLE\";\n  private animationTime: number = 0;\n  private animationDuration: number = 3; // 3 seconds for home animation\n  private isAnimating: boolean = false;\n\n  // Animation targets\n  private cameraStartPosition: THREE.Vector3;\n  private cameraEndPosition: THREE.Vector3;\n  private cameraStartLookAt: THREE.Vector3;\n  private cameraEndLookAt: THREE.Vector3;\n\n  // Object start positions (will be set when animation starts)\n  private objectStartPositions: { [key: string]: THREE.Vector3 } = {};\n\n  constructor() {\n    console.log(\"AnimationSystem: Initializing...\");\n    console.log(\"AnimationSystem: MAZE_CENTER:\", MAZE_CENTER);\n\n    // Initialize camera positions\n    this.cameraStartPosition = camera.position.clone();\n    this.cameraEndPosition = new THREE.Vector3(\n      MAZE_CENTER.x,\n      MAZE_CENTER.y + 2,\n      MAZE_CENTER.z + 3\n    );\n    this.cameraStartLookAt = new THREE.Vector3(0, 0, 0); // Will be set from current camera\n    this.cameraEndLookAt = MAZE_CENTER.clone();\n\n    console.log(\n      \"AnimationSystem: Camera start position:\",\n      this.cameraStartPosition\n    );\n    console.log(\n      \"AnimationSystem: Camera end position:\",\n      this.cameraEndPosition\n    );\n  }\n\n  // Start the home animation\n  public startHomeAnimation(): void {\n    if (this.isAnimating) return;\n\n    console.log(\"AnimationSystem: Starting home animation...\");\n    console.log(\"AnimationSystem: Pacman position:\", pacman.position);\n    console.log(\"AnimationSystem: Ghosts:\", ghosts);\n\n    this.state = \"HOME_ANIMATION\";\n    this.isAnimating = true;\n    this.animationTime = 0;\n\n    // Store current positions of all objects\n    this.objectStartPositions = {\n      pacman: pacman.position.clone(),\n      ghost1: ghosts.ghost1.position.clone(),\n      ghost2: ghosts.ghost2.position.clone(),\n      ghost3: ghosts.ghost3.position.clone(),\n      ghost4: ghosts.ghost4.position.clone(),\n      ghost5: ghosts.ghost5.position.clone(),\n    };\n\n    // Store current camera look-at\n    const direction = new THREE.Vector3(0, 0, -1);\n    direction.applyQuaternion(camera.quaternion);\n    this.cameraStartLookAt = camera.position\n      .clone()\n      .add(direction.multiplyScalar(10));\n\n    console.log(\"AnimationSystem: Home animation started\");\n  }\n\n  // Update animation\n  public update(): void {\n    if (!this.isAnimating) return;\n\n    const deltaTime = clock.getDelta();\n    this.animationTime += deltaTime;\n\n    if (this.state === \"HOME_ANIMATION\") {\n      this.updateHomeAnimation();\n    }\n  }\n\n  private updateHomeAnimation(): void {\n    const progress = Math.min(this.animationTime / this.animationDuration, 1);\n\n    // Use easing function for smooth animation\n    const easedProgress = this.easeInOutCubic(progress);\n\n    // Animate camera\n    this.animateCamera(easedProgress);\n\n    // Animate objects to center\n    this.animateObjectsToCenter(easedProgress);\n\n    // Check if animation is complete\n    if (progress >= 1) {\n      this.completeHomeAnimation();\n    }\n  }\n\n  private animateCamera(progress: number): void {\n    // Interpolate camera position\n    camera.position.lerpVectors(\n      this.cameraStartPosition,\n      this.cameraEndPosition,\n      progress\n    );\n\n    // Interpolate camera look-at\n    const currentLookAt = new THREE.Vector3();\n    currentLookAt.lerpVectors(\n      this.cameraStartLookAt,\n      this.cameraEndLookAt,\n      progress\n    );\n\n    camera.lookAt(currentLookAt);\n    camera.updateProjectionMatrix();\n  }\n\n  private animateObjectsToCenter(progress: number): void {\n    const centerPosition = MAZE_CENTER.clone();\n    centerPosition.y += 0.5; // Slightly above maze center\n\n    // Animate Pacman\n    pacman.position.lerpVectors(\n      this.objectStartPositions.pacman,\n      centerPosition,\n      progress\n    );\n\n    // Animate ghosts in a circle around the center\n    const ghostRadius = 0.8;\n    const ghostCount = 5;\n\n    Object.keys(ghosts).forEach((ghostKey, index) => {\n      if (ghostKey === \"pacman\") return; // Skip pacman, already animated\n\n      const ghost = ghosts[ghostKey];\n      const angle = (index / ghostCount) * Math.PI * 2;\n\n      const ghostEndPosition = new THREE.Vector3(\n        centerPosition.x + Math.cos(angle) * ghostRadius,\n        centerPosition.y,\n        centerPosition.z + Math.sin(angle) * ghostRadius\n      );\n\n      ghost.position.lerpVectors(\n        this.objectStartPositions[ghostKey],\n        ghostEndPosition,\n        progress\n      );\n    });\n  }\n\n  private completeHomeAnimation(): void {\n    this.isAnimating = false;\n    this.state = \"IDLE\";\n    console.log(\"AnimationSystem: Home animation completed\");\n  }\n\n  // Easing function for smooth animation\n  private easeInOutCubic(t: number): number {\n    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;\n  }\n\n  // Public getters\n  public getState(): AnimationState {\n    return this.state;\n  }\n\n  public isAnimationActive(): boolean {\n    return this.isAnimating;\n  }\n\n  // Render function\n  public render(): void {\n    renderer.render(scene, camera);\n  }\n}\n\n// Create and export the animation system\nexport const animationSystem = new AnimationSystem();\n\n// Animation loop\nexport function animate(): void {\n  requestAnimationFrame(animate);\n\n  // Update animation system\n  animationSystem.update();\n\n  // Render the scene\n  animationSystem.render();\n}\n\n// Start the animation loop\nexport function startAnimationLoop(): void {\n  console.log(\"AnimationSystem: Starting animation loop...\");\n  animate();\n}\n\n// Initialize animation system\nexport function initAnimationSystem(): void {\n  console.log(\"AnimationSystem: Initializing animation system...\");\n\n  // Initialize camera\n  initCamera();\n\n  // Start animation loop\n  startAnimationLoop();\n\n  // Auto-start home animation after a short delay\n  setTimeout(() => {\n    console.log(\"AnimationSystem: Auto-starting home animation...\");\n    animationSystem.startHomeAnimation();\n  }, 1000);\n}\n","import { initRenderer, setupLighting } from \"./scene\";\nimport { initCamera, setupCameraResize } from \"./camera\";\nimport { loadModel } from \"./objects\";\nimport { initAnimationSystem } from \"./animation\";\nimport { animate } from \"./animation\";\n\nasync function init() {\n  try {\n    initRenderer();\n    setupLighting();\n    initCamera();\n    setupCameraResize();\n\n    await loadModel();\n\n    initAnimationSystem();\n    animate();\n  } catch (error) {\n    console.error(\"Initialization error:\", error);\n  }\n}\n\ninit();\n"],"names":["THREE","isMobile","window","innerWidth","MAZE_CENTER","CAMERA_POSITIONS","startMobile","startDesktop","secondMobile","secondDesktop","mobileLookAt","desktopLookAt","startPosition","lookAtPosition","DOM_ELEMENTS","mazeContainer","document","querySelector","canvas","finalSection","finalContainer","parentElements","querySelectorAll","scene","renderer","antialias","alpha","powerPreference","precision","clock","setPixelRatio","pixelRatio","Math","min","devicePixelRatio","setSize","clientWidth","clientHeight","innerHeight","camera","initCamera","position","copy","lookAt","quaternion","clone","setFromEuler","mazeTexture","load","mazeMaterial","matcap","topMaterial","color","metalness","roughness","envMapIntensity","ghostMaterial","opacity","transparent","depthWrite","depthTest","blending","side","transmission","floorMaterial","pacmanMaterials","blue","white","default","materialMap","CAM_Pacman_Backframe","CAM_Pacman_Logo_1","CAM_Pacman_Logo_2","loader","Array","fill","pacmanMixer","pacman","add","ghosts","ghost1","ghost2","ghost3","ghost4","ghost5","ghostContainers","Ghost_EUR","Ghost_CHF","Ghost_YEN","Ghost_USD","Ghost_GBP","Object","values","forEach","ghost","animationSystem","constructor","state","animationTime","animationDuration","isAnimating","objectStartPositions","console","log","this","cameraStartPosition","cameraEndPosition","x","y","z","cameraStartLookAt","cameraEndLookAt","startHomeAnimation","direction","applyQuaternion","multiplyScalar","update","deltaTime","getDelta","updateHomeAnimation","progress","easedProgress","easeInOutCubic","animateCamera","animateObjectsToCenter","completeHomeAnimation","lerpVectors","currentLookAt","updateProjectionMatrix","centerPosition","keys","ghostKey","index","angle","PI","ghostEndPosition","cos","sin","t","pow","getState","isAnimationActive","render","animate","requestAnimationFrame","async","shadowMap","enabled","type","appendChild","domElement","body","readyState","addEventListener","ambientLight","directionalLight","set","shadow","mapSize","width","height","left","right","top","bottom","near","far","bias","radius","castShadow","setupLighting","aspect","Promise","resolve","reject","gltf","model","traverse","child","name","children","subChild","isMesh","material","push","visible","item","scale","rotation","pacmanActions","animations","clip","action","clipAction","setEffectiveWeight","play","ghostContainer","ghostGroup","startsWith","includes","clonedChild","receiveShadow","node","error","loadModel","setTimeout","init"],"sourceRoot":""}